{"version":3,"sources":["../src/network.ts","../src/http/HttpMethod.ts","../src/http/SimpleHttpClient.ts","../src/signer/signers/utils/utils.ts","../src/signer/signers/utils/index.ts","../src/provider/utils/const/rpc-mapper/rpc-methods.ts","../src/thor-client/accounts/AccountDetail.ts","../src/utils/const/built-in/built-in.ts","../src/utils/const/client/http-client.ts","../src/utils/const/client/nodes.ts","../src/utils/const/client/transactions.ts","../src/utils/const/network/network.ts","../src/utils/const/rpc/rpc.ts","../src/utils/helpers/request.ts","../src/utils/poll/sync.ts","../src/utils/poll/event.ts","../src/utils/poll/index.ts","../src/utils/thorest/helpers.ts","../src/utils/thorest/thorest.ts","../src/utils/subscriptions/beat.ts","../src/utils/subscriptions/block.ts","../src/utils/subscriptions/event.ts","../src/utils/subscriptions/transaction.ts","../src/utils/subscriptions/transfer.ts","../src/utils/subscriptions/index.ts","../src/utils/vns/addresses.ts","../src/utils/vns/index.ts","../src/thor-client/accounts/AccountsModule.ts","../src/thor-client/blocks/blocks-module.ts","../src/thor-client/contracts/model/contract-filter.ts","../src/thor-client/contracts/model/contract-proxy.ts","../src/thor-client/contracts/model/contract.ts","../src/thor-client/contracts/model/contract-factory.ts","../src/thor-client/contracts/contracts-module.ts","../src/thor-client/debug/DebugModule.ts","../src/thor-client/gas/gas-module.ts","../src/thor-client/logs/logs-module.ts","../src/thor-client/nodes/nodes-module.ts","../src/thor-client/gas/helpers/const.ts","../src/thor-client/gas/helpers/decode-evm-error.ts","../src/thor-client/transactions/transactions-module.ts","../src/thor-client/transactions/helpers/delegation-handler.ts","../src/thor-client/fork/forkDetector.ts","../src/thor-client/ThorClient.ts","../src/signer/signers/vechain-abstract-signer/vechain-abstract-signer.ts","../src/signer/signers/vechain-private-key-signer/vechain-private-key-signer.ts","../src/provider/helpers/provider-internal-wallets/abstract-wallet/abstract-provider-internal-wallet.ts","../src/provider/helpers/provider-internal-wallets/base-wallet/provider-internal-base-wallet.ts","../src/provider/helpers/provider-internal-wallets/hd-wallet/provider-internal-hd-wallet.ts","../src/provider/providers/ethers-provider/json-rpc-ethers-provider.ts","../src/provider/utils/const/providers/const.ts","../src/provider/utils/const/blocks/blocks.ts","../src/provider/utils/const/chain-id/chain-id.ts","../src/provider/utils/helpers/transaction/transaction-helpers.ts","../src/provider/utils/formatter/transactions/formatter.ts","../src/provider/utils/formatter/transactions/index.ts","../src/provider/utils/formatter/blocks/formatter.ts","../src/provider/utils/formatter/blocks/index.ts","../src/provider/utils/formatter/debug/formatter.ts","../src/provider/utils/formatter/debug/index.ts","../src/provider/utils/formatter/logs/formatter.ts","../src/provider/utils/rpc-mapper/methods/eth_chainId/eth_chainId.ts","../src/provider/utils/rpc-mapper/methods/eth_getTransactionReceipt/eth_getTransactionReceipt.ts","../src/provider/utils/rpc-mapper/methods/debug_traceTransaction/debug_traceTransaction.ts","../src/provider/utils/rpc-mapper/methods/eth_getBlockByHash/eth_getBlockByHash.ts","../src/provider/utils/rpc-mapper/methods/debug_traceBlockByHash/debug_traceBlockByHash.ts","../src/provider/utils/rpc-mapper/methods/eth_getBlockByNumber/eth_getBlockByNumber.ts","../src/provider/utils/rpc-mapper/methods/debug_traceBlockByNumber/debug_traceBlockByNumber.ts","../src/provider/utils/rpc-mapper/methods/debug_traceCall/debug_traceCall.ts","../src/provider/utils/rpc-mapper/methods/engine_getPayloadBodiesByHashV1/engine_getPayloadBodiesByHashV1.ts","../src/provider/utils/rpc-mapper/methods/engine_getPayloadBodiesByRangeV1/engine_getPayloadBodiesByRangeV1.ts","../src/provider/utils/rpc-mapper/methods/eth_accounts/eth_accounts.ts","../src/provider/utils/rpc-mapper/methods/eth_blockNumber/eth_blockNumber.ts","../src/provider/utils/rpc-mapper/methods/eth_call/eth_call.ts","../src/provider/utils/rpc-mapper/methods/eth_estimateGas/eth_estimateGas.ts","../src/provider/utils/rpc-mapper/methods/eth_feeHistory/eth_feeHistory.ts","../src/provider/utils/rpc-mapper/methods/eth_gasPrice/eth_gasPrice.ts","../src/provider/utils/rpc-mapper/methods/eth_getBalance/eth_getBalance.ts","../src/provider/utils/rpc-mapper/methods/eth_getBlockReceipts/eth_getBlockReceipts.ts","../src/provider/utils/rpc-mapper/methods/eth_getBlockTransactionCountByHash/eth_getBlockTransactionCountByHash.ts","../src/provider/utils/rpc-mapper/methods/eth_getBlockTransactionCountByNumber/eth_getBlockTransactionCountByNumber.ts","../src/provider/utils/rpc-mapper/methods/eth_getCode/eth_getCode.ts","../src/provider/utils/rpc-mapper/methods/eth_getFilterChanges/eth_getFilterChanges.ts","../src/provider/utils/rpc-mapper/methods/eth_getFilterLogs/eth_getFilterLogs.ts","../src/provider/utils/rpc-mapper/methods/eth_getLogs/eth_getLogs.ts","../src/provider/utils/rpc-mapper/methods/eth_getStorageAt/eth_getStorageAt.ts","../src/provider/utils/rpc-mapper/methods/eth_getTransactionByHash/eth_getTransactionByHash.ts","../src/provider/utils/rpc-mapper/methods/eth_getTransactionByBlockHashAndIndex/eth_getTransactionByBlockHashAndIndex.ts","../src/provider/utils/rpc-mapper/methods/eth_getTransactionByBlockNumberAndIndex/eth_getTransactionByBlockNumberAndIndex.ts","../src/provider/utils/rpc-mapper/methods/eth_getTransactionCount/eth_getTransactionCount.ts","../src/provider/utils/rpc-mapper/methods/eth_getUncleByBlockHashAndIndex/eth_getUncleByBlockHashAndIndex.ts","../src/provider/utils/rpc-mapper/methods/eth_getUncleByBlockNumberAndIndex/eth_getUncleByBlockNumberAndIndex.ts","../src/provider/utils/rpc-mapper/methods/eth_getUncleCountByBlockHash/eth_getUncleCountByBlockHash.ts","../src/provider/utils/rpc-mapper/methods/eth_getUncleCountByBlockNumber/eth_getUncleCountByBlockNumber.ts","../src/provider/utils/rpc-mapper/methods/eth_maxPriorityFeePerGas/eth_maxPriorityFeePerGas.ts","../src/provider/utils/rpc-mapper/methods/eth_requestAccounts/eth_requestAccounts.ts","../src/provider/utils/rpc-mapper/methods/eth_sendRawTransaction/eth_sendRawTransaction.ts","../src/provider/utils/rpc-mapper/methods/eth_sendTransaction/eth_sendTransaction.ts","../src/provider/utils/rpc-mapper/methods/eth_signTransaction/eth_signTransaction.ts","../src/provider/utils/rpc-mapper/methods/eth_signTypedData_v4/eth_signTypedData_v4.ts","../src/provider/utils/rpc-mapper/methods/eth_subscribe/eth_subscribe.ts","../src/provider/utils/rpc-mapper/methods/eth_syncing/eth_syncing.ts","../src/provider/utils/rpc-mapper/methods/eth_unsubscribe/eth_unsubscribe.ts","../src/provider/utils/rpc-mapper/methods/evm_mine/evm_mine.ts","../src/provider/utils/rpc-mapper/methods/net_listening/net_listening.ts","../src/provider/utils/rpc-mapper/methods/net_peerCount/net_peerCount.ts","../src/provider/utils/rpc-mapper/methods/net_version/net_version.ts","../src/provider/utils/rpc-mapper/methods/txpool_content/txpool_content.ts","../src/provider/utils/rpc-mapper/methods/txpool_contentFrom/txpool_contentFrom.ts","../src/provider/utils/rpc-mapper/methods/txpool_inspect/txpool_inspect.ts","../src/provider/utils/rpc-mapper/methods/txpool_status/txpool_status.ts","../src/provider/utils/rpc-mapper/methods/web3_clientVersion/web3_clientVersion.ts","../src/provider/utils/rpc-mapper/methods/web3_sha3/web3_sha3.ts","../src/provider/utils/rpc-mapper/rpc-mapper.ts","../src/provider/providers/vechain-provider/vechain-provider.ts","../src/provider/providers/hardhat-provider/hardhat-provider.ts"],"names":["network_exports","__export","AccountDetail","AccountsModule","BUILT_IN_CONTRACTS","BlocksModule","CHAIN_ID","CHAIN_TAG","Contract","ContractFactory","ContractsModule","DebugModule","DefaultBlockToRevision","DelegationHandler","ERROR_SELECTOR","ForkDetector","GasModule","HTTPS_REGEX","HTTP_REGEX","HardhatVeChainProvider","HttpMethod","JSONRPCEthersProvider","LogsModule","MAINNET_URL","NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS","NodesModule","PANIC_SELECTOR","POLLING_INTERVAL","Poll","ProviderInternalBaseWallet","ProviderInternalHDWallet","RPCMethodsMap","RPC_DOCUMENTATION_URL","RPC_METHODS","SimpleHttpClient","TESTNET_URL","THOR_SOLO_URL","ThorClient","TransactionsModule","VeChainAbstractSigner","VeChainPrivateKeySigner","VeChainProvider","blocksFormatter","buildQuery","chainTagToChainId","debugFormatter","debugTraceBlockByHash","debugTraceBlockByNumber","debugTraceCall","debugTraceTransaction","engineGetPayloadBodiesByHashV1","engineGetPayloadBodiesByRangeV1","ethAccounts","ethBlockNumber","ethCall","ethChainId","ethEstimateGas","ethFeeHistory","ethGasPrice","ethGetBalance","ethGetBlockByHash","ethGetBlockByNumber","ethGetBlockReceipts","ethGetBlockTransactionCountByHash","ethGetBlockTransactionCountByNumber","ethGetCode","ethGetFilterChanges","ethGetFilterLogs","ethGetLogs","ethGetStorageAt","ethGetTransactionByBlockHashAndIndex","ethGetTransactionByBlockNumberAndIndex","ethGetTransactionByHash","ethGetTransactionCount","ethGetTransactionReceipt","ethGetUncleByBlockHashAndIndex","ethGetUncleByBlockNumberAndIndex","ethGetUncleCountByBlockHash","ethGetUncleCountByBlockNumber","ethMaxPriorityFeePerGas","ethRequestAccounts","ethSendRawTransaction","ethSendTransaction","ethSignTransaction","ethSignTypedDataV4","ethSubscribe","ethSyncing","ethUnsubscribe","evmMine","formatToLogsRPC","formatToRPCStandard","getCachedChainId","getCachedChainTag","getCriteriaSetForInput","getNumberOfLogsAheadOfTransactionIntoBlockExpanded","getTransactionIndexIntoBlock","netListening","netPeerCount","netVersion","sanitizeWebsocketBaseURL","signerUtils","subscriptions","thorest","toQueryString","transactionsFormatter","txPoolContent","txPoolContentFrom","txPoolInspect","txPoolStatus","vnsUtils","web3ClientVersion","web3Sha3","_SimpleHttpClient","baseURL","headers","timeout","path","params","url","method","controller","timeoutId","key","value","error","InvalidHTTPParams","response","responseHeaders","errorMessage","InvalidHTTPRequest","transactionBodyToTransactionRequestInput","transactionBody","from","VET","Units","FixedPointNumber","VTHO","accountData","PARAMS_ADDRESS","ENERGY_ADDRESS","PARAMS_ABI","ENERGY_ABI","Keccak256","Txt","definedParams","sleep","delayInMilliseconds","resolve","SyncPoll","pollingFunction","options","InvalidDataType","currentIteration","currentResult","pollingCondition","startTime","condition","isConditionSatisfied","isMaximumIterationsReached","isTimeLimitReached","PollExecution","EventPoll","EventEmitter","requestIntervalInMilliseconds","hasToStopOnError","data","onDataCallback","onErrorCallback","onStartCallback","onStopCallback","createEventPoll","callBack","queryParts","urlRegex","address","position","revision","id","queryParams","blockCount","newestBlock","rewardPercentiles","getLegacyBeatSubscriptionUrl","getBeatSubscriptionUrl","getBlockSubscriptionUrl","getEventSubscriptionUrl","event","indexedValues","encodedTopics","ABIEvent","getNewTransactionsSubscriptionUrl","getVETtransfersSubscriptionUrl","NetworkContracts","MAINNET_NETWORK","TESTNET_NETWORK","SOLO_NETWORK","resolveName","thorClient","name","resolveNames","blocksModule","transactionsModule","names","genesisBlock","Address","resolveUtilsAddress","callGetAddresses","ABIItem","ABIFunction","addresses","ZERO_ADDRESS","lookupAddress","lookupAddresses","callGetNames","httpClient","result","HexUInt","pos","Revision","bestBlock","blockNumber","expanded","block","transaction","clause","output","transfer","ContractFilter","contract","criteriaSet","param","filterEventLogsOptions","getReadProxy","_target","prop","args","extractOptionsResult","extractAndRemoveAdditionalOptions","clauseComment","revisionValue","functionAbi","executeCallResult","ContractCallError","getTransactProxy","InvalidTransactionField","transactionOptions","extractAdditionalOptionsResult","transactionValue","getFilterProxy","buildCriteria","getClauseProxy","Clause","getCriteriaProxy","eventAbi","topics","topic","index","getTransactionValue","getClauseComment","clauseRevision","getRevision","arg","isTransactionValue","isTransactionComment","isRevision","obj","abi","contractsModule","signer","transactionReceipt","ABIContract","eventName","bytecode","deployParams","deployContractClause","gasResult","txBody","signedTx","Transaction","CannotFindTransaction","ContractDeploymentFailed","contractAddress","functionData","contractCallOptions","clauses","input","parsedTarget","target","functionName","caller","filterOptions","eventAbis","c","eventLogs","uniqueEventAbis","log","InvalidAbiItem","Hex","f","filterRawEventLogsOptions","lastBlockTimestamp","secondsSinceLastBlock","SOLIDITY_ERROR_SELECTOR","SOLIDITY_PANIC_SELECTOR","decodeRevertReason","ABI","decoded","debugModule","logsModule","gasModule","forkDetector","ThorId","raw","transactionResult","rawTx","txID","gas","blockRef","chainTag","filledOptions","body","extractedOptions","galacticaHappened","bestBlockBaseFeePerGas","biBestBlockBaseFeePerGas","defaultMaxPriorityFeePerGas","biMaxPriorityFeePerGas","biMaxFeePerGas","baseFee","feeHistory","percentile75","latestBlockRewards","sum","count","blockRewards","baseFeeCap","priorityFee","uniqueNames","map","nameList","gasPrice","gasPayer","expiration","provedWork","encodedRevertReason","errorFragment","Interface","ErrorFragment","transactionHash","transactionIndex","transactionClauseIndex","debuggedClause","simulations","isReverted","simulation","intrinsicGas","totalSimulatedGas","totalGas","res","dataUtils","encodedData","reverted","encodedResult","plain","array","_getDelegationSignature","tx","gasPayerServiceUrl","originAddress","sponsorRequestBody","NotDelegatedTransaction","gasPayerIsUndefined","isDelegatedWithUrl","isDelegatedWithPrivateKey","galacticaForkCache","NEGATIVE_CACHE_TTL","galacticaForkDetected","revisionKey","cachedResult","now","_ThorClient","networkUrl","provider","transactionToPopulate","JSONRPCInvalidParams","populatedTransaction","totalGasResult","transactionToEstimate","transactionToEvaluate","blockTag","message","payload","payloadHashed","concatBytes","SignerMethodError","types","parents","type","field","primaryTypes","n","domain","primaryType","hashTypedData","vnsName","_VeChainPrivateKeySigner","privateKey","Secp256k1","InvalidSecp256k1PrivateKey","transactionToSign","transactionToSend","signedTransaction","sign","unsignedTransactionBody","originPrivateKey","gasPayerOptions","unsignedTx","gasPayerSignature","originSignature","signature","AbstractProviderInternalWallet","accounts","parentProvider","addressOrIndex","signerAccount","account","mnemonic","initialIndex","derivationPath","HDKey","privateKeyBuffer","JsonRpcApiProvider","chainId","networkName","hardhatProvider","requestPayloadArray","responses","jsonRpcPayload","e","stringifyData","defaultBlockTags","defaultBlock","defaultBlockValue","JSONRPCInvalidDefaultBlock","hash","idx","blockExpanded","transactionId","logIndex","currentTransaction","mapVeChainTypeToEthereumType","vechainType","fromTransactionType","TransactionType","_formatTransactionToRPC","blockHash","txIndex","txType","Quantity","formatExpandedBlockToRPCStandard","formatTransactionReceiptToRPCStandard","receipt","blockContainsTransaction","logIndexOffset","logs","ZERO_BYTES","transactions","tracerName","debugDetails","valueWithoutEnergy","eventLog","HexInt","_scatterArrayTopic","criteriaTopicsArray","criteria","criteriaAddress","addr","getTopicsPerAddress","notArrayTopics","arrayTopics","cachedChainId","cachedChainTag","cachedGenesisBlockId","JSONRPCInternalError","transactionDetail","traceOptions","tracerToUse","trace","isTxDetail","traces","tracerOptions","VeChainSDKLogger","latestBlock","inputOptions","simulatedTx","estimatedGas","_provider","JSONRPCMethodNotImplemented","blockCountNum","baseFeePerGas","maxPriorityFeePerGas","priority","transactionsIntoTheBlock","transactionReceipts","MAX_LIMIT","storagePosition","_params","signedTransactionData","typedData","JSONRPCServerError","subscriptionId","_isBlockNotOutOfSyncInTime","highestBlockNumber","head","wallet","enableDelegation","JSONRPCMethodNotFound","methodsMap","currentBlock","subscriptionEvents","promises","subscriptionDetails","walletToUse","nodeUrl","buildHardhatErrorFunctionCallback","debug","rpcConfiguration","callback","mustReturn0","VechainSDKError"],"mappings":"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","file":"index.js","sourcesContent":["export * from './http';\nexport * from './provider';\nexport * from './signer';\nexport * from './thor-client';\nexport * from './utils';\n","/**\n * Enumeration for HTTP methods.\n *\n * @property {string} GET - The GET method requests a representation of the specified resource.\n * @property {string} POST - The POST method is used to submit data to be processed to a specified resource.\n */\nexport enum HttpMethod {\n    GET = 'GET',\n    POST = 'POST'\n}\n","import { HttpMethod } from './HttpMethod';\nimport { InvalidHTTPParams, InvalidHTTPRequest } from '@vechain/sdk-errors';\nimport { type HttpClient } from './HttpClient';\nimport { type HttpParams } from './HttpParams';\n\n/**\n * This class implements the HttpClient interface using the Fetch API.\n *\n * The SimpleHttpClient allows making {@link HttpMethod} requests with timeout\n * and base URL configuration.\n */\nclass SimpleHttpClient implements HttpClient {\n    /**\n     * Represent the default timeout duration for network requests in milliseconds.\n     */\n    public static readonly DEFAULT_TIMEOUT = 30000;\n\n    /**\n     * Return the root URL for the API endpoints.\n     */\n    public readonly baseURL: string;\n\n    public readonly headers: HeadersInit;\n\n    /**\n     * Return the amount of time in milliseconds before a timeout occurs\n     * when requesting with HTTP methods.\n     */\n    public readonly timeout: number;\n\n    /**\n     * Constructs an instance of SimpleHttpClient with the given base URL,\n     * timeout period and HTTP headers.\n     * The HTTP headers are used each time this client send a request to the URL,\n     * if not overwritten by the {@link HttpParams} of the method sending the request.\n     *\n     * @param {string} baseURL - The base URL for HTTP requests.\n     * @param {HeadersInit} [headers=new Headers()] - The default headers for HTTP requests.\n     * @param {number} [timeout=SimpleHttpClient.DEFAULT_TIMEOUT] - The timeout duration in milliseconds.\n     */\n    constructor(\n        baseURL: string,\n        headers: HeadersInit = new Headers(),\n        timeout: number = SimpleHttpClient.DEFAULT_TIMEOUT\n    ) {\n        this.baseURL = baseURL;\n        this.timeout = timeout;\n        this.headers = headers;\n    }\n\n    /**\n     * Sends an HTTP GET request to the specified path with optional query parameters.\n     *\n     * @param {string} path - The endpoint path to which the HTTP GET request is sent.\n     * @param {HttpParams} [params] - Optional parameters for the request,\n     * including query parameters, headers, body, and response validation.\n     * {@link HttpParams.headers} override {@link SimpleHttpClient.headers}.\n     * @return {Promise<unknown>} A promise that resolves with the response of the GET request.\n     */\n    public async get(path: string, params?: HttpParams): Promise<unknown> {\n        return await this.http(HttpMethod.GET, path, params);\n    }\n\n    /**\n     * Determines if specified url is valid\n     * @param {string} url Url to check\n     * @returns {boolean} if value\n     */\n    private isValidUrl(url: string): boolean {\n        try {\n            // eslint-disable-next-line no-new\n            new URL(url);\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Executes an HTTP request with the specified method, path, and optional parameters.\n     *\n     * @param {HttpMethod} method - The HTTP method to use for the request (e.g., GET, POST).\n     * @param {string} path - The URL path for the request. Leading slashes will be automatically removed.\n     * @param {HttpParams} [params] - Optional parameters for the request,\n     * including query parameters, headers, body, and response validation.\n     * {@link HttpParams.headers} override {@link SimpleHttpClient.headers}.\n     * @return {Promise<unknown>} A promise that resolves to the response of the HTTP request.\n     * @throws {InvalidHTTPRequest} Throws an error if the HTTP request fails.\n     */\n    public async http(\n        method: HttpMethod,\n        path: string,\n        params?: HttpParams\n    ): Promise<unknown> {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => {\n            controller.abort();\n        }, this.timeout);\n        // setup\n        let url: URL;\n        try {\n            // Remove leading slash from path\n            if (path.startsWith('/')) {\n                path = path.slice(1);\n            }\n            // Add trailing slash from baseURL if not present\n            let baseURL = this.baseURL;\n            if (!baseURL.endsWith('/')) {\n                baseURL += '/';\n            }\n            url = new URL(path, baseURL);\n            if (params?.query != null) {\n                Object.entries(params.query).forEach(([key, value]) => {\n                    url.searchParams.append(key, String(value));\n                });\n            }\n            const headers = new Headers(this.headers);\n            if (params?.headers !== undefined && params?.headers != null) {\n                Object.entries(params.headers).forEach(([key, value]) => {\n                    headers.append(key, String(value));\n                });\n            }\n        } catch (error) {\n            throw new InvalidHTTPParams(\n                'HttpClient.http()',\n                (error as Error).message,\n                {\n                    method,\n                    url: !this.isValidUrl(this.baseURL)\n                        ? path\n                        : new URL(path, this.baseURL).toString()\n                },\n                error\n            );\n        }\n        // send request\n        try {\n            const response = await fetch(url, {\n                method,\n                headers: params?.headers as HeadersInit,\n                body:\n                    method !== HttpMethod.GET\n                        ? JSON.stringify(params?.body)\n                        : undefined,\n                signal: controller.signal\n            });\n            if (response.ok) {\n                const responseHeaders = Object.fromEntries(\n                    response.headers.entries()\n                );\n                if (\n                    params?.validateResponseHeader != null &&\n                    responseHeaders != null\n                ) {\n                    params.validateResponseHeader(responseHeaders);\n                }\n                return (await response.json()) as unknown;\n            }\n            // get error message from response\n            const errorMessage = await response.clone().text();\n            throw new Error(\n                `HTTP ${response.status} ${response.statusText} ${errorMessage}`,\n                {\n                    cause: response\n                }\n            );\n        } catch (error) {\n            throw new InvalidHTTPRequest(\n                'HttpClient.http()',\n                (error as Error).message,\n                {\n                    method,\n                    url: !this.isValidUrl(this.baseURL)\n                        ? path\n                        : new URL(path, this.baseURL).toString()\n                },\n                error\n            );\n        } finally {\n            clearTimeout(timeoutId);\n        }\n    }\n\n    /**\n     * Makes an HTTP POST request to the specified path with optional parameters.\n     *\n     * @param {string} path - The endpoint to which the POST request is made.\n     * @param {HttpParams} [params] - Optional parameters for the request,\n     * including query parameters, headers, body, and response validation.\n     * {@link HttpParams.headers} override {@link SimpleHttpClient.headers}.\n     * @return {Promise<unknown>} A promise that resolves with the response from the server.\n     */\n    public async post(path: string, params?: HttpParams): Promise<unknown> {\n        return await this.http(HttpMethod.POST, path, params);\n    }\n}\n\nexport { SimpleHttpClient };\n","import { type TransactionBody } from '@vechain/sdk-core';\nimport { type TransactionRequestInput } from '../types';\n\n/**\n * Utility method to convert a transaction body to a transaction request input\n *\n * @param transactionBody - The transaction body to convert\n * @param from - The address of the sender\n *\n * @returns The transaction request input\n * @throws Error if nonce is negative\n */\nfunction transactionBodyToTransactionRequestInput(\n    transactionBody: TransactionBody,\n    from: string\n): TransactionRequestInput {\n    // Validate that nonce is not negative\n    if (transactionBody.nonce !== undefined) {\n        const nonceValue =\n            typeof transactionBody.nonce === 'string'\n                ? parseInt(transactionBody.nonce, 10)\n                : transactionBody.nonce;\n\n        if (nonceValue < 0) {\n            throw new Error('Transaction nonce must be a positive number');\n        }\n    }\n\n    return {\n        from,\n        chainTag: transactionBody.chainTag,\n        blockRef: transactionBody.blockRef,\n        expiration: transactionBody.expiration,\n        clauses: transactionBody.clauses,\n        gasPriceCoef: transactionBody.gasPriceCoef,\n        gas: transactionBody.gas,\n        dependsOn: transactionBody.dependsOn ?? undefined,\n        nonce: transactionBody.nonce,\n        reserved: transactionBody.reserved,\n        maxPriorityFeePerGas: transactionBody.maxPriorityFeePerGas ?? undefined,\n        maxFeePerGas: transactionBody.maxFeePerGas ?? undefined\n    } satisfies TransactionRequestInput;\n}\n\nexport { transactionBodyToTransactionRequestInput };\n","import { transactionBodyToTransactionRequestInput } from './utils';\n\nconst signerUtils = {\n    transactionBodyToTransactionRequestInput\n};\nexport { signerUtils };\n","/**\n * List of all valid ethereum RPC methods\n *\n * @note following links for more details:\n * * https://eth.wiki/json-rpc/API\n * * https://ethereum.github.io/execution-apis/api-documentation/\n */\nenum RPC_METHODS {\n    /**\n     * IMPLEMENTED METHODS:\n     */\n    eth_blockNumber = 'eth_blockNumber',\n    eth_chainId = 'eth_chainId',\n    eth_getBalance = 'eth_getBalance',\n    eth_getCode = 'eth_getCode',\n    eth_getStorageAt = 'eth_getStorageAt',\n    eth_estimateGas = 'eth_estimateGas',\n    eth_call = 'eth_call',\n    eth_sendRawTransaction = 'eth_sendRawTransaction',\n    eth_getLogs = 'eth_getLogs',\n    eth_getBlockByHash = 'eth_getBlockByHash',\n    eth_getBlockByNumber = 'eth_getBlockByNumber',\n    eth_accounts = 'eth_accounts',\n    eth_requestAccounts = 'eth_requestAccounts',\n    eth_gasPrice = 'eth_gasPrice',\n    eth_getTransactionByHash = 'eth_getTransactionByHash',\n    eth_getTransactionCount = 'eth_getTransactionCount',\n    eth_getTransactionReceipt = 'eth_getTransactionReceipt',\n    eth_getTransactionByBlockNumberAndIndex = 'eth_getTransactionByBlockNumberAndIndex',\n    eth_getTransactionByBlockHashAndIndex = 'eth_getTransactionByBlockHashAndIndex',\n    eth_getBlockTransactionCountByHash = 'eth_getBlockTransactionCountByHash',\n    eth_getBlockTransactionCountByNumber = 'eth_getBlockTransactionCountByNumber',\n    eth_sendTransaction = 'eth_sendTransaction',\n    eth_syncing = 'eth_syncing',\n    net_version = 'net_version',\n    web3_clientVersion = 'web3_clientVersion',\n    eth_subscribe = 'eth_subscribe',\n    eth_unsubscribe = 'eth_unsubscribe',\n    debug_traceTransaction = 'debug_traceTransaction',\n    debug_traceCall = 'debug_traceCall',\n    evm_mine = 'evm_mine',\n    evm_increaseTime = 'evm_increaseTime', // Uses evm_mine under the hood, required for hardhat\n    web3_sha3 = 'web3_sha3',\n    net_peerCount = 'net_peerCount',\n    net_listening = 'net_listening',\n    eth_getUncleByBlockNumberAndIndex = 'eth_getUncleByBlockNumberAndIndex',\n    eth_getUncleByBlockHashAndIndex = 'eth_getUncleByBlockHashAndIndex',\n    txpool_inspect = 'txpool_inspect',\n    txpool_contentFrom = 'txpool_contentFrom',\n    txpool_content = 'txpool_content',\n    txpool_status = 'txpool_status',\n    eth_signTransaction = 'eth_signTransaction',\n    debug_traceBlockByHash = 'debug_traceBlockByHash',\n    debug_traceBlockByNumber = 'debug_traceBlockByNumber',\n    eth_getUncleCountByBlockHash = 'eth_getUncleCountByBlockHash',\n    eth_getUncleCountByBlockNumber = 'eth_getUncleCountByBlockNumber',\n    eth_signTypedData_v4 = 'eth_signTypedData_v4',\n    eth_getBlockReceipts = 'eth_getBlockReceipts',\n\n    /**\n     * TO BE IMPLEMENTED METHODS:\n     * Add to packages/network/src/provider/utils/rpc-mapper/methods/index.ts to implement\n     */\n    eth_coinbase = 'eth_coinbase',\n    eth_feeHistory = 'eth_feeHistory',\n    eth_getWork = 'eth_getWork',\n    eth_mining = 'eth_mining',\n    eth_hashrate = 'eth_hashrate',\n    eth_protocolVersion = 'eth_protocolVersion',\n    eth_sign = 'eth_sign',\n    eth_submitWork = 'eth_submitWork',\n    parity_nextNonce = 'parity_nextNonce',\n    eth_newFilter = 'eth_newFilter',\n    eth_newBlockFilter = 'eth_newBlockFilter',\n    eth_newPendingTransactionFilter = 'eth_newPendingTransactionFilter',\n    eth_getFilterLogs = 'eth_getFilterLogs',\n    eth_getFilterChanges = 'eth_getFilterChanges',\n    eth_uninstallFilter = 'eth_uninstallFilter',\n    debug_getBadBlocks = 'debug_getBadBlocks',\n    debug_getRawBlock = 'debug_getRawBlock',\n    debug_getRawHeader = 'debug_getRawHeader',\n    debug_getRawReceipts = 'debug_getRawReceipts',\n    debug_getRawTransaction = 'debug_getRawTransaction',\n    engine_exchangeCapabilities = 'engine_exchangeCapabilities',\n    engine_exchangeTransitionConfigurationV1 = 'engine_exchangeTransitionConfigurationV1',\n    engine_forkchoiceUpdatedV1 = 'engine_forkchoiceUpdatedV1',\n    engine_forkchoiceUpdatedV2 = 'engine_forkchoiceUpdatedV2',\n    engine_forkchoiceUpdatedV3 = 'engine_forkchoiceUpdatedV3',\n    engine_getPayloadBodiesByHashV1 = 'engine_getPayloadBodiesByHashV1',\n    engine_getPayloadBodiesByRangeV1 = 'engine_getPayloadBodiesByRangeV1',\n    engine_getPayloadV1 = 'engine_getPayloadV1',\n    engine_getPayloadV2 = 'engine_getPayloadV2',\n    engine_getPayloadV3 = 'engine_getPayloadV3',\n    engine_newPayloadV1 = 'engine_newPayloadV1',\n    engine_newPayloadV2 = 'engine_newPayloadV2',\n    engine_newPayloadV3 = 'engine_newPayloadV3',\n    eth_createAccessList = 'eth_createAccessList',\n    eth_getProof = 'eth_getProof',\n    eth_maxPriorityFeePerGas = 'eth_maxPriorityFeePerGas'\n}\n\nexport { RPC_METHODS };\n","import { FixedPointNumber, Units, VET, VTHO } from '@vechain/sdk-core';\nimport { type AccountData } from './AccountData';\n\n/**\n * Represents detailed account information.\n *\n * Implements the {@link AccountData} interface.\n */\nclass AccountDetail implements AccountData {\n    /**\n     * Return the hexadecimal expression of the wei VET value of the balance.\n     */\n    readonly balance: string;\n\n    /**\n     * Return the hexadecimal expression of the wei VTHO value of the energy balance.\n     */\n    readonly energy: string;\n\n    /**\n     * Return `true` if the account is a smart contract, otherwise `false`.\n     */\n    readonly hasCode: boolean;\n\n    /**\n     * Returns the balance of the account in {@link VET}.\n     */\n    get vet(): VET {\n        return VET.of(Units.formatEther(FixedPointNumber.of(this.balance)));\n    }\n\n    /**\n     * Returns the energy balance of the account in {@link VTHO}.\n     */\n    get vtho(): VTHO {\n        return VTHO.of(Units.formatEther(FixedPointNumber.of(this.energy)));\n    }\n\n    /**\n     * Constructs a new instance of the class.\n     *\n     * @param {AccountData} accountData - The data to initialize the account with.\n     */\n    constructor(accountData: AccountData) {\n        this.balance = accountData.balance;\n        this.energy = accountData.energy;\n        this.hasCode = accountData.hasCode;\n    }\n}\n\nexport { AccountDetail };\n","/**\n * Address of the Params built-in contract.\n *\n * @link see [params.sol](https://docs.vechain.org/developer-resources/built-in-contracts#params-sol)\n */\nconst PARAMS_ADDRESS = '0x0000000000000000000000000000506172616d73';\n\n/**\n * Address of the Energy built-in contract.\n *\n * @link see [energy.sol](https://docs.vechain.org/developer-resources/built-in-contracts#energy-sol)\n */\nconst ENERGY_ADDRESS = '0x0000000000000000000000000000456e65726779';\n\n/**\n * ABI of the Params built-in contract.\n *\n * @link see [params.sol](https://docs.vechain.org/developer-resources/built-in-contracts#params-sol)\n */\nconst PARAMS_ABI = [\n    {\n        constant: false,\n        inputs: [\n            {\n                name: '_key',\n                type: 'bytes32'\n            },\n            {\n                name: '_value',\n                type: 'uint256'\n            }\n        ],\n        name: 'set',\n        outputs: [],\n        payable: false,\n        stateMutability: 'nonpayable',\n        type: 'function'\n    },\n    {\n        constant: true,\n        inputs: [\n            {\n                name: '_key',\n                type: 'bytes32'\n            }\n        ],\n        name: 'get',\n        outputs: [\n            {\n                name: '',\n                type: 'uint256'\n            }\n        ],\n        payable: false,\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        constant: true,\n        inputs: [],\n        name: 'executor',\n        outputs: [\n            {\n                name: '',\n                type: 'address'\n            }\n        ],\n        payable: false,\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                name: 'key',\n                type: 'bytes32'\n            },\n            {\n                indexed: false,\n                name: 'value',\n                type: 'uint256'\n            }\n        ],\n        name: 'Set',\n        type: 'event'\n    }\n] as const;\n\n/**\n * ABI of the Energy built-in contract. (VTHO)\n *\n * @link see [energy.sol](https://docs.vechain.org/developer-resources/built-in-contracts#energy-sol)\n */\nconst ENERGY_ABI = [\n    {\n        constant: true,\n        inputs: [],\n        name: 'name',\n        outputs: [\n            {\n                name: '',\n                type: 'string'\n            }\n        ],\n        payable: false,\n        stateMutability: 'pure',\n        type: 'function'\n    },\n    {\n        constant: false,\n        inputs: [\n            {\n                name: '_spender',\n                type: 'address'\n            },\n            {\n                name: '_value',\n                type: 'uint256'\n            }\n        ],\n        name: 'approve',\n        outputs: [\n            {\n                name: 'success',\n                type: 'bool'\n            }\n        ],\n        payable: false,\n        stateMutability: 'nonpayable',\n        type: 'function'\n    },\n    {\n        constant: true,\n        inputs: [],\n        name: 'totalSupply',\n        outputs: [\n            {\n                name: '',\n                type: 'uint256'\n            }\n        ],\n        payable: false,\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        constant: false,\n        inputs: [\n            {\n                name: '_from',\n                type: 'address'\n            },\n            {\n                name: '_to',\n                type: 'address'\n            },\n            {\n                name: '_amount',\n                type: 'uint256'\n            }\n        ],\n        name: 'transferFrom',\n        outputs: [\n            {\n                name: 'success',\n                type: 'bool'\n            }\n        ],\n        payable: false,\n        stateMutability: 'nonpayable',\n        type: 'function'\n    },\n    {\n        constant: true,\n        inputs: [],\n        name: 'decimals',\n        outputs: [\n            {\n                name: '',\n                type: 'uint8'\n            }\n        ],\n        payable: false,\n        stateMutability: 'pure',\n        type: 'function'\n    },\n    {\n        constant: true,\n        inputs: [\n            {\n                name: '_owner',\n                type: 'address'\n            }\n        ],\n        name: 'balanceOf',\n        outputs: [\n            {\n                name: 'balance',\n                type: 'uint256'\n            }\n        ],\n        payable: false,\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        constant: true,\n        inputs: [],\n        name: 'symbol',\n        outputs: [\n            {\n                name: '',\n                type: 'string'\n            }\n        ],\n        payable: false,\n        stateMutability: 'pure',\n        type: 'function'\n    },\n    {\n        constant: false,\n        inputs: [\n            {\n                name: '_to',\n                type: 'address'\n            },\n            {\n                name: '_amount',\n                type: 'uint256'\n            }\n        ],\n        name: 'transfer',\n        outputs: [\n            {\n                name: 'success',\n                type: 'bool'\n            }\n        ],\n        payable: false,\n        stateMutability: 'nonpayable',\n        type: 'function'\n    },\n    {\n        constant: false,\n        inputs: [\n            {\n                name: '_from',\n                type: 'address'\n            },\n            {\n                name: '_to',\n                type: 'address'\n            },\n            {\n                name: '_amount',\n                type: 'uint256'\n            }\n        ],\n        name: 'move',\n        outputs: [\n            {\n                name: 'success',\n                type: 'bool'\n            }\n        ],\n        payable: false,\n        stateMutability: 'nonpayable',\n        type: 'function'\n    },\n    {\n        constant: true,\n        inputs: [],\n        name: 'totalBurned',\n        outputs: [\n            {\n                name: '',\n                type: 'uint256'\n            }\n        ],\n        payable: false,\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        constant: true,\n        inputs: [\n            {\n                name: '_owner',\n                type: 'address'\n            },\n            {\n                name: '_spender',\n                type: 'address'\n            }\n        ],\n        name: 'allowance',\n        outputs: [\n            {\n                name: 'remaining',\n                type: 'uint256'\n            }\n        ],\n        payable: false,\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                name: '_from',\n                type: 'address'\n            },\n            {\n                indexed: true,\n                name: '_to',\n                type: 'address'\n            },\n            {\n                indexed: false,\n                name: '_value',\n                type: 'uint256'\n            }\n        ],\n        name: 'Transfer',\n        type: 'event'\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                name: '_owner',\n                type: 'address'\n            },\n            {\n                indexed: true,\n                name: '_spender',\n                type: 'address'\n            },\n            {\n                indexed: false,\n                name: '_value',\n                type: 'uint256'\n            }\n        ],\n        name: 'Approval',\n        type: 'event'\n    }\n] as const;\n\n/**\n * Built-in contracts.\n */\nexport const BUILT_IN_CONTRACTS = {\n    PARAMS_ABI,\n    PARAMS_ADDRESS,\n    ENERGY_ABI,\n    ENERGY_ADDRESS\n};\n","/**\n * HTTP regex.\n */\nconst HTTP_REGEX: RegExp = /^http:\\/\\//;\n\n/**\n * HTTPS regex.\n */\nconst HTTPS_REGEX: RegExp = /^https:\\/\\//;\n\nexport { HTTP_REGEX, HTTPS_REGEX };\n","/**\n * Node healthcheck Tolerance in seconds.\n * @example When set to 30, it means that we consider a node healthy even when it's off-sync by roughly 3 blocks.\n */\nconst NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS = 30;\n\nexport { NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS };\n","import { Keccak256, Txt } from '@vechain/sdk-core';\n\n/**\n * The selector for the error event.\n */\nconst ERROR_SELECTOR = Keccak256.of(Txt.of('Error(string)').bytes)\n    .toString()\n    .slice(0, 10);\n\n/**\n * The selector for the panic event.\n */\nconst PANIC_SELECTOR = Keccak256.of(Txt.of('Panic(uint256)').bytes)\n    .toString()\n    .slice(0, 10);\n\nexport { ERROR_SELECTOR, PANIC_SELECTOR };\n","/**\n * Url of the mainnet\n */\nconst MAINNET_URL = 'https://mainnet.vechain.org';\n\n/**\n * Url of the testnet\n */\nconst TESTNET_URL = 'https://testnet.vechain.org';\n\n/**\n * Url of the solo network\n * Using explicit IPv4 (127.0.0.1) instead of localhost to avoid IPv6 resolution issues in CI\n */\nconst THOR_SOLO_URL = 'http://localhost:8669';\n\nexport { MAINNET_URL, TESTNET_URL, THOR_SOLO_URL };\n","/**\n * Documentation link of RPC methods\n */\nconst RPC_DOCUMENTATION_URL =\n    'https://ethereum.github.io/execution-apis/api-documentation/';\n\nexport { RPC_DOCUMENTATION_URL };\n","/**\n * Constructs a query object for HTTP requests by filtering out undefined values.\n *\n * @param params - An object containing the query parameters with potential undefined values.\n * @returns An object containing only the defined query parameters.\n */\nconst buildQuery = (\n    params: Record<string, string | boolean | undefined>\n): Record<string, string> => {\n    const definedParams: Record<string, string> = {};\n\n    // Iterate over each property in the params object\n    for (const key in params) {\n        // Check if the value is not undefined\n        if (params[key] !== undefined) {\n            // If the value is defined, add it to the definedParams object\n            definedParams[key] = params[key] as string;\n        }\n    }\n\n    return definedParams;\n};\n\nexport { buildQuery };\n","import { type SyncPollInputOptions } from './types';\nimport { InvalidDataType, PollExecution } from '@vechain/sdk-errors';\n\n/**\n * Sleep for a given amount of time (in milliseconds).\n *\n * @param delayInMilliseconds - The amount of time to sleep in milliseconds.\n */\nasync function sleep(delayInMilliseconds: number): Promise<void> {\n    await new Promise((resolve) => setTimeout(resolve, delayInMilliseconds));\n}\n\n/**\n * Poll until the condition is met.\n *\n * @note: Be careful!, this function is synchronous and will block the thread until the condition is met.\n * Thus mean it can run forever if the condition is never met.\n * To avoid infinite loop, you can use the `options.maximumIterations` parameter.\n *\n * @example It can be used to wait until:\n *  - A balance is updated after a transaction is sent\n *  - A transaction is mined\n *  - A block is mined\n *  ...\n *\n * @param pollingFunction - The function to be called.\n * @param options - Polling options. @see {SyncPollInputOptions} type. If not specified, the default values are used. In particular: `requestIntervalInMilliseconds` is 1000, `maximumIterations` is not specified\n *                  and `maximumWaitingTimeInMilliseconds` is not specified.\n * @returns An object with a `waitUntil` method. It blocks execution until the condition is met. When the condition is met, it returns the result of the poll.\n * @throws {InvalidDataType, PollExecution}\n */\nfunction SyncPoll<TReturnType>(\n    pollingFunction: () => Promise<TReturnType> | TReturnType,\n    options?: SyncPollInputOptions\n): {\n    waitUntil: (\n        condition: (data: TReturnType) => boolean\n    ) => Promise<TReturnType>;\n} {\n    // Positive number for the request interval\n    if (\n        options?.requestIntervalInMilliseconds !== undefined &&\n        (options.requestIntervalInMilliseconds <= 0 ||\n            !Number.isInteger(options.requestIntervalInMilliseconds))\n    ) {\n        throw new InvalidDataType(\n            'SyncPoll()',\n            'Polling failed: Invalid input for field \"options?.requestIntervalInMilliseconds\" it must be a positive number',\n            {\n                requestIntervalInMilliseconds:\n                    options.requestIntervalInMilliseconds\n            }\n        );\n    }\n\n    // Positive number for maximum iterations\n    if (\n        options?.maximumIterations !== undefined &&\n        (options.maximumIterations <= 0 ||\n            !Number.isInteger(options.maximumIterations))\n    ) {\n        throw new InvalidDataType(\n            'SyncPoll()',\n            'Polling failed: Invalid input for field \"options?.maximumIterations\" it must be a positive number',\n            {\n                maximumIterations: options.maximumIterations\n            }\n        );\n    }\n\n    // Positive number for maximum waiting time\n    if (\n        options?.maximumWaitingTimeInMilliseconds !== undefined &&\n        (options.maximumWaitingTimeInMilliseconds <= 0 ||\n            !Number.isInteger(options.maximumWaitingTimeInMilliseconds))\n    ) {\n        throw new InvalidDataType(\n            'SyncPoll()',\n            'Polling failed: Invalid input for field \"options?.maximumWaitingTimeInMilliseconds\" it must be a positive number',\n            {\n                maximumWaitingTimeInMilliseconds:\n                    options.maximumWaitingTimeInMilliseconds\n            }\n        );\n    }\n\n    // Number of iterations\n    let currentIteration = 0;\n\n    // Current result\n    let currentResult: TReturnType;\n\n    // Polling condition\n    let pollingCondition: boolean = false;\n\n    // Initialize the start time\n    const startTime = Date.now();\n\n    return {\n        /**\n         * Poll until the condition is met.\n         *\n         * @param condition - The condition to be met.\n         * @returns The result of the poll after the condition is met.\n         */\n        waitUntil: async (\n            condition: (data: TReturnType) => boolean\n        ): Promise<TReturnType> => {\n            try {\n                do {\n                    // 1 - Fetch the result of promise\n                    currentResult = await pollingFunction();\n\n                    // 2 - Sleep for the interval (in a synchronous way)\n                    await sleep(options?.requestIntervalInMilliseconds ?? 1000);\n\n                    // 3 - Increment the current iteration\n                    currentIteration = currentIteration + 1;\n\n                    // 4 - Check if the poll should be stopped (in a forced way OR not)\n                    // 4.1 - If the condition is met or not\n                    const isConditionSatisfied = condition(currentResult);\n\n                    // 4.2 - Stop forced on iterations\n                    const isMaximumIterationsReached =\n                        options?.maximumIterations !== undefined\n                            ? currentIteration >= options.maximumIterations\n                            : false;\n\n                    // 4.3 - Stop forced on maximum waiting time\n                    const isTimeLimitReached =\n                        options?.maximumWaitingTimeInMilliseconds !==\n                            undefined &&\n                        Date.now() - startTime >=\n                            options.maximumWaitingTimeInMilliseconds;\n\n                    // Stop the polling if the condition is met OR the maximum iterations is reached OR the maximum waiting time is reached\n                    pollingCondition = !(\n                        isConditionSatisfied ||\n                        isMaximumIterationsReached ||\n                        isTimeLimitReached\n                    );\n                } while (pollingCondition);\n\n                return currentResult;\n            } catch (error) {\n                throw new PollExecution(\n                    'SyncPoll.waitUntil()',\n                    'Polling failed: Function execution error encountered during synchronous polling.',\n                    {\n                        functionName: pollingFunction.name\n                    },\n                    error\n                );\n            }\n        }\n    };\n}\n\nexport { SyncPoll };\n","import { EventEmitter } from 'events';\nimport { InvalidDataType, PollExecution } from '@vechain/sdk-errors';\n\n/**\n * Poll in an event based way.\n * This Poll is Asynchronous. It exploits:\n * - The EventEmitter to emit events\n * - The setInterval function to poll\n *\n * @example It can be used to trigger events every time\n *  - When balance is updated after a transaction is sent a message is sent\n *  - When a transaction is mined a message is sent\n *  - When a certain block is mined an operation can start\n *  ...\n */\nclass EventPoll<TReturnType> extends EventEmitter {\n    /**\n     * The current iteration. It counts how many iterations have been done.\n     * This parameter is useful to know how many iterations have been done.\n     * For example, it can be used to stop the poll after a certain number of iterations.\n     */\n    private currentIteration: number = 0;\n\n    /**\n     * Error thrown during the execution of the poll.\n     */\n    private error?: Error;\n\n    /**\n     * Indicates whether to stop execution on error of the\n     * {@link _intervalLoop} function.\n     *\n     * @type {boolean}\n     */\n    private readonly hasToStopOnError: boolean;\n\n    /**\n     * The interval used to poll.\n     */\n    private intervalId?: NodeJS.Timeout;\n\n    /**\n     * The function to be called.\n     */\n    private readonly pollingFunction: () => Promise<TReturnType>;\n\n    /**\n     * The interval of time (in milliseconds) between each request.\n     */\n    private readonly requestIntervalInMilliseconds: number;\n\n    /**\n     * Constructor for creating an instance of EventPoll.\n     *\n     * @param {Function} pollingFunction - The function to be executed repeatedly.\n     * @param {number} requestIntervalInMilliseconds - The interval in milliseconds between each execution of the polling function.\n     * @param {boolean} [hasToStopOnError=true] - Indicates whether to stop polling if an error occurs.\n     * @throws {InvalidDataType}\n     */\n    constructor(\n        pollingFunction: () => Promise<TReturnType>,\n        requestIntervalInMilliseconds: number,\n        hasToStopOnError: boolean\n    ) {\n        super();\n        this.pollingFunction = pollingFunction;\n        this.hasToStopOnError = hasToStopOnError;\n\n        // Positive number for request interval\n        if (\n            requestIntervalInMilliseconds !== undefined &&\n            (requestIntervalInMilliseconds <= 0 ||\n                !Number.isInteger(requestIntervalInMilliseconds))\n        ) {\n            throw new InvalidDataType(\n                'SyncPoll()',\n                'Polling failed: Invalid input for field \"options?.maximumWaitingTimeInMilliseconds\" it must be a positive number',\n                {\n                    requestIntervalInMilliseconds\n                }\n            );\n        }\n\n        this.requestIntervalInMilliseconds = requestIntervalInMilliseconds;\n    }\n\n    /**\n     * Get how many iterations have been done.\n     *\n     * @returns The number of iterations.\n     */\n    public get getCurrentIteration(): number {\n        return this.currentIteration;\n    }\n\n    /**\n     * Basic interval loop function.\n     * This function must be called into setInterval.\n     * It calls the promise and emit the event.\n     */\n    private async _intervalLoop(): Promise<void> {\n        try {\n            // Get data and emit the event\n            const data = await this.pollingFunction();\n            this.emit('data', { data, eventPoll: this });\n        } catch (error) {\n            // Set error\n            this.error = new PollExecution(\n                'EventPoll - main interval loop function',\n                `Error during the execution of the poll ${(error as Error).message}`,\n                {\n                    functionName: this.pollingFunction.name\n                }\n            );\n\n            // Emit the error\n            this.emit('error', { error: this.error });\n\n            // Stop listening?\n            if (this.hasToStopOnError) {\n                this.stopListen();\n            }\n        }\n\n        // Increment the iteration\n        this.currentIteration = this.currentIteration + 1;\n    }\n\n    /**\n     * Listen to the 'data' event.\n     * This method is the redefinition of the EventEmitter.on method.\n     * Because the EventEmitter.on method does not allow to specify the type of the data.\n     * And we must be type safe.\n     *\n     * This is equivalent to:\n     *\n     * ```typescript\n     * eventPoll.on('data', (data) => { ... });\n     * ```\n     * @param onDataCallback - The callback to be called when the event is emitted.\n     */\n    public onData(\n        onDataCallback: (\n            data: TReturnType,\n            eventPoll: EventPoll<TReturnType>\n        ) => void\n    ): this {\n        this.on('data', (data) => {\n            onDataCallback(\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                data.data as TReturnType,\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                data.eventPoll as EventPoll<TReturnType>\n            );\n        });\n\n        return this;\n    }\n\n    /* --- Overloaded of 'on' event emitter start --- */\n\n    /**\n     * Listen to the 'error' event.\n     * This method is the redefinition of the EventEmitter.on method.\n     * Because the EventEmitter.on method does not allow to specify the type of the data.\n     * And we must be type safe.\n     *\n     * This is equivalent to:\n     *\n     * ```typescript\n     * eventPoll.on('error', (data) => { ... });\n     * ```\n     * @param onErrorCallback - The callback to be called when the event is emitted.\n     */\n    public onError(onErrorCallback: (error: Error) => void): this {\n        this.on('error', (error) => {\n            onErrorCallback(\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                error.error as Error\n            );\n        });\n\n        return this;\n    }\n\n    /**\n     * Listen to the 'start' event.\n     * This happens when the poll is stopped.\n     *\n     * @param onStartCallback - The callback to be called when the event is emitted.\n     */\n    public onStart(\n        onStartCallback: (eventPoll: EventPoll<TReturnType>) => void\n    ): this {\n        this.on('start', (data) => {\n            onStartCallback(\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                data.eventPoll as EventPoll<TReturnType>\n            );\n        });\n\n        return this;\n    }\n\n    /**\n     * Listen to the 'stop' event.\n     * This happens when the poll is stopped.\n     *\n     * @param onStopCallback - The callback to be called when the event is emitted.\n     */\n    public onStop(\n        onStopCallback: (eventPoll: EventPoll<TReturnType>) => void\n    ): this {\n        this.on('stop', (data) => {\n            onStopCallback(\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                data.eventPoll as EventPoll<TReturnType>\n            );\n        });\n\n        return this;\n    }\n\n    /**\n     * Start listening to the event.\n     */\n    startListen(): void {\n        // Start listening\n        this.emit('start', { eventPoll: this });\n\n        // Execute `_intervalLoop` and then set an interval which calls `_intervalLoop` every `requestIntervalInMilliseconds`\n        void this._intervalLoop().then(() => {\n            // Create an interval\n            this.intervalId = setInterval(() => {\n                void (async () => {\n                    await this._intervalLoop();\n                })();\n            }, this.requestIntervalInMilliseconds);\n        }); // No need for .catch(), errors are handled within _intervalLoop\n    }\n\n    /**\n     * Stop listening to the event.\n     */\n    stopListen(): void {\n        clearInterval(this.intervalId);\n        this.emit('stop', { eventPoll: this });\n    }\n\n    /* --- Overloaded of 'on' event emitter end --- */\n}\n\n/**\n * Creates an event poll that performs a callback function repeatedly at a specified interval.\n * This method is useful to create an event poll in a more readable way.\n *\n * @param {Function} callBack - The callback function to be executed on each interval. It should return a Promise.\n * @param {number} requestIntervalInMilliseconds - The interval in milliseconds at which the callback function will be executed.\n * @param {boolean} [hasToStopOnError=true] - Optional parameter to specify whether the poll should stop on error. Default is true.\n * @returns {EventPoll} - The created event poll instance.\n */\nfunction createEventPoll<TReturnType>(\n    callBack: () => Promise<TReturnType>,\n    requestIntervalInMilliseconds: number,\n    hasToStopOnError: boolean = true\n): EventPoll<TReturnType> {\n    return new EventPoll<TReturnType>(\n        callBack,\n        requestIntervalInMilliseconds,\n        hasToStopOnError\n    );\n}\n\nexport { EventPoll, createEventPoll };\n","// Synchronous Polling\nimport { SyncPoll } from './sync';\n\n// Asynchronous Event Polling\nimport { createEventPoll, type EventPoll } from './event';\n\n// Types\nexport type * from './types.d';\n\nconst Poll = { SyncPoll, createEventPoll };\nexport { Poll, type EventPoll };\n","import { InvalidDataType } from '@vechain/sdk-errors';\nimport { HTTP_REGEX, HTTPS_REGEX } from '../const';\n\n/**\n * Generates a query string from a record of key-value pairs.\n * Only includes keys in the query string whose values are defined.\n *\n * @param params - The record of key-value pairs.\n * @returns The query string.\n */\nconst toQueryString = (\n    params: Record<string, string | number | boolean | undefined>\n): string => {\n    // Filter out undefined values and map to 'key=value' strings\n    const queryParts = Object.entries(params)\n        .filter(([, value]) => value !== undefined)\n        .map(\n            ([key, value]) =>\n                `${encodeURIComponent(key)}=${encodeURIComponent(\n                    value as string\n                )}`\n        );\n\n    // Join the parts with '&' and prepend a '?' if not empty\n    return queryParts.length > 0 ? `?${queryParts.join('&')}` : '';\n};\n\n/**\n * Sanitizes a base URL by removing trailing slashes and adding the protocol if missing.\n *\n * @param url - The URL to validate.\n * @returns The sanitized URL without the protocol.\n * @throws {InvalidDataType}\n */\nconst sanitizeWebsocketBaseURL = (url: string): string => {\n    // Clean the url\n    url = url.trim();\n\n    // Simplified regex to check if the URL is valid\n    const urlRegex =\n        /^(https?:\\/\\/)([a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*)(:\\d+)?\\/?$/;\n\n    if (!urlRegex.test(url))\n        throw new InvalidDataType(\n            'sanitizeWebsocketBaseURL()',\n            `Invalid url: ${url}. Must adhere to the regex: ${urlRegex}.`,\n            { url, urlRegex }\n        );\n\n    // Remove trailing slash\n    url = url.replace(/\\/$/, '');\n\n    // Replace http with ws and https with wss\n    url =\n        HTTP_REGEX.exec(url) !== null\n            ? url.replace(HTTP_REGEX, 'ws://')\n            : url.replace(HTTPS_REGEX, 'wss://');\n\n    return url;\n};\n\nexport { toQueryString, sanitizeWebsocketBaseURL };\n","import { sanitizeWebsocketBaseURL, toQueryString } from './helpers';\nimport { type VetTransferOptions, type EventOptions } from './types';\n\n/**\n * Endpoints for the REST API.\n */\nconst thorest = {\n    /**\n     * Accounts related endpoints.\n     */\n    accounts: {\n        get: {\n            ACCOUNT_DETAIL: (address: string): string => `/accounts/${address}`,\n            ACCOUNT_BYTECODE: (address: string): string =>\n                `/accounts/${address}/code`,\n            STORAGE_AT: (address: string, position: string): string =>\n                `/accounts/${address}/storage/${position}`\n        },\n        post: {\n            SIMULATE_TRANSACTION: (revision?: string): string => {\n                return revision != null\n                    ? `/accounts/*?revision=${revision}`\n                    : `/accounts/*`;\n            }\n        }\n    },\n\n    /**\n     * Blocks related endpoints.\n     */\n    blocks: {\n        get: {\n            BLOCK_DETAIL: (revision: string | number): string =>\n                `/blocks/${revision}`\n        }\n    },\n\n    /**\n     * Nodes related endpoints.\n     */\n    nodes: {\n        get: {\n            NODES: (): string => '/node/network/peers'\n        }\n    },\n\n    /**\n     * Logs related endpoints.\n     */\n    logs: {\n        post: {\n            EVENT_LOGS: (): string => '/logs/event',\n            TRANSFER_LOGS: (): string => '/logs/transfer'\n        }\n    },\n\n    /**\n     * Transactions related endpoints.\n     */\n    transactions: {\n        get: {\n            TRANSACTION: (id: string): string => `/transactions/${id}`,\n            TRANSACTION_RECEIPT: (id: string): string =>\n                `/transactions/${id}/receipt`\n        },\n        post: {\n            TRANSACTION: (): string => `/transactions`\n        }\n    },\n\n    /**\n     * Subscriptions related endpoints.\n     */\n    subscriptions: {\n        get: {\n            /**\n             * Subscribe to new blocks.\n             *\n             * @param baseURL - The URL of the node to request the subscription from.\n             * @param position - (optional) The block id to start from, defaults to the best block.\n             *\n             * @returns The websocket subscription URL.\n             */\n            BLOCK: (baseURL: string, position?: string): string => {\n                const queryParams = toQueryString({\n                    pos: position\n                });\n\n                return `${sanitizeWebsocketBaseURL(\n                    baseURL\n                )}/subscriptions/block${queryParams}`;\n            },\n\n            /**\n             * Subscribe to new events.\n             *\n             * @param baseURL - The URL of the node to request the subscription from.\n             * @param options - (optional) The options for the subscription.\n             *\n             * @returns The websocket subscription URL.\n             */\n            EVENT: (baseURL: string, options?: EventOptions): string => {\n                const queryParams = toQueryString({\n                    pos: options?.position,\n                    addr: options?.contractAddress,\n                    t0: options?.topic0,\n                    t1: options?.topic1,\n                    t2: options?.topic2,\n                    t3: options?.topic3,\n                    t4: options?.topic4\n                });\n\n                return `${sanitizeWebsocketBaseURL(\n                    baseURL\n                )}/subscriptions/event${queryParams}`;\n            },\n\n            /**\n             * Subscribe to new VET transfers.\n             *\n             * @param baseURL - The URL of the node to request the subscription from.\n             * @param options - (optional) The options for the subscription.\n             *\n             * @returns The websocket subscription URL.\n             */\n            VET_TRANSFER: (\n                baseURL: string,\n                options?: VetTransferOptions\n            ): string => {\n                const queryParams = toQueryString({\n                    pos: options?.position,\n                    txOrigin: options?.signerAddress,\n                    sender: options?.sender,\n                    recipient: options?.receiver\n                });\n\n                return `${sanitizeWebsocketBaseURL(\n                    baseURL\n                )}/subscriptions/transfer${queryParams}`;\n            },\n\n            /**\n             * Subscribe to new legacy beats.\n             * A beat is a notification that a new block has been added to the blockchain with a bloom filter which can be used to check if the block contains any relevant account.\n             * @note This subscription has been improved with dynamic size bloom filter with the new `BEAT` subscription.\n             *\n             * @param baseURL - The URL of the node to request the subscription from.\n             * @param position - (optional) The block id to start from, defaults to the best block.\n             *\n             * @returns The websocket subscription URL.\n             */\n            BEAT_LEGACY: (baseURL: string, position?: string): string => {\n                const queryParams = toQueryString({\n                    pos: position\n                });\n\n                return `${sanitizeWebsocketBaseURL(\n                    baseURL\n                )}/subscriptions/beat${queryParams}`;\n            },\n\n            /**\n             * Subscribe to new beats.\n             * A beat is a notification that a new block has been added to the blockchain with a bloom filter which can be used to check if the block contains any relevant account.\n             *\n             * @param baseURL - The URL of the node to request the subscription from.\n             * @param position - (optional) The block id to start from, defaults to the best block.\n             *\n             * @returns The websocket subscription URL.\n             */\n            BEAT: (baseURL: string, position?: string): string => {\n                const queryParams = toQueryString({\n                    pos: position\n                });\n\n                return `${sanitizeWebsocketBaseURL(\n                    baseURL\n                )}/subscriptions/beat2${queryParams}`;\n            },\n\n            /**\n             * Subscribe to new transactions.\n             *\n             * @returns The websocket subscription URL.\n             */\n            NEW_TRANSACTIONS: (baseURL: string): string =>\n                `${sanitizeWebsocketBaseURL(baseURL)}/subscriptions/txpool`\n        }\n    },\n\n    /**\n     * Debug related endpoints.\n     */\n    debug: {\n        post: {\n            TRACE_TRANSACTION_CLAUSE: (): string => `/debug/tracers`,\n            TRACE_CONTRACT_CALL: (): string => `/debug/tracers/call`,\n            RETRIEVE_STORAGE_RANGE: (): string => `/debug/storage-range`\n        }\n    },\n\n    /**\n     * Fees related endpoints.\n     */\n    fees: {\n        get: {\n            FEES_HISTORY: (\n                blockCount: number,\n                newestBlock: string | number,\n                rewardPercentiles?: number[]\n            ): string => {\n                const queryParams = toQueryString({\n                    blockCount,\n                    newestBlock,\n                    rewardPercentiles: rewardPercentiles?.join(',')\n                });\n                return `/fees/history${queryParams}`;\n            }\n        }\n    }\n};\n\nexport { thorest };\n","import { thorest } from '../thorest';\nimport { type BlockSubscriptionOptions } from './types';\n\n/**\n * Returns the URL for subscribing to new beats through a websocket connection.\n * @note This subscribes to the legacy beats.\n * [Legacy Beat source code](https://github.com/vechain/thor/blob/abf1da466b554dcc9c1ad30cb8e75a860b046bf5/api/subscriptions/beat_reader.go#L29)\n *\n * @param baseURL - The URL of the node to request the subscription from.\n * @param options - (optional) other optional parameters for the request.\n *                  `blockID` - The block id to start from, defaults to the best block.\n *\n * @returns The websocket subscription URL.\n */\nconst getLegacyBeatSubscriptionUrl = (\n    baseURL: string,\n    options?: BlockSubscriptionOptions\n): string => {\n    return thorest.subscriptions.get.BEAT_LEGACY(baseURL, options?.blockID);\n};\n\n/**\n * Returns the URL for subscribing to new beats through a websocket connection.\n * @note this subscribes to the updated version of the beats. The new version uses a dynamic size bloom filter.\n *\n * @param baseURL - The URL of the node to request the subscription from.\n * @param options - (optional) other optional parameters for the request.\n *                 `blockID` - The block id to start from, defaults to the best block.\n *\n * @returns The websocket subscription URL.\n */\nconst getBeatSubscriptionUrl = (\n    baseURL: string,\n    options?: BlockSubscriptionOptions\n): string => {\n    return thorest.subscriptions.get.BEAT(baseURL, options?.blockID);\n};\n\nexport { getLegacyBeatSubscriptionUrl, getBeatSubscriptionUrl };\n","import { thorest } from '../thorest';\nimport { type BlockSubscriptionOptions } from './types';\n\n/**\n * Returns the URL for subscribing to new blocks through a websocket connection.\n *\n * @param baseURL - The URL of the node to request the subscription from.\n * @param options - (optional) other optional parameters for the request.\n *                 `blockID` - The block id to start from, defaults to the best block.\n *\n * @returns The websocket subscription URL.\n */\nconst getBlockSubscriptionUrl = (\n    baseURL: string,\n    options?: BlockSubscriptionOptions\n): string => {\n    return thorest.subscriptions.get.BLOCK(baseURL, options?.blockID);\n};\n\nexport { getBlockSubscriptionUrl };\n","import { ABIEvent } from '@vechain/sdk-core';\nimport { type AbiEvent } from 'abitype';\nimport { thorest } from '../thorest';\nimport { type EventLike, type EventSubscriptionOptions } from './types';\n\n/**\n * Returns the URL for subscribing to an event through a websocket connection.\n *\n * @param baseURL - The URL of the node to request the subscription from.\n * @param event - The event to subscribe to.\n *                Can be an event object or a string representing an event.\n *                @see [Viem Parse ABI Item](https://viem.sh/docs/abi/parseAbiItem.html)\n *\n * @param indexedValues - The values of the indexed parameters to construct the topic filters.\n * @param options - (optional) other optional parameters for the request.\n *                  `blockID` - The block id to start from, defaults to the best block.\n *                  `address` - The contract address to filter events by.\n *\n * @returns The websocket subscription URL.\n *\n * @throws Will throw an error if the event is not a valid event or if the indexed values to encode are invalid.\n */\nconst getEventSubscriptionUrl = (\n    baseURL: string,\n    event: EventLike,\n    indexedValues?: unknown[],\n    options?: EventSubscriptionOptions\n): string => {\n    const ev =\n        typeof event === 'string'\n            ? new ABIEvent(event)\n            : new ABIEvent(event as AbiEvent);\n\n    // Encode the indexed parameters to construct the topic filters\n    const encodedTopics = ev.encodeFilterTopicsNoNull(indexedValues ?? []);\n\n    return thorest.subscriptions.get.EVENT(baseURL, {\n        position: options?.blockID,\n        contractAddress: options?.address,\n        topic0: encodedTopics[0],\n        topic1: encodedTopics[1],\n        topic2: encodedTopics[2],\n        topic3: encodedTopics[3],\n        topic4: encodedTopics[4]\n    });\n};\n\nexport { getEventSubscriptionUrl };\n","import { thorest } from '../thorest';\n\n/**\n * Returns the URL for subscribing to new transactions through a websocket connection.\n *\n * @param baseURL - The URL of the node to request the subscription from.\n * @returns The websocket subscription URL.\n */\nconst getNewTransactionsSubscriptionUrl = (baseURL: string): string => {\n    return thorest.subscriptions.get.NEW_TRANSACTIONS(baseURL);\n};\n\nexport { getNewTransactionsSubscriptionUrl };\n","import { thorest } from '../thorest';\nimport { type VETtransfersSubscriptionOptions } from './types';\n\n/**\n * Returns the URL for subscribing to new VET transfers through a websocket connection.\n *\n * @param baseURL - The URL of the node to request the subscription from.\n * @param options - (optional) other optional parameters for the request.\n *                  `blockID` - The block id to start from, defaults to the best block.\n *                  `signerAddress` - The address of the signer of the transaction to filter transfers by.\n *                  `sender` - The sender address to filter transfers by.\n *                  `recipient` - The recipient address to filter transfers by.\n *\n * @returns The websocket subscription URL.\n */\nconst getVETtransfersSubscriptionUrl = (\n    baseURL: string,\n    options?: VETtransfersSubscriptionOptions\n): string => {\n    return thorest.subscriptions.get.VET_TRANSFER(baseURL, {\n        position: options?.blockID,\n        signerAddress: options?.signerAddress,\n        sender: options?.sender,\n        receiver: options?.recipient\n    });\n};\n\nexport { getVETtransfersSubscriptionUrl };\n","import { getBeatSubscriptionUrl, getLegacyBeatSubscriptionUrl } from './beat';\nimport { getBlockSubscriptionUrl } from './block';\nimport { getEventSubscriptionUrl } from './event';\nimport { getNewTransactionsSubscriptionUrl } from './transaction';\nimport { getVETtransfersSubscriptionUrl } from './transfer';\n\nexport type * from './types.d';\n\n/**\n * Subscriptions utilities.\n * Contains functions for obtaining URLs for subscribing to events through a websocket connection.\n */\nexport const subscriptions = {\n    getEventSubscriptionUrl,\n    getBlockSubscriptionUrl,\n    getNewTransactionsSubscriptionUrl,\n    getVETtransfersSubscriptionUrl,\n    getLegacyBeatSubscriptionUrl,\n    getBeatSubscriptionUrl\n};\n","import {\n    MAINNET_NETWORK,\n    SOLO_NETWORK,\n    TESTNET_NETWORK\n} from '@vechain/sdk-core';\n\nconst NetworkContracts: Record<\n    string,\n    { registry: string; resolveUtils: string }\n> = {\n    [MAINNET_NETWORK.genesisBlock.id]: {\n        registry: '0xa9231da8BF8D10e2df3f6E03Dd5449caD600129b',\n        resolveUtils: '0xA11413086e163e41901bb81fdc5617c975Fa5a1A'\n    },\n\n    [TESTNET_NETWORK.genesisBlock.id]: {\n        registry: '0xcBFB30c1F267914816668d53AcBA7bA7c9806D13',\n        resolveUtils: '0xc403b8EA53F707d7d4de095f0A20bC491Cf2bc94'\n    },\n\n    [SOLO_NETWORK.genesisBlock.id]: {\n        registry: '0x1c4a602ed21f3d1dddd1142c81f231ef1a08c921',\n        resolveUtils: '0xb2f08bbfa8a42b1fbe63feec604cb147385203d7'\n    }\n};\n\nexport { NetworkContracts };\n","import { ABIFunction, ABIItem, Address, ZERO_ADDRESS } from '@vechain/sdk-core';\nimport {\n    type BlocksModule,\n    type ThorClient,\n    type TransactionsModule\n} from '../../thor-client';\nimport { NetworkContracts } from './addresses';\n\n/**\n * Returns a single address or null for a name resolved at vet.domains\n *\n * @param thorClient - The thor client instance to use.\n * @param name - The name to resolve\n * @returns The address or null\n */\nconst resolveName = async (\n    thorClient: ThorClient,\n    name: string\n): Promise<null | string> => {\n    const [address] = await vnsUtils.resolveNames(\n        thorClient.blocks,\n        thorClient.transactions,\n        [name]\n    );\n    return address ?? null;\n};\n\n/**\n * Returns a list of addresses or null for names resolved by vet.domains\n *\n * @param thorClient - The thor client instance to use.\n * @param names - The names to resolve\n * @returns The list of the same size of names with the resolved address or null\n */\nconst resolveNames = async (\n    blocksModule: BlocksModule,\n    transactionsModule: TransactionsModule,\n    names: string[]\n): Promise<Array<null | string>> => {\n    // identify current chain\n    const genesisBlock = await blocksModule.getGenesisBlock();\n\n    // verify configuration for chain exists\n    if (\n        genesisBlock === null ||\n        !Address.isValid(NetworkContracts[genesisBlock.id]?.resolveUtils)\n    ) {\n        return names.map(() => null);\n    }\n\n    const resolveUtilsAddress = NetworkContracts[genesisBlock.id].resolveUtils;\n\n    // use the resolveUtils to lookup names\n    const callGetAddresses = await transactionsModule.executeCall(\n        resolveUtilsAddress,\n        ABIItem.ofSignature(\n            ABIFunction,\n            'function getAddresses(string[] names) returns (address[] addresses)'\n        ),\n        [names]\n    );\n\n    const [addresses] = callGetAddresses.result.array as string[][];\n\n    return addresses.map((address) => {\n        // zero addresses are missing configuration entries\n        if (address === ZERO_ADDRESS || !Address.isValid(address)) {\n            return null;\n        }\n\n        return address;\n    });\n};\n\n/**\n * Returns a single primary name for a given address resolved at vet.domains\n *\n * @param thorClient - The thor client instance to use.\n * @param address - The address to lookup\n * @returns The name or null\n */\nconst lookupAddress = async (\n    thorClient: ThorClient,\n    address: string\n): Promise<null | string> => {\n    const [name] = await vnsUtils.lookupAddresses(thorClient, [address]);\n    return name ?? null;\n};\n\n/**\n * Returns a list of names or null for addresses primary names resolved by vet.domains. Reverse lookup of name to address is verified.\n *\n * @param thorClient - The thor client instance to use.\n * @param addresses - The addresses to lookup\n * @returns The list of the same size of addresses with the resolved primary names or null\n */\nconst lookupAddresses = async (\n    thorClient: ThorClient,\n    addresses: string[]\n): Promise<Array<null | string>> => {\n    // identify current chain\n    const genesisBlock = await thorClient.blocks.getGenesisBlock();\n\n    // verify configuration for chain exists\n    if (\n        genesisBlock === null ||\n        !Address.isValid(NetworkContracts[genesisBlock.id]?.resolveUtils)\n    ) {\n        return addresses.map(() => null);\n    }\n\n    const resolveUtilsAddress = NetworkContracts[genesisBlock.id].resolveUtils;\n\n    // use the resolveUtils to lookup names\n    const callGetNames = await thorClient.contracts.executeCall(\n        resolveUtilsAddress,\n        ABIItem.ofSignature(\n            ABIFunction,\n            'function getNames(address[] addresses) returns (string[] names)'\n        ),\n        [addresses]\n    );\n\n    const [names] = callGetNames.result.array as string[][];\n\n    return names.map((name) => {\n        // empty strings indicate a missing entry\n        if (name === '') {\n            return null;\n        }\n\n        return name;\n    });\n};\n\nconst vnsUtils = { resolveName, resolveNames, lookupAddress, lookupAddresses };\nexport { vnsUtils };\n","import { AccountDetail } from './AccountDetail';\nimport { buildQuery, thorest } from '../../utils';\nimport { type AccountData } from './AccountData';\nimport { type AccountInputOptions } from './AccountInputOptions';\nimport { type Address, type BlockId, HexUInt } from '@vechain/sdk-core';\nimport { type HttpClient } from '../../http';\n\n/**\n * of the VeChain Thor blockchain.\n * It allows to retrieve details, bytecode, and storage data for a specific blockchain account.\n */\nclass AccountsModule {\n    /**\n     * Creates an instance of the class with a specified HTTP client.\n     *\n     * @param {HttpClient} httpClient - The HTTP client instance to be used for making requests.\n     */\n    constructor(readonly httpClient: HttpClient) {}\n\n    /**\n     * Retrieves the details of an account given the account address and optional parameters.\n     *\n     * @param {Address} address - The address of the account to be retrieved.\n     * @param {AccountInputOptions} [options] - Optional parameters to modify the account retrieval.\n     * @return {Promise<AccountDetail>} Returns a promise that resolves to the account details.\n     */\n    public async getAccount(\n        address: Address,\n        options?: AccountInputOptions\n    ): Promise<AccountDetail> {\n        const revision = options?.revision?.toString();\n        return new AccountDetail(\n            (await this.httpClient.get(\n                thorest.accounts.get.ACCOUNT_DETAIL(address.toString()),\n                {\n                    query: buildQuery({ revision })\n                }\n            )) as AccountData\n        );\n    }\n\n    /**\n     * Retrieves the bytecode of the smart contract deployed at the specified address.\n     *\n     * @param {Address} address - The address of the smart contract.\n     * @param {AccountInputOptions} [options] - Optional settings for the request, including the block revision.\n     * @return {Promise<HexUInt>} A promise that resolves to the bytecode of the smart contract.\n     */\n    public async getBytecode(\n        address: Address,\n        options?: AccountInputOptions\n    ): Promise<HexUInt> {\n        const revision = options?.revision?.toString();\n        const result = (await this.httpClient.get(\n            thorest.accounts.get.ACCOUNT_BYTECODE(address.toString()),\n            {\n                query: buildQuery({ revision })\n            }\n        )) as ResponseBytecode;\n        return HexUInt.of(result.code);\n    }\n\n    /**\n     * Retrieves the storage value at the specified storage position for a given address.\n     *\n     * @param {Address} address - The address of the account whose storage value is to be retrieved.\n     * @param {ThorId} position - The position in the storage from where the value is to be retrieved.\n     * @param {AccountInputOptions} [options] - Optional parameters including revision for specifying the block number or ID to query against.\n     * @return {Promise<HexUInt>} - A promise that resolves to the storage value as a string.\n     */\n    public async getStorageAt(\n        address: Address,\n        position: BlockId,\n        options?: AccountInputOptions\n    ): Promise<HexUInt> {\n        const pos = position.toString();\n        const revision = options?.revision?.toString();\n        const result = (await this.httpClient.get(\n            thorest.accounts.get.STORAGE_AT(address.toString(), pos),\n            {\n                query: buildQuery({ pos, revision })\n            }\n        )) as ResponseStorage;\n\n        return HexUInt.of(result.value);\n    }\n}\n\n/**\n * The bytecode of a smart contract.\n * The bytecode is represented in hex string.\n */\ninterface ResponseBytecode {\n    /**\n     * Bytecode of the smart contract\n     */\n    code: string;\n}\n\n/**\n * The storage data of a smart contract at the specified position.\n * The storage data is represented in hex string.\n */\ninterface ResponseStorage {\n    /**\n     * Hex string of the storage data\n     */\n    value: string;\n}\n\nexport { AccountsModule };\n","import { InvalidDataType } from '@vechain/sdk-errors';\nimport { buildQuery, type EventPoll, Poll, thorest } from '../../utils';\nimport {\n    type BlocksModuleOptions,\n    type CompressedBlockDetail,\n    type ExpandedBlockDetail,\n    type TransactionsExpandedBlockDetail,\n    type WaitForBlockOptions\n} from './types';\nimport { Revision, type TransactionClause } from '@vechain/sdk-core';\nimport { type HttpClient, HttpMethod } from '../../http';\n\n/** The `BlocksModule` class encapsulates functionality for interacting with blocks\n * on the VeChainThor blockchain.\n */\nclass BlocksModule {\n    /**\n     * The head block (best block). This is updated by the event poll instance every time a new block is produced.\n     * @private\n     */\n    private headBlock: CompressedBlockDetail | null = null;\n\n    /**\n     * Error handler for block-related errors.\n     */\n    public onBlockError?: (error: Error) => undefined;\n\n    /**\n     * The Poll instance for event polling\n     * @private\n     */\n    private pollInstance?: EventPoll<CompressedBlockDetail | null>;\n\n    /**\n     * Initializes a new instance of the `Thor` class.\n     * @param httpClient - The Thor instance used to interact with the VeChain blockchain API.\n     * @param options - (Optional) Other optional parameters for polling and error handling.\n     */\n    constructor(\n        readonly httpClient: HttpClient,\n        options?: BlocksModuleOptions\n    ) {\n        this.onBlockError = options?.onBlockError;\n        if (options?.isPollingEnabled === true) this.setupPolling();\n    }\n\n    /**\n     * Destroys the instance by stopping the event poll.\n     */\n    public destroy(): void {\n        if (this.pollInstance != null) {\n            this.pollInstance.stopListen();\n        }\n    }\n\n    /**\n     * Sets up the event polling for the best block.\n     * @private\n     * */\n    private setupPolling(): void {\n        this.pollInstance = Poll.createEventPoll(\n            async () => await this.getBestBlockCompressed(),\n            10000 // Poll every 10 seconds,\n        )\n            .onData((data) => {\n                this.headBlock = data;\n            })\n            .onError(this.onBlockError ?? (() => {}));\n\n        this.pollInstance.startListen();\n    }\n\n    /**\n     * Retrieves details of a compressed specific block identified by its revision (block number or ID).\n     *\n     * @param revision - The block number or ID to query details for.\n     * @returns A promise that resolves to an object containing the details of the compressed block.\n     * @throws {InvalidDataType}\n     */\n    public async getBlockCompressed(\n        revision: string | number\n    ): Promise<CompressedBlockDetail | null> {\n        // Check if the revision is a valid block number or ID\n        if (\n            revision !== null &&\n            revision !== undefined &&\n            !Revision.isValid(revision)\n        ) {\n            throw new InvalidDataType(\n                'BlocksModule.getBlockCompressed()',\n                'Invalid revision. The revision must be a string representing a block number or block id (also \"best\" is accepted which represents the best block & \"finalized\" for the finalized block).',\n                { revision }\n            );\n        }\n        return (await this.httpClient.http(\n            HttpMethod.GET,\n            thorest.blocks.get.BLOCK_DETAIL(revision)\n        )) as CompressedBlockDetail | null;\n    }\n\n    /**\n     * Retrieves details of an expanded specific block identified by its revision (block number or ID).\n     *\n     * @param revision - The block number or ID to query details for.\n     * @returns A promise that resolves to an object containing the details of the expanded block.\n     * @throws {InvalidDataType}\n     */\n    public async getBlockExpanded(\n        revision: string | number\n    ): Promise<ExpandedBlockDetail | null> {\n        // Check if the revision is a valid block number or ID\n        if (\n            revision !== null &&\n            revision !== undefined &&\n            !Revision.isValid(revision)\n        ) {\n            throw new InvalidDataType(\n                'BlocksModule.getBlockExpanded()',\n                'Invalid revision. The revision must be a string representing a block number or block id (also \"best\" is accepted which represents the best block & \"finalized\" for the finalized block).',\n                { revision }\n            );\n        }\n\n        return (await this.httpClient.http(\n            HttpMethod.GET,\n            thorest.blocks.get.BLOCK_DETAIL(revision),\n            {\n                query: buildQuery({ expanded: true })\n            }\n        )) as ExpandedBlockDetail | null;\n    }\n\n    /**\n     * Retrieves details of the latest block.\n     *\n     * @returns A promise that resolves to an object containing the compressed block details.\n     */\n    public async getBestBlockCompressed(): Promise<CompressedBlockDetail | null> {\n        return await this.getBlockCompressed('best');\n    }\n\n    /**\n     * Retrieves details of the latest block.\n     *\n     * @returns A promise that resolves to an object containing the expanded block details.\n     */\n    public async getBestBlockExpanded(): Promise<ExpandedBlockDetail | null> {\n        return await this.getBlockExpanded('best');\n    }\n\n    /**\n     * Retrieves the base fee per gas of the best block.\n     *\n     * @returns A promise that resolves to the base fee per gas of the best block.\n     */\n    public async getBestBlockBaseFeePerGas(): Promise<string | null> {\n        const bestBlock = await this.getBestBlockCompressed();\n        if (bestBlock === null) return null;\n        return bestBlock.baseFeePerGas ?? null;\n    }\n\n    /**\n     * Asynchronously retrieves a reference to the best block in the blockchain.\n     *\n     * This method first calls `getBestBlockCompressed()` to obtain the current best block. If no block is found (i.e., if `getBestBlockCompressed()` returns `null`),\n     * the method returns `null` indicating that there's no block to reference. Otherwise, it extracts and returns the first 18 characters of the\n     * block's ID, providing the ref to the best block.\n     *\n     * @returns {Promise<string | null>} A promise that resolves to either a string representing the first 18 characters of the best block's ID,\n     * or `null` if no best block is found.\n     *\n     * @Example:\n     * const blockRef = await getBestBlockRef();\n     * if (blockRef) {\n     *     console.log(`Reference to the best block: ${blockRef}`);\n     * } else {\n     *     console.log(\"No best block found.\");\n     * }\n     */\n    public async getBestBlockRef(): Promise<string | null> {\n        const bestBlock = await this.getBestBlockCompressed();\n        if (bestBlock === null) return null;\n        return bestBlock.id.slice(0, 18);\n    }\n\n    /**\n     * Retrieves the finalized block.\n     *\n     * @returns A promise that resolves to an object containing the finalized block.\n     */\n    public async getFinalBlockCompressed(): Promise<CompressedBlockDetail | null> {\n        return await this.getBlockCompressed('finalized');\n    }\n\n    /**\n     * Retrieves details of the finalized block.\n     *\n     * @returns A promise that resolves to an object containing the finalized block details.\n     */\n    public async getFinalBlockExpanded(): Promise<ExpandedBlockDetail | null> {\n        return await this.getBlockExpanded('finalized');\n    }\n\n    /**\n     * Synchronously waits for a specific block revision using polling.\n     *\n     * @param blockNumber - The block number to wait for.\n     * @param expanded - A boolean indicating whether to wait for an expanded block.\n     * @param options - (Optional) Allows to specify timeout and interval in milliseconds\n     * @returns A promise that resolves to an object containing the compressed block.\n     * @throws {InvalidDataType}\n     */\n    private async _waitForBlock(\n        blockNumber: number,\n        expanded: boolean,\n        options?: WaitForBlockOptions\n    ): Promise<CompressedBlockDetail | ExpandedBlockDetail | null> {\n        if (\n            blockNumber !== undefined &&\n            blockNumber !== null &&\n            blockNumber <= 0\n        ) {\n            throw new InvalidDataType(\n                'BlocksModule.waitForBlock()',\n                'Invalid blockNumber. The blockNumber must be a number representing a block number.',\n                { blockNumber }\n            );\n        }\n\n        // Use the Poll.SyncPoll utility to repeatedly call getBestBlock with a specified interval\n        return await Poll.SyncPoll(\n            async () =>\n                expanded\n                    ? await this.getBestBlockCompressed()\n                    : await this.getBestBlockExpanded(),\n            {\n                requestIntervalInMilliseconds: options?.intervalMs,\n                maximumWaitingTimeInMilliseconds: options?.timeoutMs\n            }\n        ).waitUntil((result) => {\n            // Continue polling until the result's block number matches the specified revision\n            return result != null && result?.number >= blockNumber;\n        });\n    }\n\n    /**\n     * Synchronously waits for a specific block revision using polling.\n     *\n     * @param blockNumber - The block number to wait for.\n     * @param options - (Optional) Allows to specify timeout and interval in milliseconds\n     * @returns A promise that resolves to an object containing the compressed block.\n     */\n    public async waitForBlockCompressed(\n        blockNumber: number,\n        options?: WaitForBlockOptions\n    ): Promise<CompressedBlockDetail | null> {\n        return (await this._waitForBlock(\n            blockNumber,\n            false,\n            options\n        )) as CompressedBlockDetail | null;\n    }\n\n    /**\n     * Synchronously waits for a specific expanded block revision using polling.\n     *\n     * @param blockNumber - The block number to wait for.\n     * @param options - (Optional) Allows to specify timeout and interval in milliseconds\n     * @returns A promise that resolves to an object containing the expanded block details.\n     */\n    public async waitForBlockExpanded(\n        blockNumber: number,\n        options?: WaitForBlockOptions\n    ): Promise<ExpandedBlockDetail | null> {\n        return (await this._waitForBlock(\n            blockNumber,\n            true,\n            options\n        )) as ExpandedBlockDetail | null;\n    }\n\n    /**\n     * Returns the head block (best block).\n     * @returns {BlockDetail | null} The head block (best block).\n     */\n    public getHeadBlock(): CompressedBlockDetail | null {\n        return this.headBlock;\n    }\n\n    /**\n     * Retrieves details of the genesis block.\n     *\n     * @returns A promise that resolves to an object containing the block details of the genesis block.\n     */\n    public async getGenesisBlock(): Promise<CompressedBlockDetail | null> {\n        return await this.getBlockCompressed(0);\n    }\n\n    /**\n     * Retrieves all addresses involved in a given block. This includes beneficiary, signer, clauses,\n     * gas payer, origin, contract addresses, event addresses, and transfer recipients and senders.\n     *\n     * @param {ExpandedBlockDetail} block - The block object to extract addresses from.\n     *\n     * @returns {string[]} - An array of addresses involved in the block, included\n     * empty addresses, duplicate elements are removed.\n     *\n     */\n    public getAllAddressesIntoABlock(block: ExpandedBlockDetail): string[] {\n        const addresses = new Set<string>();\n        addresses.add(block.beneficiary);\n        addresses.add(block.signer);\n        block.transactions.forEach(\n            (transaction: TransactionsExpandedBlockDetail) => {\n                transaction.clauses.forEach((clause: TransactionClause) => {\n                    if (typeof clause.to === 'string') {\n                        addresses.add(clause.to);\n                    }\n                });\n                addresses.add(transaction.gasPayer);\n                addresses.add(transaction.origin);\n                transaction.outputs.forEach((output) => {\n                    if (typeof output.contractAddress === 'string') {\n                        addresses.add(output.contractAddress);\n                    }\n                    output.events.forEach((event) => {\n                        addresses.add(event.address);\n                    });\n                    output.transfers.forEach((transfer) => {\n                        addresses.add(transfer.recipient);\n                        addresses.add(transfer.sender);\n                    });\n                });\n            }\n        );\n        return Array.from(addresses);\n    }\n}\n\nexport { BlocksModule };\n","import type {\n    EventLogs,\n    FilterCriteria,\n    FilterEventLogsOptions\n} from '../../logs';\nimport { type Contract } from './contract';\nimport { type Abi } from 'abitype';\nimport { type TransferFilterOptions } from './types';\n\n/**\n * Represents a filter for events emitted by a smart contract. This class allows for the specification of criteria to filter\n * events and provides a method to fetch event logs based on those criteria.\n */\nclass ContractFilter<TAbi extends Abi> {\n    /**\n     * The smart contract instance to apply the filter on.\n     */\n    public contract: Contract<TAbi>;\n    /**\n     * A set of criteria used to filter events.\n     */\n    public criteriaSet: FilterCriteria[];\n\n    /**\n     * Constructs an instance of the `ContractFilter` class.\n     *\n     * @param contract - The smart contract instance to apply the filter on.\n     * @param criteriaSet - A set of criteria used to filter events.\n     */\n    constructor(contract: Contract<TAbi>, criteriaSet: FilterCriteria[]) {\n        this.contract = contract;\n        this.criteriaSet = criteriaSet;\n    }\n\n    /**\n     * Retrieves event logs based on the specified filter criteria, range, pagination options, and order.\n     *\n     * @returns An array of event logs that match the specified criteria.\n     * @param param - The filter options to apply to the event logs.\n     */\n    public async get(param?: TransferFilterOptions): Promise<EventLogs[]> {\n        const filterEventLogsOptions: FilterEventLogsOptions = {\n            range: param?.range ?? {\n                unit: 'block',\n                from: 0,\n                to: (\n                    await this.contract.contractsModule.transactionsModule.blocksModule.getBestBlockCompressed()\n                )?.number\n            },\n            criteriaSet: this.criteriaSet,\n            options: param?.options,\n            order: param?.order ?? 'asc'\n        };\n        return await this.contract.contractsModule.transactionsModule.logsModule.filterEventLogs(\n            filterEventLogsOptions\n        );\n    }\n}\nexport { ContractFilter };\n","import {\n    Address,\n    Clause,\n    type TransactionClause,\n    Units,\n    VET\n} from '@vechain/sdk-core';\nimport {\n    ContractCallError,\n    InvalidTransactionField\n} from '@vechain/sdk-errors';\nimport type {\n    Abi,\n    AbiParametersToPrimitiveTypes,\n    ExtractAbiEventNames,\n    ExtractAbiFunction,\n    ExtractAbiFunctionNames\n} from 'abitype';\nimport { type VeChainSigner } from '../../../signer';\nimport { type FilterCriteria } from '../../logs';\nimport { type SendTransactionResult } from '../../transactions/types';\nimport { type ContractClause } from '../types';\nimport { type Contract } from './contract';\nimport { ContractFilter } from './contract-filter';\nimport {\n    type ClauseAdditionalOptions,\n    type ClauseComment,\n    type ClauseRevision,\n    type ContractFunctionClause,\n    type ContractFunctionCriteria,\n    type ContractFunctionFilter,\n    type ContractFunctionRead,\n    type ContractFunctionTransact,\n    type TransactionValue\n} from './types';\n\n/**\n * Creates a Proxy object for reading contract state, allowing for the dynamic invocation of contract read operations.\n * @param contract - The contract instance to create the read proxy for.\n * @returns A Proxy that intercepts calls to read contract functions, automatically handling the invocation with the configured options.\n */\nfunction getReadProxy<TAbi extends Abi>(\n    contract: Contract<TAbi>\n): ContractFunctionRead<TAbi, ExtractAbiFunctionNames<TAbi, 'pure' | 'view'>> {\n    return new Proxy(contract.read, {\n        get: (_target, prop) => {\n            // Otherwise, assume that the function is a contract method\n            return async (\n                ...args: AbiParametersToPrimitiveTypes<\n                    ExtractAbiFunction<TAbi, 'balanceOf'>['inputs'],\n                    'inputs'\n                >\n            ): Promise<unknown[]> => {\n                // check if the clause comment is provided as an argument\n\n                const extractOptionsResult = extractAndRemoveAdditionalOptions(\n                    args as unknown[]\n                );\n\n                const clauseComment =\n                    extractOptionsResult.clauseAdditionalOptions?.comment;\n\n                const revisionValue =\n                    extractOptionsResult.clauseAdditionalOptions?.revision;\n\n                const functionAbi = contract.getFunctionAbi(prop);\n\n                const executeCallResult =\n                    await contract.contractsModule.executeCall(\n                        contract.address,\n                        functionAbi,\n                        extractOptionsResult.args,\n                        {\n                            caller:\n                                contract.getSigner() !== undefined\n                                    ? await contract.getSigner()?.getAddress()\n                                    : undefined,\n                            ...contract.getContractReadOptions(),\n                            comment: clauseComment,\n                            revision: revisionValue,\n                            includeABI: true\n                        }\n                    );\n\n                if (!executeCallResult.success) {\n                    throw new ContractCallError(\n                        functionAbi.stringSignature,\n                        executeCallResult.result.errorMessage as string,\n                        {\n                            contractAddress: contract.address\n                        }\n                    );\n                }\n                return executeCallResult.result.array as unknown[];\n            };\n        }\n    });\n}\n\n/**\n * Creates a Proxy object for transacting with contract functions, allowing for the dynamic invocation of contract transaction operations.\n * @param contract - The contract instance\n * @returns A Proxy that intercepts calls to transaction contract functions, automatically handling the invocation with the configured options.\n * @throws {InvalidTransactionField}\n * @private\n */\nfunction getTransactProxy<TAbi extends Abi>(\n    contract: Contract<TAbi>\n): ContractFunctionTransact<\n    TAbi,\n    ExtractAbiFunctionNames<TAbi, 'nonpayable' | 'payable'>\n> {\n    return new Proxy(contract.transact, {\n        get: (_target, prop) => {\n            // Otherwise, assume that the function is a contract method\n            return async (\n                ...args: unknown[]\n            ): Promise<SendTransactionResult> => {\n                if (contract.getSigner() === undefined) {\n                    throw new InvalidTransactionField(\n                        'getTransactProxy()',\n                        'Caller signer is required to transact with the contract.',\n                        { fieldName: 'signer', prop }\n                    );\n                }\n\n                // get the transaction options for the contract\n                const transactionOptions =\n                    contract.getContractTransactOptions();\n\n                // check if the transaction value is provided as an argument\n\n                const extractAdditionalOptionsResult =\n                    extractAndRemoveAdditionalOptions(args);\n\n                const transactionValue =\n                    extractAdditionalOptionsResult.clauseAdditionalOptions\n                        ?.value;\n\n                const clauseComment =\n                    extractAdditionalOptionsResult.clauseAdditionalOptions\n                        ?.comment;\n\n                args = extractAdditionalOptionsResult.args;\n\n                return await contract.contractsModule.executeTransaction(\n                    contract.getSigner() as VeChainSigner,\n                    contract.address,\n                    contract.getFunctionAbi(prop),\n                    args,\n                    {\n                        ...transactionOptions,\n                        value:\n                            transactionOptions.value ??\n                            transactionValue ??\n                            '0x0',\n                        comment: clauseComment,\n                        includeABI: true\n                    }\n                );\n            };\n        }\n    });\n}\n\n/**\n * Creates a Proxy object for filtering contract events, allowing for the dynamic invocation of contract event filtering operations.\n * @param contract - The contract instance to create the filter proxy for.\n * @returns A Proxy that intercepts calls to filter contract events, automatically handling the invocation with the configured options.\n */\nfunction getFilterProxy<TAbi extends Abi>(\n    contract: Contract<TAbi>\n): ContractFunctionFilter<TAbi, ExtractAbiEventNames<TAbi>> {\n    return new Proxy(contract.filters, {\n        get: (_target, prop) => {\n            return (\n                // eslint-disable-next-line sonarjs/use-type-alias\n                args: Record<string, unknown> | unknown[] | undefined\n            ): ContractFilter<TAbi> => {\n                const criteriaSet = buildCriteria(contract, prop, args);\n\n                return new ContractFilter<TAbi>(contract, [criteriaSet]);\n            };\n        }\n    });\n}\n\n/**\n * Creates a Proxy object for interacting with contract functions, allowing for the dynamic invocation of contract functions.\n * @param contract - The contract instance to create the clause proxy for.\n * @returns A Proxy that intercepts calls to contract functions, automatically handling the invocation with the configured options.\n */\nfunction getClauseProxy<TAbi extends Abi>(\n    contract: Contract<TAbi>\n): ContractFunctionClause<TAbi, ExtractAbiFunctionNames<TAbi>> {\n    return new Proxy(contract.clause, {\n        get: (_target, prop) => {\n            return (...args: unknown[]): ContractClause => {\n                // get the transaction options for the contract\n                const transactionOptions =\n                    contract.getContractTransactOptions();\n\n                // check if the transaction value is provided as an argument\n                const extractAdditionalOptionsResult =\n                    extractAndRemoveAdditionalOptions(args);\n\n                const transactionValue =\n                    extractAdditionalOptionsResult.clauseAdditionalOptions\n                        ?.value;\n\n                const clauseComment =\n                    extractAdditionalOptionsResult.clauseAdditionalOptions\n                        ?.comment;\n\n                args = extractAdditionalOptionsResult.args;\n\n                // return the contract clause\n                return {\n                    clause: Clause.callFunction(\n                        Address.of(contract.address),\n                        contract.getFunctionAbi(prop),\n                        args,\n                        VET.of(\n                            transactionOptions.value ?? transactionValue ?? 0,\n                            Units.wei\n                        ),\n                        {\n                            comment: clauseComment,\n                            includeABI: true\n                        }\n                    ) as TransactionClause,\n                    functionAbi: contract.getFunctionAbi(prop)\n                };\n            };\n        }\n    });\n}\n\n/**\n * Create a proxy object for building event criteria for the event filtering.\n * @param contract - The contract instance to create the criteria proxy for.\n * @returns A Proxy that intercepts calls to build event criteria, automatically handling the invocation with the configured options.\n */\nfunction getCriteriaProxy<TAbi extends Abi>(\n    contract: Contract<TAbi>\n): ContractFunctionCriteria<TAbi, ExtractAbiEventNames<TAbi>> {\n    return new Proxy(contract.criteria, {\n        get: (_target, prop) => {\n            return (\n                args: Record<string, unknown> | unknown[] | undefined\n            ): FilterCriteria => {\n                return buildCriteria(contract, prop, args);\n            };\n        }\n    });\n}\n\n/**\n * Builds the filter criteria for the contract filter.\n * @param contract - The contract instance to create the criteria for.\n * @param prop - The property name of the contract event.\n * @param args - The arguments to filter the event.\n * @returns The event criteria for the contract filter.\n */\nfunction buildCriteria<TAbi extends Abi>(\n    contract: Contract<TAbi>,\n    prop: string | symbol,\n    args: Record<string, unknown> | unknown[] | undefined\n): FilterCriteria {\n    // Create the VeChain sdk event ABI\n    const eventAbi = contract.getEventAbi(prop);\n\n    // Create a map of encoded filter topics for the event\n    const topics = new Map<number, string | undefined>(\n        eventAbi\n            .encodeFilterTopicsNoNull(args)\n            .map((topic, index) => [index, topic])\n    );\n\n    // Create the criteria set for the contract filter\n    return {\n        criteria: {\n            address: contract.address,\n            topic0: topics.get(0) as string, // the first topic is always defined since it's the event signature\n            topic1: topics.has(1) ? topics.get(1) : undefined,\n            topic2: topics.has(2) ? topics.get(2) : undefined,\n            topic3: topics.has(3) ? topics.get(3) : undefined,\n            topic4: topics.has(4) ? topics.get(4) : undefined\n        },\n        eventAbi\n    };\n}\n\n/**\n * Extracts the transaction value and comment from the list of arguments, if present.\n * @param args - The list of arguments to search for the transaction value.\n * @returns The transaction value and comment object, if found in the arguments list. Also returns the list of arguments with the clause options removed.\n */\nfunction extractAndRemoveAdditionalOptions(args: unknown[]): {\n    args: unknown[];\n    clauseAdditionalOptions: ClauseAdditionalOptions | undefined;\n} {\n    // check if the transaction value is provided as an argument\n    const transactionValue = getTransactionValue(args);\n    const clauseComment = getClauseComment(args);\n    const clauseRevision = getRevision(args);\n\n    // if present remove the transaction value argument from the list of arguments\n    if (\n        transactionValue !== undefined ||\n        clauseComment !== undefined ||\n        clauseRevision !== undefined\n    ) {\n        args = args.filter(\n            (arg) =>\n                !(\n                    isTransactionValue(arg) ||\n                    isTransactionComment(arg) ||\n                    isRevision(arg)\n                )\n        );\n    }\n\n    return {\n        args,\n        clauseAdditionalOptions: {\n            value: transactionValue?.value,\n            comment: clauseComment?.comment,\n            revision: clauseRevision?.revision\n        }\n    };\n}\n\n/**\n * Extracts the transaction value from the list of arguments, if present.\n * @param args - The list of arguments to search for the transaction value.\n * @returns The transaction value object, if found in the arguments list.\n */\nfunction getTransactionValue(args: unknown[]): TransactionValue | undefined {\n    return args.find((arg) => isTransactionValue(arg)) as\n        | TransactionValue\n        | undefined;\n}\n\n/**\n * Extracts the clause comment from the list of arguments, if present.\n * @param args - The list of arguments to search for the clause comment.\n * @returns The clause comment object, if found in the arguments list.\n */\nfunction getClauseComment(args: unknown[]): ClauseComment | undefined {\n    return args.find((arg) => isTransactionComment(arg)) as\n        | ClauseComment\n        | undefined;\n}\n\n/**\n * Extracts the revision from the list of arguments, if present.\n * @param args - The list of arguments to search for the revision.\n * @returns The revision object, if found in the arguments list.\n */\nfunction getRevision(args: unknown[]): ClauseRevision | undefined {\n    return args.find((arg) => isRevision(arg)) as ClauseRevision | undefined;\n}\n\n/**\n * Type guard function to check if an object is a TransactionValue.\n * @param obj - The object to check.\n * @returns True if the object is a TransactionValue, false otherwise.\n */\nfunction isTransactionValue(obj: unknown): obj is ClauseAdditionalOptions {\n    return (obj as ClauseAdditionalOptions).value !== undefined;\n}\n\n/**\n * Type guard function to check if an object is a ClauseComment.\n * @param obj - The object to check.\n * @returns True if the object is a ClauseComment, false otherwise.\n */\nfunction isTransactionComment(obj: unknown): obj is ClauseAdditionalOptions {\n    return (obj as ClauseAdditionalOptions).comment !== undefined;\n}\n\n/**\n * Type guard function to check if an object is a revision.\n * @param obj - The object to check.\n * @returns True if the object is a revision, false otherwise.\n */\nfunction isRevision(obj: unknown): obj is ClauseAdditionalOptions {\n    return (obj as ClauseAdditionalOptions).revision !== undefined;\n}\n\nexport {\n    getClauseProxy,\n    getCriteriaProxy,\n    getFilterProxy,\n    getReadProxy,\n    getTransactProxy\n};\n","import {\n    ABIContract,\n    type ABIEvent,\n    type ABIFunction\n} from '@vechain/sdk-core';\nimport {\n    type Abi,\n    type ExtractAbiEventNames,\n    type ExtractAbiFunctionNames\n} from 'abitype';\nimport { type VeChainSigner } from '../../../signer';\nimport type { TransactionReceipt } from '../../transactions/types';\nimport type { ContractCallOptions, ContractTransactionOptions } from '../types';\nimport {\n    getClauseProxy,\n    getCriteriaProxy,\n    getFilterProxy,\n    getReadProxy,\n    getTransactProxy\n} from './contract-proxy';\nimport {\n    type ContractFunctionClause,\n    type ContractFunctionCriteria,\n    type ContractFunctionFilter,\n    type ContractFunctionRead,\n    type ContractFunctionTransact\n} from './types';\nimport { type ContractsModule } from '../contracts-module';\n\n/**\n * A class representing a smart contract deployed on the blockchain.\n */\nclass Contract<TAbi extends Abi> {\n    readonly contractsModule: ContractsModule;\n    readonly address: string;\n    readonly abi: Abi;\n    private signer?: VeChainSigner;\n\n    readonly deployTransactionReceipt: TransactionReceipt | undefined;\n\n    public read: ContractFunctionRead<\n        TAbi,\n        ExtractAbiFunctionNames<TAbi, 'pure' | 'view'>\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    > = {} as ContractFunctionRead<\n        TAbi,\n        ExtractAbiFunctionNames<TAbi, 'pure' | 'view'>\n    >;\n\n    public transact: ContractFunctionTransact<\n        TAbi,\n        ExtractAbiFunctionNames<TAbi, 'payable' | 'nonpayable'>\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    > = {} as ContractFunctionTransact<\n        TAbi,\n        ExtractAbiFunctionNames<TAbi, 'payable' | 'nonpayable'>\n    >;\n\n    public filters: ContractFunctionFilter<TAbi, ExtractAbiEventNames<TAbi>> =\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        {} as ContractFunctionFilter<TAbi, ExtractAbiEventNames<TAbi>>;\n\n    public clause: ContractFunctionClause<\n        TAbi,\n        ExtractAbiFunctionNames<TAbi>\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    > = {} as ContractFunctionClause<TAbi, ExtractAbiFunctionNames<TAbi>>;\n\n    public criteria: ContractFunctionCriteria<\n        TAbi,\n        ExtractAbiEventNames<TAbi>\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    > = {} as ContractFunctionCriteria<TAbi, ExtractAbiEventNames<TAbi>>;\n\n    private contractCallOptions: ContractCallOptions = {};\n    private contractTransactionOptions: ContractTransactionOptions = {};\n\n    /**\n     * Initializes a new instance of the `Contract` class.\n     * @param address The address of the contract.\n     * @param abi The Application Binary Interface (ABI) of the contract, which defines the contract's methods and events.\n     * @param thor An instance of ThorClient to interact with the blockchain.\n     * @param signer The signer caller used for signing transactions.\n     * @param transactionReceipt (Optional) The transaction receipt of the contract deployment.\n     */\n    constructor(\n        address: string,\n        abi: Abi,\n        contractsModule: ContractsModule,\n        signer?: VeChainSigner,\n        transactionReceipt?: TransactionReceipt\n    ) {\n        this.abi = abi;\n        this.address = address;\n        this.contractsModule = contractsModule;\n        this.deployTransactionReceipt = transactionReceipt;\n        this.signer = signer;\n        this.read = getReadProxy(this);\n        this.transact = getTransactProxy(this);\n        this.filters = getFilterProxy(this);\n        this.clause = getClauseProxy(this);\n        this.criteria = getCriteriaProxy(this);\n    }\n\n    /**\n     * Sets the options for contract calls.\n     * @param options - The contract call options to set.\n     * @returns The updated contract call options.\n     */\n    public setContractReadOptions(\n        options: ContractCallOptions\n    ): ContractCallOptions {\n        this.contractCallOptions = options;\n\n        // initialize the proxy with the new options\n        this.read = getReadProxy(this);\n        return this.contractCallOptions;\n    }\n\n    /**\n     * Clears the current contract call options, resetting them to an empty object.\n     * @returns The updated contract call options.\n     */\n    public getContractReadOptions(): ContractCallOptions {\n        return this.contractCallOptions;\n    }\n\n    /**\n     * Clears the current contract call options, resetting them to an empty object.\n     */\n    public clearContractReadOptions(): void {\n        this.contractCallOptions = {};\n        this.read = getReadProxy(this);\n    }\n\n    /**\n     * Sets the options for contract transactions.\n     * @param options - The contract transaction options to set.\n     * @returns The updated contract transaction options.\n     */\n    public setContractTransactOptions(\n        options: ContractTransactionOptions\n    ): ContractTransactionOptions {\n        this.contractTransactionOptions = options;\n\n        // initialize the proxy with the new options\n        this.transact = getTransactProxy(this);\n        return this.contractTransactionOptions;\n    }\n\n    /**\n     * Retrieves the options for contract transactions.\n     * @returns The contract transaction options.\n     */\n    public getContractTransactOptions(): ContractTransactionOptions {\n        return this.contractTransactionOptions;\n    }\n\n    /**\n     * Clears the current contract transaction options, resetting them to an empty object.\n     */\n    public clearContractTransactOptions(): void {\n        this.contractTransactionOptions = {};\n        this.transact = getTransactProxy(this);\n    }\n\n    /**\n     * Sets the private key of the caller for signing transactions.\n     * @param signer - The caller signer\n     */\n    public setSigner(signer: VeChainSigner): VeChainSigner {\n        this.signer = signer;\n\n        // initialize the proxy with the new signer\n        this.transact = getTransactProxy(this);\n        this.read = getReadProxy(this);\n        return this.signer;\n    }\n\n    /**\n     * Get the caller signer used for signing transactions.\n     * @returns The signer used for signing transactions.\n     */\n    public getSigner(): VeChainSigner | undefined {\n        return this.signer;\n    }\n\n    /**\n     * Retrieves the function ABI for the specified function name.\n     * @param prop - The name of the function.\n     * @return The function ABI for the specified event name.\n     * @throws {InvalidAbiItem}\n     *\n     */\n    public getFunctionAbi(prop: string | symbol): ABIFunction {\n        return ABIContract.ofAbi(this.abi).getFunction(prop.toString());\n    }\n\n    /**\n     * Retrieves the event ABI for the specified event name.\n     * @param eventName - The name of the event.\n     * @return The event ABI for the specified event name.\n     * @throws {InvalidAbiItem}\n     */\n    public getEventAbi(eventName: string | symbol): ABIEvent {\n        return ABIContract.ofAbi(this.abi).getEvent(eventName.toString());\n    }\n}\n\nexport { Contract };\n","import {\n    Clause,\n    HexUInt,\n    Transaction,\n    type DeployParams,\n    type TransactionClause\n} from '@vechain/sdk-core';\nimport {\n    CannotFindTransaction,\n    ContractDeploymentFailed\n} from '@vechain/sdk-errors';\nimport { type Abi } from 'abitype';\nimport { signerUtils, type VeChainSigner } from '../../../signer';\nimport { type SendTransactionResult } from '../../transactions/types';\nimport type { ContractTransactionOptions } from '../types';\nimport { Contract } from './contract';\nimport { type ContractsModule } from '../contracts-module';\n\n/**\n * A factory class for deploying smart contracts to a blockchain using a ThorClient.\n */\nclass ContractFactory<TAbi extends Abi> {\n    /**\n     * The ABI (Application Binary Interface) of the contract.\n     */\n    private readonly abi: Abi;\n\n    /**\n     * The bytecode of the smart contract.\n     */\n    private readonly bytecode: string;\n\n    /**\n     * The signer used for signing transactions.\n     */\n    private readonly signer: VeChainSigner;\n\n    /**\n     * The result of the deployment transaction, undefined until a deployment is started.\n     */\n    private deployTransaction: SendTransactionResult | undefined;\n\n    readonly contractsModule: ContractsModule;\n\n    /**\n     * Initializes a new instance of the `ContractFactory` class.\n     * @param abi The Application Binary Interface (ABI) of the contract, which defines the contract's methods and events.\n     * @param bytecode The compiled bytecode of the contract, representing the contract's executable code.\n     * @param signer The signer used for signing transactions during contract deployment, ensuring the deployer's identity.\n     * @param contractsModule An instance of the module to interact with the blockchain.\n     */\n    constructor(\n        abi: Abi,\n        bytecode: string,\n        signer: VeChainSigner,\n        contractsModule: ContractsModule\n    ) {\n        this.abi = abi;\n        this.bytecode = bytecode;\n        this.signer = signer;\n        this.contractsModule = contractsModule;\n    }\n\n    /**\n     * Initiates the deployment of a smart contract.\n     *\n     * This method performs several steps to deploy a smart contract:\n     * 1. Builds a transaction clause for deploying the contract.\n     * 2. Estimates the gas cost required for the transaction.\n     * 3. Constructs the transaction body with the estimated gas cost.\n     * 4. Signs the transaction using the provided signer.\n     * 5. Sends the signed transaction to the blockchain.\n     *\n     * @param {DeployParams?} deployParams (Optional) parameters for contract deployment.\n     * @param {ContractTransactionOptions?} options (Optional) transaction options, such as gas limit.\n     * @returns {Promise<ContractFactory>} A promise that resolves to the instance of `ContractFactory`,\n     *          allowing for fluent chaining of further actions or queries.\n     * @throws {Error} Throws an error if any step in the deployment process fails.\n     */\n    public async startDeployment(\n        deployParams?: DeployParams,\n        options?: ContractTransactionOptions\n    ): Promise<ContractFactory<TAbi>> {\n        // Build a transaction for deploying the smart contract\n\n        const deployContractClause = Clause.deployContract(\n            HexUInt.of(this.bytecode),\n            deployParams\n        ) as TransactionClause;\n\n        // Estimate the gas cost of the transaction\n        const gasResult =\n            await this.contractsModule.transactionsModule.estimateGas(\n                [deployContractClause],\n                await this.signer.getAddress()\n            );\n\n        const txBody =\n            await this.contractsModule.transactionsModule.buildTransactionBody(\n                [deployContractClause],\n                gasResult.totalGas,\n                options\n            );\n\n        // Sign the transaction\n        const signedTx = await this.signer.signTransaction(\n            signerUtils.transactionBodyToTransactionRequestInput(\n                txBody,\n                await this.signer.getAddress()\n            )\n        );\n\n        // Send the signed transaction to the blockchain\n        this.deployTransaction =\n            await this.contractsModule.transactionsModule.sendTransaction(\n                Transaction.decode(HexUInt.of(signedTx.slice(2)).bytes, true)\n            );\n\n        return this;\n    }\n\n    /**\n     * Waits for the completion of a contract deployment transaction.\n     *\n     * This method checks for the presence of a deployed transaction result and then\n     * waits for the transaction to be processed. Upon successful processing, it\n     * constructs and returns a new `Contract` instance based on the transaction receipt.\n     *\n     * @returns {Promise<Contract>} A promise that resolves to a `Contract` instance\n     *          once the deployment transaction is completed.\n     * @throws {CannotFindTransaction, ContractDeploymentFailed}\n     */\n    public async waitForDeployment(): Promise<Contract<TAbi>> {\n        // Check if the deploy transaction result is available\n        if (this.deployTransaction?.id === undefined) {\n            throw new CannotFindTransaction(\n                'ContractFactory.waitForDeployment()',\n                'Cannot find a contract deployment transaction',\n                {\n                    networkUrl:\n                        this.contractsModule.transactionsModule.blocksModule\n                            .httpClient.baseURL\n                }\n            );\n        }\n\n        // Wait for the transaction to be processed\n        const transactionReceipt = await this.deployTransaction.wait();\n\n        // Ensure that the transaction receipt is valid\n        if (\n            transactionReceipt?.outputs[0]?.contractAddress === null ||\n            transactionReceipt?.outputs[0]?.contractAddress === undefined\n        ) {\n            throw new ContractDeploymentFailed(\n                'ContractFactory.waitForDeployment()',\n                'Contract deployment failed.',\n                {\n                    deployTransaction: this.deployTransaction\n                }\n            );\n        }\n\n        // Construct and return a new Contract instance\n        return new Contract<TAbi>(\n            transactionReceipt?.outputs[0].contractAddress,\n            this.abi,\n            this.contractsModule,\n            this.signer,\n            transactionReceipt\n        );\n    }\n\n    /**\n     * Returns the deploy transaction result, if available.\n     */\n    public getDeployTransaction(): SendTransactionResult | undefined {\n        return this.deployTransaction;\n    }\n}\n\nexport { ContractFactory };\n","import { type ABIFunction } from '@vechain/sdk-core';\nimport { type Abi } from 'abitype';\nimport { type VeChainSigner } from '../../signer/signers/types';\nimport {\n    type SendTransactionResult,\n    type SimulateTransactionOptions\n} from '../transactions/types';\nimport { Contract, ContractFactory } from './model';\nimport type {\n    ContractCallOptions,\n    ContractCallResult,\n    ContractClause,\n    ContractTransactionOptions\n} from './types';\nimport { type TransactionsModule } from '../transactions';\n\n/**\n * Represents a module for interacting with smart contracts on the blockchain.\n */\nclass ContractsModule {\n    constructor(readonly transactionsModule: TransactionsModule) {}\n\n    /**\n     * Creates a new instance of `ContractFactory` configured with the specified ABI, bytecode, and signer.\n     * This factory is used to deploy new smart contracts to the blockchain network managed by this instance.\n     *\n     * @param abi - The Application Binary Interface (ABI) of the contract, which defines the contract's methods and events.\n     * @param bytecode - The compiled bytecode of the contract, representing the contract's executable code.\n     * @param signer - The signer used for signing transactions during contract deployment, ensuring the deployer's identity.\n     * @returns An instance of `ContractFactory` configured with the provided ABI, bytecode, and signer, ready for deploying contracts.\n     */\n    public createContractFactory<TAbi extends Abi>(\n        abi: TAbi,\n        bytecode: string,\n        signer: VeChainSigner\n    ): ContractFactory<TAbi> {\n        return new ContractFactory<TAbi>(abi, bytecode, signer, this);\n    }\n\n    /**\n     * Initializes and returns a new Contract instance with the provided parameters.\n     *\n     * @param address - The blockchain address of the contract to load.\n     * @param abi - The Application Binary Interface (ABI) of the contract, which defines the contract's methods and structures.\n     * @param signer - Optional. The signer caller, used for signing transactions when interacting with the contract.\n     * @returns A new instance of the Contract, initialized with the provided address, ABI, and optionally, a signer.\n     */\n    public load<Tabi extends Abi>(\n        address: string,\n        abi: Tabi,\n        signer?: VeChainSigner\n    ): Contract<Tabi> {\n        return new Contract<Tabi>(address, abi, this, signer);\n    }\n\n    /**\n     * This method is going to be deprecated in next release.\n     * Use {@link TransactionsModule.executeCall} instead.\n     */\n    public async executeCall(\n        contractAddress: string,\n        functionAbi: ABIFunction,\n        functionData: unknown[],\n        contractCallOptions?: ContractCallOptions\n    ): Promise<ContractCallResult> {\n        return await this.transactionsModule.executeCall(\n            contractAddress,\n            functionAbi,\n            functionData,\n            contractCallOptions\n        );\n    }\n\n    /**\n     * This method is going to be deprecated in the next release.\n     * Use {@link TransactionsModule.executeMultipleClausesCall} next.\n     */\n    public async executeMultipleClausesCall(\n        clauses: ContractClause[],\n        options?: SimulateTransactionOptions\n    ): Promise<ContractCallResult[]> {\n        return await this.transactionsModule.executeMultipleClausesCall(\n            clauses,\n            options\n        );\n    }\n\n    /**\n     * This method is going to be deprecated in the next release.\n     * Use {@link TransactionsModule.executeTransaction} instead.\n     */\n    public async executeTransaction(\n        signer: VeChainSigner,\n        contractAddress: string,\n        functionAbi: ABIFunction,\n        functionData: unknown[],\n        options?: ContractTransactionOptions\n    ): Promise<SendTransactionResult> {\n        return await this.transactionsModule.executeTransaction(\n            signer,\n            contractAddress,\n            functionAbi,\n            functionData,\n            options\n        );\n    }\n\n    /**\n     * This method is going to be deprected in the next release.\n     * Use {@link TransactionsModule.executeMultipleClausesTransaction} instead.\n     */\n    public async executeMultipleClausesTransaction(\n        clauses: ContractClause[],\n        signer: VeChainSigner,\n        options?: ContractTransactionOptions\n    ): Promise<SendTransactionResult> {\n        return await this.transactionsModule.executeMultipleClausesTransaction(\n            clauses,\n            signer,\n            options\n        );\n    }\n\n    /**\n     * This method is going to be deprecated in the next release.\n     * Use {@link TransactionsModule.getLegacyBaseGasPrice} instead.\n     */\n    public async getLegacyBaseGasPrice(): Promise<ContractCallResult> {\n        return await this.transactionsModule.getLegacyBaseGasPrice();\n    }\n}\n\nexport { ContractsModule };\n","import { InvalidDataType } from '@vechain/sdk-errors';\nimport { thorest } from '../../utils';\nimport { type ContractTraceTarget } from './ContractTraceTarget';\nimport { type HttpClient } from '../../http';\nimport { type RetrieveStorageRange } from './RetrieveStorageRange';\nimport { type RetrieveStorageRangeOptions } from './RetrieveStorageRangeOptions';\nimport { type TransactionTraceTarget } from './TransactionTraceTarget';\nimport {\n    type ContractTraceOptions,\n    type TracerConfig,\n    type TraceReturnType,\n    type TracerName\n} from './types';\nimport { HexUInt } from '@vechain/sdk-core';\n\n/**\n * The class provides methods to debug the VeChain Thor blockchain.\n */\nclass DebugModule {\n    /**\n     * Creates an instance of the class with a specified HTTP client.\n     *\n     * @param {HttpClient} httpClient - The HTTP client instance to be used for making requests.\n     */\n    constructor(readonly httpClient: HttpClient) {}\n\n    /**\n     * Retrieve the storage range for a specified transaction trace target.\n     *\n     * @param {Object} input - The input parameters.\n     * @param {TransactionTraceTarget} input.target - The transaction trace target containing the block ID, transaction, and clause index.\n     * @param {RetrieveStorageRangeOptions} [input.options] - Optional settings for the retrieval process.\n     * @param {Address} [input.options.address] - The address for which to retrieve the storage range.\n     * @param {KeyStart} [input.options.keyStart] - The starting key for the storage range retrieval.\n     * @param {number} [input.options.maxResult] - The maximum number of results to retrieve.\n     *\n     * @return {Promise<RetrieveStorageRange>} The storage range data for the specified target.\n     *\n     * @throws IllegalDataType If {@link TransactionTraceTarget} `input.target` has a negative `clauseIndex` or `transaction` property.\n     */\n    public async retrieveStorageRange(input: {\n        target: TransactionTraceTarget;\n        options?: RetrieveStorageRangeOptions;\n    }): Promise<RetrieveStorageRange> {\n        // Validate target. If invalid, assert\n        this.validateTarget(input.target, 'retrieveStorageRange');\n\n        // Parse target\n        const parsedTarget = `${input.target.blockId}/${input.target.transaction}/${input.target.clauseIndex}`;\n\n        // Send request\n        return (await this.httpClient.post(\n            thorest.debug.post.RETRIEVE_STORAGE_RANGE(),\n            {\n                query: {},\n                body: {\n                    target: parsedTarget,\n                    address: input.options?.address?.toString(),\n                    keyStart: input.options?.keyStart?.toString(),\n                    maxResult: input.options?.maxResult\n                },\n                headers: {}\n            }\n        )) as RetrieveStorageRange;\n    }\n\n    /**\n     * Traces a contract call using the specified target, options, and configuration.\n     *\n     * @param {Object} input - The input parameters for the contract call trace.\n     * @param {ContractTraceTarget} [input.target] - The target contract details.\n     * @param {ContractTraceOptions} [input.options] - Optional configuration for the contract trace.\n     * @param {TracerConfig<typeof name>} [input.config] - Configuration for the tracer.\n     * @param {TracerName} [name] - The name of the tracer to be used.\n     * @return {Promise<TraceReturnType<typeof name>>} A promise that resolves to the trace result.\n     */\n    public async traceContractCall(\n        input: {\n            target?: ContractTraceTarget;\n            options?: ContractTraceOptions;\n            config?: TracerConfig<typeof name>;\n        },\n        name?: TracerName\n    ): Promise<TraceReturnType<typeof name>> {\n        // Send request\n        return (await this.httpClient.post(\n            thorest.debug.post.TRACE_CONTRACT_CALL(),\n            {\n                query: {},\n                body: {\n                    to: input.target?.to?.toString(),\n                    data: input.target?.data?.toString(),\n                    value:\n                        typeof input.target?.value?.wei === 'bigint'\n                            ? HexUInt.of(input.target.value.wei).toString()\n                            : undefined,\n                    name,\n                    gas: input.options?.gas,\n                    gasPrice: input.options?.gasPrice,\n                    caller: input.options?.caller,\n                    provedWork: input.options?.provedWork,\n                    gasPayer: input.options?.gasPayer,\n                    expiration: input.options?.expiration,\n                    blockRef: input.options?.blockRef,\n                    config: input.config\n                },\n                headers: {}\n            }\n        )) as TraceReturnType<typeof name>;\n    }\n\n    /**\n     * Traces a transaction clause based on the provided target and configuration.\n     *\n     * Tracers are instrumental in monitoring and analyzing the execution flow within the EVM.\n     *\n     * @param {Object} input - The input object containing the transaction trace target and optional tracer config.\n     * @param {TransactionTraceTarget} input.target - The target transaction details including block ID, transaction ID, and clause index.\n     * @param {TracerConfig<typeof name>} [input.config] - Optional tracer configuration settings.\n     * @param {TracerName} [name] - Optional name for the tracer.\n     * @return {Promise<TraceReturnType<typeof name>>} - The result of the trace operation.\n     * @throws {InvalidDataType} - If the `input.target.transaction`  or `input.target.clauseIndex` properties are invalid.\n     */\n    public async traceTransactionClause(\n        input: {\n            target: TransactionTraceTarget;\n            config?: TracerConfig<typeof name>;\n        },\n        name?: TracerName\n    ): Promise<TraceReturnType<typeof name>> {\n        // Validate target. If invalid, assert\n        this.validateTarget(input.target, 'traceTransactionClause');\n        // Parse target\n        const parsedTarget = `${input.target.blockId}/${input.target.transaction}/${input.target.clauseIndex}`;\n        // Send request\n        return (await this.httpClient.post(\n            thorest.debug.post.TRACE_TRANSACTION_CLAUSE(),\n            {\n                query: {},\n                body: {\n                    target: parsedTarget,\n                    name,\n                    config: input.config\n                },\n                headers: {}\n            }\n        )) as TraceReturnType<typeof name>;\n    }\n\n    /**\n     * Validates the properties of a TransactionTraceTarget object.\n     *\n     * @param {TransactionTraceTarget} target - The target object containing transaction details to be validated.\n     * @param {string} functionName - The name of the function where this validation is invoked.\n     * @throws {InvalidDataType} If the transaction or clauseIndex properties in the target object are invalid.\n     */\n    private validateTarget(\n        target: TransactionTraceTarget,\n        functionName: string\n    ): void {\n        // Validate target - transaction\n        if (typeof target.transaction === 'number') {\n            if (target.transaction < 0) {\n                throw new InvalidDataType(\n                    'DebugModule.validateTarget()',\n                    `invalid transaction index '${target.transaction}' given as input for ${functionName}.`,\n                    {\n                        transaction: target.transaction,\n                        functionName\n                    }\n                );\n            }\n        }\n        // Validate target - clauseIndex\n        if (target.clauseIndex < 0) {\n            throw new InvalidDataType(\n                'DebugModule.validateTarget()',\n                `invalid clause index '${target.clauseIndex}' given as input for ${functionName}.`,\n                { clauseIndex: target.clauseIndex, functionName }\n            );\n        }\n    }\n}\n\nexport { DebugModule };\n","import {\n    type FeesPriorityResponse,\n    type FeeHistoryResponse,\n    type FeeHistoryOptions,\n    type EstimateGasOptions,\n    type EstimateGasResult\n} from './types';\nimport { InvalidDataType } from '@vechain/sdk-errors';\nimport { HttpMethod, type HttpClient } from '../../http';\nimport { Revision } from '@vechain/sdk-core';\nimport { thorest } from '../../utils';\nimport { type SimulateTransactionClause } from '../transactions/types';\n\ninterface TransactionModuleInterface {\n    estimateGas: (\n        clauses: SimulateTransactionClause[],\n        caller?: string,\n        options?: EstimateGasOptions\n    ) => Promise<EstimateGasResult>;\n}\n\n/**\n * The `GasModule` handles gas related operations and provides\n * convenient methods for estimating the gas cost of a transaction.\n */\nclass GasModule {\n    readonly httpClient: HttpClient;\n    protected transactionsModule: TransactionModuleInterface | null;\n\n    constructor(httpClient: HttpClient) {\n        this.httpClient = httpClient;\n        this.transactionsModule = null;\n    }\n\n    /**\n     * Sets the transactions module.\n     *\n     * @param transactionsModule - The transactions module to set.\n     */\n    public setTransactionsModule(\n        transactionsModule: TransactionModuleInterface\n    ): void {\n        this.transactionsModule = transactionsModule;\n    }\n\n    /**\n     * Simulates a transaction and returns an object containing information regarding the gas used and whether the transaction reverted.\n     *\n     * @note The caller option is suggested as estimation without this parameter may not be accurate.\n     *\n     * @param clauses - The clauses of the transaction to simulate.\n     * @param caller - The address of the account sending the transaction.\n     * @param options - Optional parameters for the request. Includes all options of the `simulateTransaction` method excluding the `caller` option.\n     *                  @see {@link TransactionsClient#simulateTransaction}\n     *                  Also, includes the `gasPadding` option which is a percentage of gas to add on top of the estimated gas. The value must be between (0, 1].\n     * @returns An object containing information regarding the gas used and whether the transaction reverted, together with the decoded revert reason and VM errors.\n     * @throws{InvalidDataType}\n     */\n    public async estimateGas(\n        clauses: SimulateTransactionClause[],\n        caller?: string,\n        options?: EstimateGasOptions\n    ): Promise<EstimateGasResult> {\n        if (this.transactionsModule == null) {\n            throw new InvalidDataType(\n                'estimateGas()',\n                'Transactions module not set',\n                {}\n            );\n        }\n        return await this.transactionsModule.estimateGas(\n            clauses,\n            caller,\n            options\n        );\n    }\n\n    /**\n     * Returns the suggested priority fee per gas in wei.\n     * This is calculated based on the current base fee and network conditions.\n     *\n     * @returns Suggested priority fee per gas in wei (hex string)\n     * @throws {InvalidDataType}\n     */\n    public async getMaxPriorityFeePerGas(): Promise<string> {\n        const response = (await this.httpClient.get(\n            '/fees/priority'\n        )) as FeesPriorityResponse;\n\n        // Validate response\n        if (\n            response === null ||\n            response === undefined ||\n            typeof response !== 'object'\n        ) {\n            throw new InvalidDataType(\n                'getMaxPriorityFeePerGas()',\n                'Invalid response format from /fees/priority endpoint',\n                { response }\n            );\n        }\n\n        if (\n            response.maxPriorityFeePerGas === undefined ||\n            response.maxPriorityFeePerGas === null ||\n            response.maxPriorityFeePerGas === '' ||\n            typeof response.maxPriorityFeePerGas !== 'string'\n        ) {\n            throw new InvalidDataType(\n                'getMaxPriorityFeePerGas()',\n                'Missing or invalid maxPriorityFeePerGas in response',\n                { response }\n            );\n        }\n\n        return response.maxPriorityFeePerGas;\n    }\n\n    /**\n     * Returns fee history for the returned block range.\n     *\n     * @param options - The options for the fee history request\n     * @returns Fee history for the returned block range\n     * @throws {InvalidDataType}\n     */\n    public async getFeeHistory(\n        options: FeeHistoryOptions\n    ): Promise<FeeHistoryResponse> {\n        if (\n            options === null ||\n            options === undefined ||\n            typeof options.blockCount !== 'number' ||\n            !Number.isFinite(options.blockCount) ||\n            options.blockCount <= 0\n        ) {\n            throw new InvalidDataType(\n                'getFeeHistory()',\n                'Invalid blockCount parameter',\n                { options }\n            );\n        }\n\n        if (\n            options.newestBlock !== null &&\n            options.newestBlock !== undefined &&\n            !Revision.isValid(options.newestBlock)\n        ) {\n            throw new InvalidDataType(\n                'getFeeHistory()',\n                'Invalid revision. The revision must be a string representing a block number or block id (also \"best\" is accepted which represents the best block & \"finalized\" for the finalized block).',\n                { options }\n            );\n        }\n\n        const response = await this.httpClient.http(\n            HttpMethod.GET,\n            thorest.fees.get.FEES_HISTORY(\n                options.blockCount,\n                options.newestBlock,\n                options.rewardPercentiles\n            )\n        );\n        if (\n            response === null ||\n            response === undefined ||\n            typeof response !== 'object'\n        ) {\n            throw new InvalidDataType(\n                'getFeeHistory()',\n                'Invalid response format from /fees/history endpoint',\n                { response }\n            );\n        }\n\n        return response as FeeHistoryResponse;\n    }\n}\n\nexport { GasModule };\n","import { type ABIEvent, Hex } from '@vechain/sdk-core';\nimport { InvalidAbiItem } from '@vechain/sdk-errors';\nimport { thorest } from '../../utils/thorest/thorest';\nimport {\n    type EventLogs,\n    type FilterEventLogsOptions,\n    type FilterRawEventLogsOptions,\n    type FilterTransferLogsOptions,\n    type TransferLogs\n} from './types';\nimport { HttpMethod } from '../../http';\nimport { type BlocksModule } from '../blocks';\n\n/**\n * The `LogsClient` class provides methods to interact with log-related endpoints\n * of the VeChainThor blockchain. It allows filtering event and transfer logs.\n */\nclass LogsModule {\n    readonly blocksModule: BlocksModule;\n\n    constructor(blocksModule: BlocksModule) {\n        this.blocksModule = blocksModule;\n    }\n\n    /**\n     * Filters event logs based on the provided criteria. Raw event logs are not decoded.\n     *\n     * @param filterOptions - An object specifying filtering criteria for event logs.\n     * @returns A promise that resolves to filtered event logs.\n     */\n    public async filterRawEventLogs(\n        filterOptions: FilterRawEventLogsOptions\n    ): Promise<EventLogs[]> {\n        return (await this.blocksModule.httpClient.http(\n            HttpMethod.POST,\n            thorest.logs.post.EVENT_LOGS(),\n            {\n                query: {},\n                body: filterOptions,\n                headers: {}\n            }\n        )) as EventLogs[];\n    }\n\n    /**\n     * Filters event logs based on the provided criteria and decodes them using the provided ABI items.\n     * The decoded data is added to the event logs as a new property.\n     * @param filterOptions - An object specifying filtering criteria for event logs.\n     */\n    public async filterEventLogs(\n        filterOptions: FilterEventLogsOptions\n    ): Promise<EventLogs[]> {\n        // Extract raw event logs and ABI items from filter options\n        const eventAbis = filterOptions.criteriaSet?.map((c) => c.eventAbi);\n\n        const eventLogs = await this.getRawEventLogs(filterOptions);\n\n        const result: EventLogs[] = [];\n\n        if (eventAbis !== undefined) {\n            const uniqueEventAbis = this.removeDuplicatedAbis(eventAbis);\n\n            eventLogs.forEach((log) => {\n                const eventAbi = uniqueEventAbis.get(log.topics[0]);\n                if (eventAbi === undefined || eventAbi === null) {\n                    throw new InvalidAbiItem(\n                        'LogsModule.filterEventLogs',\n                        'Topic not found in the provided ABIs.',\n                        { type: 'event', value: log.topics[0] }\n                    );\n                }\n                log.decodedData = eventAbi.decodeEventLogAsArray({\n                    data: Hex.of(log.data),\n                    topics: log.topics.map((topic) => Hex.of(topic))\n                });\n                result.push(log);\n            });\n        }\n\n        return result;\n    }\n\n    /**\n     * Filters event logs based on the provided criteria and decodes them using the provided ABI items.\n     * The decoded data is added to the event logs as a new property.\n     * The result is an array of event logs grouped by the event topic hash.\n     * @param filterOptions\n     * @returns A promise that resolves to an array of event logs grouped by event.\n     */\n    public async filterGroupedEventLogs(\n        filterOptions: FilterEventLogsOptions\n    ): Promise<EventLogs[][]> {\n        // Extract raw event logs and ABI items from filter options\n        const eventAbis = filterOptions.criteriaSet?.map((c) => c.eventAbi);\n\n        const eventLogs = await this.getRawEventLogs(filterOptions);\n\n        const result = new Map<string, EventLogs[]>();\n\n        if (eventAbis !== undefined) {\n            const uniqueEventAbis = this.removeDuplicatedAbis(eventAbis);\n\n            // Initialize the result map with empty arrays for each unique ABI item\n            uniqueEventAbis.forEach((f) => result.set(f.signatureHash, []));\n\n            eventLogs.forEach((log) => {\n                const eventAbi = uniqueEventAbis.get(log.topics[0]);\n                if (eventAbi === undefined || eventAbi === null) {\n                    throw new InvalidAbiItem(\n                        'LogsModule.filterGroupedEventLogs',\n                        'Topic not found in the provided ABIs.',\n                        { type: 'event', value: log.topics[0] }\n                    );\n                }\n\n                log.decodedData = eventAbi.decodeEventLogAsArray({\n                    data: Hex.of(log.data),\n                    topics: log.topics.map((topic) => Hex.of(topic))\n                });\n                result.get(log.topics[0])?.push(log);\n            });\n        }\n\n        return Array.from(result.values());\n    }\n\n    /**\n     * Filters event logs based on the provided criteria without decoding them.\n     * @param filterOptions - An object specifying filtering criteria for event logs.\n     * @private Returns a promise that resolves to filtered non decoded event logs.\n     */\n    private async getRawEventLogs(\n        filterOptions: FilterEventLogsOptions\n    ): Promise<EventLogs[]> {\n        const criteriaSet = filterOptions.criteriaSet?.map((c) => c.criteria);\n        // Create new filter options with the criteria set\n        const filterRawEventLogsOptions: FilterRawEventLogsOptions = {\n            range: filterOptions.range ?? {\n                unit: 'block',\n                from: 0,\n                to: (await this.blocksModule.getBestBlockCompressed())?.number\n            },\n            criteriaSet,\n            options: filterOptions.options,\n            order: filterOptions.order ?? 'asc'\n        };\n\n        // Filter event logs based on the provided criteria\n        return await this.filterRawEventLogs(filterRawEventLogsOptions);\n    }\n\n    /**\n     * Removes duplicated ABI items from the provided array. ABI items are considered duplicated if they have the same topic hash.\n     * @param eventAbis - An array of event ABI items.\n     * @private Returns a map of unique ABI items.\n     */\n    private removeDuplicatedAbis(eventAbis: ABIEvent[]): Map<string, ABIEvent> {\n        const uniqueEventAbis = new Map<string, ABIEvent>();\n\n        eventAbis.forEach((obj) => {\n            if (!uniqueEventAbis.has(obj.signatureHash)) {\n                uniqueEventAbis.set(obj.signatureHash, obj);\n            }\n        });\n\n        return uniqueEventAbis;\n    }\n\n    /**\n     * Filters transfer logs based on the provided criteria.\n     *\n     * @param filterOptions - An object specifying filtering criteria for transfer logs.\n     * @returns A promise that resolves to filtered transfer logs.\n     */\n    public async filterTransferLogs(\n        filterOptions: FilterTransferLogsOptions\n    ): Promise<TransferLogs[]> {\n        return (await this.blocksModule.httpClient.http(\n            HttpMethod.POST,\n            thorest.logs.post.TRANSFER_LOGS(),\n            {\n                query: {},\n                body: filterOptions,\n                headers: {}\n            }\n        )) as TransferLogs[];\n    }\n}\n\nexport { LogsModule };\n","import { InvalidDataType } from '@vechain/sdk-errors';\nimport { NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS, thorest } from '../../utils';\nimport { type BlocksModule, type CompressedBlockDetail } from '../blocks';\nimport { type ConnectedPeer } from './types';\nimport { HttpMethod } from '../../http';\n\n/**\n * The `NodesModule` class serves as a module for node-related functionality, for example, checking the health of a node.\n */\nclass NodesModule {\n    readonly blocksModule: BlocksModule;\n\n    constructor(blocksModule: BlocksModule) {\n        this.blocksModule = blocksModule;\n    }\n\n    /**\n     * Retrieves connected peers of a node.\n     *\n     * @returns A promise that resolves to the list of connected peers.\n     */\n    public async getNodes(): Promise<ConnectedPeer[]> {\n        const nodes = (await this.blocksModule.httpClient.http(\n            HttpMethod.GET,\n            thorest.nodes.get.NODES()\n        )) as ConnectedPeer[] | null;\n        return nodes ?? [];\n    }\n\n    /**\n     * Checks the health of a node using the following algorithm:\n     * 1. Make an HTTP GET request to retrieve the last block timestamp.\n     * 2. Calculates the difference between the current time and the last block timestamp.\n     * 3. If the difference is less than the tolerance, the node is healthy.\n     * Note, we could also check '/node/network/peers since' but the difficulty with this approach is\n     * if you consider a scenario where the node is connected to 20+ peers, which is healthy, and it receives the new blocks as expected.\n     * But what if the node's disk is full, and it's not writing the new blocks to its database? In this case the node is off-sync even\n     * though it's technically alive and connected\n     * @returns A boolean indicating whether the node is healthy.\n     * @throws {InvalidDataTypeError}\n     */\n    public async isHealthy(): Promise<boolean> {\n        /**\n         * @internal\n         * Perform an HTTP GET request using the SimpleNet instance to get the latest block\n         */\n        const response = await this.blocksModule.getBestBlockCompressed();\n\n        /**\n         * timestamp from the last block and, eventually handle errors\n         * @internal\n         */\n        const lastBlockTimestamp: number = this.getTimestampFromBlock(response);\n\n        /**\n         * seconds elapsed since the timestamp of the last block\n         * @internal\n         */\n        const secondsSinceLastBlock =\n            Math.floor(Date.now() / 1000) - lastBlockTimestamp;\n\n        return (\n            Math.abs(secondsSinceLastBlock) <\n            NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS\n        );\n    }\n\n    /**\n     * Extracts the timestamp from the block\n     * @remarks\n     * This function throws an error if the timestamp key does not exist in the response from the API call to the node\n     * @param response the response from the API call to the node\n     * @returns the timestamp from the block\n     * @throws{InvalidDataType}\n     */\n    private readonly getTimestampFromBlock = (\n        response: CompressedBlockDetail | null\n    ): number => {\n        if (\n            response === null ||\n            response === undefined ||\n            typeof response !== 'object' ||\n            !('timestamp' in response) ||\n            typeof response.timestamp !== 'number'\n        ) {\n            throw new InvalidDataType(\n                'NodesModule.getTimestampFromBlock()',\n                'Sending failed: Input must be a valid raw transaction in hex format.',\n                { response }\n            );\n        }\n\n        return response?.timestamp;\n    };\n}\n\nexport { NodesModule };\n","import { Keccak256, Txt } from '@vechain/sdk-core';\n\n/**\n * The selector of the `Error(string)` function in Solidity.\n */\nconst SOLIDITY_ERROR_SELECTOR = Keccak256.of(Txt.of('Error(string)').bytes)\n    .toString()\n    .slice(0, 10);\n\n/**\n * The selector of the `Panic(uint256)` function in Solidity.\n */\nconst SOLIDITY_PANIC_SELECTOR = Keccak256.of(Txt.of('Panic(uint256)').bytes)\n    .toString()\n    .slice(0, 10);\n\nexport { SOLIDITY_ERROR_SELECTOR, SOLIDITY_PANIC_SELECTOR };\n","// https://docs.soliditylang.org/en/v0.8.16/control-structures.html#error-handling-assert-require-revert-and-exceptions\n// builtin errors in solidity, Error(string) and Panic(uint256)\n\nimport { ABI } from '@vechain/sdk-core';\nimport { SOLIDITY_ERROR_SELECTOR, SOLIDITY_PANIC_SELECTOR } from './const';\n\n/**\n * Decodes revert reasons from a given hex-encoded data string, identifying whether the revert is due to an \"Error(string)\" or a \"Panic(uint256)\".\n *\n * @param data - Hex-encoded data containing revert information.\n * @returns Decoded revert reason or an error message if decoding fails.\n *\n * @example\n * ```typescript\n * const revertReason = decodeRevertReason('0x0123456789abcdef0123456789abcdef');\n * console.log(revertReason); // 'Decoded Revert Reason'\n * ```\n */\nfunction decodeRevertReason(data: string): string | undefined {\n    // Check if the revert reason starts with the error selector\n    if (data.startsWith(SOLIDITY_ERROR_SELECTOR))\n        // Decode the error message from the remaining data\n        return ABI.ofEncoded(\n            'string',\n            '0x' + data.slice(SOLIDITY_ERROR_SELECTOR.length)\n        ).getFirstDecodedValue();\n\n    if (data.startsWith(SOLIDITY_PANIC_SELECTOR)) {\n        // Decode the panic code and format it as a string\n        const decoded = ABI.ofEncoded(\n            'uint256',\n            '0x' + data.slice(SOLIDITY_PANIC_SELECTOR.length)\n        ).getFirstDecodedValue<string>();\n        return `Panic(0x${parseInt(decoded).toString(16).padStart(2, '0')})`;\n    }\n}\n\nexport { decodeRevertReason };\n","import {\n    ABI,\n    ABIContract,\n    type ABIFunction,\n    Address,\n    Clause,\n    dataUtils,\n    Hex,\n    HexUInt,\n    Revision,\n    ThorId,\n    Transaction,\n    type TransactionBody,\n    type TransactionClause,\n    Units,\n    VET\n} from '@vechain/sdk-core';\nimport { InvalidDataType, InvalidTransactionField } from '@vechain/sdk-errors';\nimport { ErrorFragment, Interface } from 'ethers';\nimport { HttpMethod } from '../../http';\nimport { blocksFormatter, getTransactionIndexIntoBlock } from '../../provider';\nimport type { VeChainSigner } from '../../signer';\nimport {\n    buildQuery,\n    BUILT_IN_CONTRACTS,\n    ERROR_SELECTOR,\n    PANIC_SELECTOR,\n    Poll,\n    thorest,\n    vnsUtils\n} from '../../utils';\nimport { type BlocksModule, type ExpandedBlockDetail } from '../blocks';\nimport type {\n    ContractCallOptions,\n    ContractCallResult,\n    ContractClause,\n    ContractTransactionOptions\n} from '../contracts';\nimport { type CallNameReturnType, type DebugModule } from '../debug';\nimport { type ForkDetector } from '../fork';\nimport { type GasModule } from '../gas';\nimport { decodeRevertReason } from '../gas/helpers/decode-evm-error';\nimport type { EstimateGasOptions, EstimateGasResult } from '../gas/types';\nimport { type LogsModule } from '../logs';\nimport {\n    type GetTransactionInputOptions,\n    type GetTransactionReceiptInputOptions,\n    type SendTransactionResult,\n    type SimulateTransactionClause,\n    type SimulateTransactionOptions,\n    type TransactionBodyOptions,\n    type TransactionDetailNoRaw,\n    type TransactionDetailRaw,\n    type TransactionReceipt,\n    type TransactionSimulationResult,\n    type WaitForTransactionOptions\n} from './types';\n\n/**\n * The `TransactionsModule` handles transaction related operations and provides\n * convenient methods for sending transactions and waiting for transaction confirmation.\n */\nclass TransactionsModule {\n    readonly blocksModule: BlocksModule;\n    readonly debugModule: DebugModule;\n    readonly logsModule: LogsModule;\n    readonly gasModule: GasModule;\n    readonly forkDetector: ForkDetector;\n\n    constructor(\n        blocksModule: BlocksModule,\n        debugModule: DebugModule,\n        logsModule: LogsModule,\n        gasModule: GasModule,\n        forkDetector: ForkDetector\n    ) {\n        this.blocksModule = blocksModule;\n        this.debugModule = debugModule;\n        this.logsModule = logsModule;\n        this.gasModule = gasModule;\n        this.forkDetector = forkDetector;\n    }\n\n    /**\n     * Retrieves the details of a transaction.\n     *\n     * @param id - Transaction ID of the transaction to retrieve.\n     * @param options - (Optional) Other optional parameters for the request.\n     * @returns A promise that resolves to the details of the transaction.\n     * @throws {InvalidDataType}\n     */\n    public async getTransaction(\n        id: string,\n        options?: GetTransactionInputOptions\n    ): Promise<TransactionDetailNoRaw | null> {\n        // Invalid transaction ID\n        if (!ThorId.isValid(id)) {\n            throw new InvalidDataType(\n                'TransactionsModule.getTransaction()',\n                'Invalid transaction ID given as input. Input must be an hex string of length 64.',\n                { id }\n            );\n        }\n\n        // Invalid head\n        if (options?.head !== undefined && !ThorId.isValid(options.head))\n            throw new InvalidDataType(\n                'TransactionsModule.getTransaction()',\n                'Invalid head given as input. Input must be an hex string of length 64.',\n                { head: options?.head }\n            );\n\n        return (await this.blocksModule.httpClient.http(\n            HttpMethod.GET,\n            thorest.transactions.get.TRANSACTION(id),\n            {\n                query: buildQuery({\n                    raw: false,\n                    head: options?.head,\n                    pending: options?.pending\n                })\n            }\n        )) as TransactionDetailNoRaw | null;\n    }\n\n    /**\n     * Retrieves the details of a transaction.\n     *\n     * @param id - Transaction ID of the transaction to retrieve.\n     * @param options - (Optional) Other optional parameters for the request.\n     * @returns A promise that resolves to the details of the transaction.\n     * @throws {InvalidDataType}\n     */\n    public async getTransactionRaw(\n        id: string,\n        options?: GetTransactionInputOptions\n    ): Promise<TransactionDetailRaw | null> {\n        // Invalid transaction ID\n        if (!ThorId.isValid(id)) {\n            throw new InvalidDataType(\n                'TransactionsModule.getTransactionRaw()',\n                'Invalid transaction ID given as input. Input must be an hex string of length 64.',\n                { id }\n            );\n        }\n\n        // Invalid head\n        if (options?.head !== undefined && !ThorId.isValid(options.head))\n            throw new InvalidDataType(\n                'TransactionsModule.getTransaction()',\n                'Invalid head given as input. Input must be an hex string of length 64.',\n                { head: options?.head }\n            );\n\n        return (await this.blocksModule.httpClient.http(\n            HttpMethod.GET,\n            thorest.transactions.get.TRANSACTION(id),\n            {\n                query: buildQuery({\n                    raw: true,\n                    head: options?.head,\n                    pending: options?.pending\n                })\n            }\n        )) as TransactionDetailRaw | null;\n    }\n\n    /**\n     * Retrieves the receipt of a transaction.\n     *\n     * @param id - Transaction ID of the transaction to retrieve.\n     * @param options - (Optional) Other optional parameters for the request.\n     *                  If `head` is not specified, the receipt of the transaction at the best block is returned.\n     * @returns A promise that resolves to the receipt of the transaction.\n     * @throws {InvalidDataType}\n     */\n    public async getTransactionReceipt(\n        id: string,\n        options?: GetTransactionReceiptInputOptions\n    ): Promise<TransactionReceipt | null> {\n        // Invalid transaction ID\n        if (!ThorId.isValid(id)) {\n            throw new InvalidDataType(\n                'TransactionsModule.getTransactionReceipt()',\n                'Invalid transaction ID given as input. Input must be an hex string of length 64.',\n                { id }\n            );\n        }\n\n        // Invalid head\n        if (options?.head !== undefined && !ThorId.isValid(options.head))\n            throw new InvalidDataType(\n                'TransactionsModule.getTransaction()',\n                'Invalid head given as input. Input must be an hex string of length 64.',\n                { head: options?.head }\n            );\n\n        return (await this.blocksModule.httpClient.http(\n            HttpMethod.GET,\n            thorest.transactions.get.TRANSACTION_RECEIPT(id),\n            {\n                query: buildQuery({ head: options?.head })\n            }\n        )) as TransactionReceipt | null;\n    }\n\n    /**\n     * Retrieves the receipt of a transaction.\n     *\n     * @param raw - The raw transaction.\n     * @returns The transaction id of send transaction.\n     * @throws {InvalidDataType}\n     */\n    public async sendRawTransaction(\n        raw: string\n    ): Promise<SendTransactionResult> {\n        // Validate raw transaction\n        if (!Hex.isValid0x(raw)) {\n            throw new InvalidDataType(\n                'TransactionsModule.sendRawTransaction()',\n                'Sending failed: Input must be a valid raw transaction in hex format.',\n                { raw }\n            );\n        }\n\n        // Decode raw transaction to check if raw is ok\n        try {\n            Transaction.decode(HexUInt.of(raw.slice(2)).bytes, true);\n        } catch (error) {\n            throw new InvalidDataType(\n                'TransactionsModule.sendRawTransaction()',\n                'Sending failed: Input must be a valid raw transaction in hex format. Decoding error encountered.',\n                { raw },\n                error\n            );\n        }\n\n        const transactionResult = (await this.blocksModule.httpClient.http(\n            HttpMethod.POST,\n            thorest.transactions.post.TRANSACTION(),\n            {\n                body: { raw }\n            }\n        )) as SendTransactionResult;\n\n        return {\n            id: transactionResult.id,\n            wait: async () =>\n                await this.waitForTransaction(transactionResult.id)\n        };\n    }\n\n    /**\n     * Sends a signed transaction to the network.\n     *\n     * @param signedTx - the transaction to send. It must be signed.\n     * @returns A promise that resolves to the transaction ID of the sent transaction.\n     * @throws {InvalidDataType}\n     */\n    public async sendTransaction(\n        signedTx: Transaction\n    ): Promise<SendTransactionResult> {\n        // Assert transaction is signed or not\n        if (!signedTx.isSigned) {\n            throw new InvalidDataType(\n                'TransactionsModule.sendTransaction()',\n                'Invalid transaction given as input. Transaction must be signed.',\n                { signedTx }\n            );\n        }\n\n        const rawTx = Hex.of(signedTx.encoded).toString();\n\n        return await this.sendRawTransaction(rawTx);\n    }\n\n    /**\n     * Waits for a transaction to be included in a block.\n     *\n     * @param txID - The transaction ID of the transaction to wait for.\n     * @param options - Optional parameters for the request. Includes the timeout and interval between requests.\n     *                  Both parameters are in milliseconds. If the timeout is not specified, the request will not time out!\n     * @returns A promise that resolves to the transaction receipt of the transaction. If the transaction is not included in a block before the timeout,\n     *          the promise will resolve to `null`.\n     * @throws {InvalidDataType}\n     */\n    public async waitForTransaction(\n        txID: string,\n        options?: WaitForTransactionOptions\n    ): Promise<TransactionReceipt | null> {\n        // Invalid transaction ID\n        if (!ThorId.isValid(txID)) {\n            throw new InvalidDataType(\n                'TransactionsModule.waitForTransaction()',\n                'Invalid transaction ID given as input. Input must be an hex string of length 64.',\n                { txID }\n            );\n        }\n\n        return await Poll.SyncPoll(\n            async () => await this.getTransactionReceipt(txID),\n            {\n                requestIntervalInMilliseconds: options?.intervalMs,\n                maximumWaitingTimeInMilliseconds: options?.timeoutMs\n            }\n        ).waitUntil((result) => {\n            return result !== null;\n        });\n    }\n\n    /**\n     * Builds a transaction body with the given clauses without having to\n     * specify the chainTag, expiration, gasPriceCoef, gas, dependsOn and reserved fields.\n     *\n     * @param clauses - The clauses of the transaction.\n     * @param gas - The gas to be used to perform the transaction.\n     * @param options - Optional parameters for the request. Includes the expiration, gasPriceCoef, maxFeePErGas, maxPriorityFeePerGas, dependsOn and isDelegated fields.\n     *                  If the `expiration` is not specified, the transaction will expire after 32 blocks.\n     *                  If the `gasPriceCoef` is not specified & galactica fork didn't happen yet, the transaction will use the default gas price coef of 0.\n     *                  If the `gasPriceCoef` is not specified & galactica fork happened, the transaction will use the default maxFeePerGas and maxPriorityFeePerGas.\n     *                  If the `dependsOn is` not specified, the transaction will not depend on any other transaction.\n     *                  If the `isDelegated` is not specified, the transaction will not be delegated.\n     *\n     * @returns A promise that resolves to the transaction body.\n     *\n     * @throws an error if the genesis block or the latest block cannot be retrieved.\n     */\n    public async buildTransactionBody(\n        clauses: TransactionClause[],\n        gas: number,\n        options?: TransactionBodyOptions\n    ): Promise<TransactionBody> {\n        // Get the genesis block to get the chainTag\n        const genesisBlock = await this.blocksModule.getBlockCompressed(0);\n        if (genesisBlock === null)\n            throw new InvalidTransactionField(\n                'TransactionsModule.buildTransactionBody()',\n                'Error while building transaction body: Cannot get genesis block.',\n                { fieldName: 'genesisBlock', genesisBlock, clauses, options }\n            );\n\n        const blockRef =\n            options?.blockRef ?? (await this.blocksModule.getBestBlockRef());\n        if (blockRef === null)\n            throw new InvalidTransactionField(\n                'TransactionsModule.buildTransactionBody()',\n                'Error while building transaction body: Cannot get blockRef.',\n                { fieldName: 'blockRef', blockRef, clauses, options }\n            );\n\n        const chainTag =\n            options?.chainTag ?? Number(`0x${genesisBlock.id.slice(64)}`);\n\n        const filledOptions = await this.fillDefaultBodyOptions(options);\n\n        return {\n            blockRef,\n            chainTag,\n            clauses: await this.resolveNamesInClauses(clauses),\n            dependsOn: options?.dependsOn ?? null,\n            expiration: options?.expiration ?? 32,\n            gas,\n            gasPriceCoef: filledOptions?.gasPriceCoef,\n            maxFeePerGas: filledOptions?.maxFeePerGas,\n            maxPriorityFeePerGas: filledOptions?.maxPriorityFeePerGas,\n            nonce: options?.nonce ?? Hex.random(8).toString(),\n            reserved:\n                options?.isDelegated === true ? { features: 1 } : undefined\n        };\n    }\n\n    /**\n     * Fills the transaction body with the default options.\n     *\n     * @param body - The transaction body to fill.\n     * @returns A promise that resolves to the filled transaction body.\n     * @throws {InvalidDataType}\n     */\n    public async fillTransactionBody(\n        body: TransactionBody\n    ): Promise<TransactionBody> {\n        const extractedOptions: TransactionBodyOptions = {\n            maxFeePerGas: body.maxFeePerGas,\n            maxPriorityFeePerGas: body.maxPriorityFeePerGas,\n            gasPriceCoef: body.gasPriceCoef\n        };\n\n        const filledOptions =\n            await this.fillDefaultBodyOptions(extractedOptions);\n        return {\n            ...body,\n            ...filledOptions\n        };\n    }\n\n    /**\n     * Fills the default body options for a transaction.\n     *\n     * @param options - The transaction body options to fill.\n     * @returns A promise that resolves to the filled transaction body options.\n     * @throws {InvalidDataType}\n     */\n    public async fillDefaultBodyOptions(\n        options?: TransactionBodyOptions\n    ): Promise<TransactionBodyOptions> {\n        options ??= {};\n        if (options.gasPriceCoef !== undefined) {\n            // user specified legacy fee type\n            options.maxFeePerGas = undefined;\n            options.maxPriorityFeePerGas = undefined;\n            return options;\n        }\n        if (\n            options.gasPriceCoef !== undefined &&\n            (options.maxFeePerGas !== undefined ||\n                options.maxPriorityFeePerGas !== undefined)\n        ) {\n            // user specified both legacy and dynamic fee type\n            throw new InvalidDataType(\n                'TransactionsModule.fillDefaultBodyOptions()',\n                'Invalid transaction body options. Cannot specify both legacy and dynamic fee type options.',\n                { options }\n            );\n        }\n        // check if fork happened\n        const galacticaHappened =\n            await this.forkDetector.isGalacticaForked('best');\n        if (\n            !galacticaHappened &&\n            (options.maxFeePerGas !== undefined ||\n                options.maxPriorityFeePerGas !== undefined)\n        ) {\n            // user has specified dynamic fee tx, but fork didn't happen yet\n            throw new InvalidDataType(\n                'TransactionsModule.fillDefaultBodyOptions()',\n                'Invalid transaction body options. Dynamic fee tx is not allowed before Galactica fork.',\n                { options }\n            );\n        }\n        if (\n            !galacticaHappened &&\n            (options.gasPriceCoef === undefined ||\n                options.gasPriceCoef === null)\n        ) {\n            // galactica hasn't happened yet, default is legacy fee\n            options.gasPriceCoef = 0;\n            return options;\n        }\n        if (\n            galacticaHappened &&\n            options.maxFeePerGas !== undefined &&\n            options.maxPriorityFeePerGas !== undefined\n        ) {\n            // galactica happened, user specified new fee type\n            return options;\n        }\n        // default to dynamic fee tx\n        options.gasPriceCoef = undefined;\n\n        // Get best block base fee per gas\n        const bestBlockBaseFeePerGas =\n            await this.blocksModule.getBestBlockBaseFeePerGas();\n        if (\n            bestBlockBaseFeePerGas === null ||\n            bestBlockBaseFeePerGas === undefined\n        ) {\n            throw new InvalidDataType(\n                'TransactionsModule.fillDefaultBodyOptions()',\n                'Invalid transaction body options. Unable to get best block base fee per gas.',\n                { options }\n            );\n        }\n        const biBestBlockBaseFeePerGas = HexUInt.of(bestBlockBaseFeePerGas).bi;\n\n        // set maxPriorityFeePerGas if not specified already\n        if (\n            options.maxPriorityFeePerGas === undefined ||\n            options.maxPriorityFeePerGas === null\n        ) {\n            // Calculate maxPriorityFeePerGas based on fee history (75th percentile)\n            // and the HIGH speed threshold (min(0.046*baseFee, 75_percentile))\n            const defaultMaxPriorityFeePerGas =\n                await this.calculateDefaultMaxPriorityFeePerGas(\n                    biBestBlockBaseFeePerGas\n                );\n            options.maxPriorityFeePerGas = defaultMaxPriorityFeePerGas;\n        }\n\n        // set maxFeePerGas if not specified already\n        if (\n            options.maxFeePerGas === undefined ||\n            options.maxFeePerGas === null\n        ) {\n            // compute maxFeePerGas\n            const biMaxPriorityFeePerGas = HexUInt.of(\n                options.maxPriorityFeePerGas\n            ).bi;\n            const biMaxFeePerGas =\n                biBestBlockBaseFeePerGas + biMaxPriorityFeePerGas;\n            options.maxFeePerGas = HexUInt.of(biMaxFeePerGas).toString();\n        }\n        return options;\n    }\n\n    /**\n     * Calculates the default max priority fee per gas based on the current base fee\n     * and historical 75th percentile rewards.\n     *\n     * Uses the FAST (HIGH) speed threshold: min(0.046*baseFee, 75_percentile)\n     *\n     * @param baseFee - The current base fee per gas\n     * @returns A promise that resolves to the default max priority fee per gas as a hex string\n     */\n    private async calculateDefaultMaxPriorityFeePerGas(\n        baseFee: bigint\n    ): Promise<string> {\n        // Get fee history for recent blocks\n        const feeHistory = await this.gasModule.getFeeHistory({\n            blockCount: 10,\n            newestBlock: 'best',\n            rewardPercentiles: [25, 50, 75] // Get 25th, 50th and 75th percentiles\n        });\n\n        // Get the 75th percentile reward from the most recent block\n        let percentile75: bigint;\n\n        if (\n            feeHistory.reward !== null &&\n            feeHistory.reward !== undefined &&\n            feeHistory.reward.length > 0\n        ) {\n            const latestBlockRewards =\n                feeHistory.reward[feeHistory.reward.length - 1];\n            const equalRewardsOnLastBlock =\n                new Set(latestBlockRewards).size === 3;\n\n            // If rewards are equal in the last block, use the first one (75th percentile)\n            // Otherwise, calculate the average of 75th percentiles across blocks\n            if (equalRewardsOnLastBlock) {\n                percentile75 = HexUInt.of(latestBlockRewards[2]).bi; // 75th percentile at index 2\n            } else {\n                // Calculate average of 75th percentiles across blocks\n                let sum = 0n;\n                let count = 0;\n\n                for (const blockRewards of feeHistory.reward) {\n                    if (\n                        blockRewards.length !== null &&\n                        blockRewards.length > 2 &&\n                        blockRewards[2] !== null &&\n                        blockRewards[2] !== undefined\n                    ) {\n                        sum += HexUInt.of(blockRewards[2]).bi;\n                        count++;\n                    }\n                }\n\n                percentile75 = count > 0 ? sum / BigInt(count) : 0n;\n            }\n        } else {\n            // Fallback to getMaxPriorityFeePerGas if fee history is not available\n            percentile75 = HexUInt.of(\n                await this.gasModule.getMaxPriorityFeePerGas()\n            ).bi;\n        }\n\n        // Calculate 4.6% of base fee (HIGH speed threshold)\n        const baseFeeCap = (baseFee * 46n) / 1000n; // 0.046 * baseFee\n\n        // Use the minimum of the two values\n        const priorityFee =\n            baseFeeCap < percentile75 ? baseFeeCap : percentile75;\n\n        return HexUInt.of(priorityFee).toString();\n    }\n\n    /**\n     * Ensures that names in clauses are resolved to addresses\n     *\n     * @param clauses - The clauses of the transaction.\n     * @returns A promise that resolves to clauses with resolved addresses\n     */\n    public async resolveNamesInClauses(\n        clauses: TransactionClause[]\n    ): Promise<TransactionClause[]> {\n        // find unique names in the clause list\n        const uniqueNames = clauses.reduce((map, clause) => {\n            if (\n                typeof clause.to === 'string' &&\n                !map.has(clause.to) &&\n                clause.to.includes('.')\n            ) {\n                map.set(clause.to, clause.to);\n            }\n            return map;\n        }, new Map<string, string>());\n\n        const nameList = [...uniqueNames.keys()];\n\n        // no names, return the original clauses\n        if (uniqueNames.size === 0) {\n            return clauses;\n        }\n\n        // resolve the names to addresses\n        const addresses = await vnsUtils.resolveNames(\n            this.blocksModule,\n            this,\n            nameList\n        );\n\n        // map unique names with resolved addresses\n        addresses.forEach((address, index) => {\n            if (address !== null) {\n                uniqueNames.set(nameList[index], address);\n            }\n        });\n\n        // replace names with resolved addresses, or leave unchanged\n        return clauses.map((clause) => {\n            if (typeof clause.to !== 'string') {\n                return clause;\n            }\n\n            return {\n                to: uniqueNames.get(clause.to) ?? clause.to,\n                data: clause.data,\n                value: clause.value\n            };\n        });\n    }\n\n    /**\n     * Simulates the execution of a transaction.\n     * Allows to estimate the gas cost of a transaction without sending it, as well as to retrieve the return value(s) of the transaction.\n     *\n     * @param clauses - The clauses of the transaction to simulate.\n     * @param options - (Optional) The options for simulating the transaction.\n     * @returns A promise that resolves to an array of simulation results.\n     *          Each element of the array represents the result of simulating a clause.\n     * @throws {InvalidDataType}\n     */\n    public async simulateTransaction(\n        clauses: SimulateTransactionClause[],\n        options?: SimulateTransactionOptions\n    ): Promise<TransactionSimulationResult[]> {\n        const {\n            revision,\n            caller,\n            gasPrice,\n            gasPayer,\n            gas,\n            blockRef,\n            expiration,\n            provedWork\n        } = options ?? {};\n        if (\n            revision !== undefined &&\n            revision !== null &&\n            !Revision.isValid(revision)\n        ) {\n            throw new InvalidDataType(\n                'TransactionsModule.simulateTransaction()',\n                'Invalid revision given as input. Input must be a valid revision (i.e., a block number or block ID).',\n                { revision }\n            );\n        }\n\n        return (await this.blocksModule.httpClient.http(\n            HttpMethod.POST,\n            thorest.accounts.post.SIMULATE_TRANSACTION(revision),\n            {\n                query: buildQuery({ revision }),\n                body: {\n                    clauses: await this.resolveNamesInClauses(\n                        clauses.map((clause) => {\n                            return {\n                                to: clause.to,\n                                data: clause.data,\n                                value: BigInt(clause.value).toString()\n                            };\n                        })\n                    ),\n                    gas,\n                    gasPrice,\n                    caller,\n                    provedWork,\n                    gasPayer,\n                    expiration,\n                    blockRef\n                }\n            }\n        )) as TransactionSimulationResult[];\n    }\n\n    /**\n     * Decode the revert reason from the encoded revert reason into a transaction.\n     *\n     * @param encodedRevertReason - The encoded revert reason to decode.\n     * @param errorFragment - (Optional) The error fragment to use to decode the revert reason (For Solidity custom errors).\n     * @returns A promise that resolves to the decoded revert reason.\n     * Revert reason can be a string error or Panic(error_code)\n     */\n    public decodeRevertReason(\n        encodedRevertReason: string,\n        errorFragment?: string\n    ): string {\n        // Error selector\n        if (encodedRevertReason.startsWith(ERROR_SELECTOR))\n            return ABI.ofEncoded(\n                'string',\n                `0x${encodedRevertReason.slice(ERROR_SELECTOR.length)}`\n            ).getFirstDecodedValue();\n        // Panic selector\n        else if (encodedRevertReason.startsWith(PANIC_SELECTOR)) {\n            const decoded = ABI.ofEncoded(\n                'uint256',\n                `0x${encodedRevertReason.slice(PANIC_SELECTOR.length)}`\n            ).getFirstDecodedValue<string>();\n            return `Panic(0x${parseInt(decoded).toString(16).padStart(2, '0')})`;\n        }\n        // Solidity error, an error fragment is provided, so decode the revert reason using solidity error\n        else if (errorFragment !== undefined) {\n            const errorInterface = new Interface([\n                ErrorFragment.from(errorFragment)\n            ]);\n            return errorInterface\n                .decodeErrorResult(\n                    ErrorFragment.from(errorFragment),\n                    encodedRevertReason\n                )\n                .toArray()[0] as string;\n        }\n\n        // Unknown revert reason (we know ONLY that transaction is reverted)\n        return ``;\n    }\n\n    /**\n     * Get the revert reason of an existing transaction.\n     *\n     * @param transactionHash - The hash of the transaction to get the revert reason for.\n     * @param errorFragment - (Optional) The error fragment to use to decode the revert reason (For Solidity custom errors).\n     * @returns A promise that resolves to the revert reason of the transaction.\n     */\n    public async getRevertReason(\n        transactionHash: string,\n        errorFragment?: string\n    ): Promise<string | null> {\n        // 1 - Init Blocks and Debug modules\n        const blocksModule = this.blocksModule;\n        const debugModule = this.debugModule;\n\n        // 2 - Get the transaction details\n        const transaction = await this.getTransaction(transactionHash);\n\n        // 3 - Get the block details (to get the transaction index)\n        const block =\n            transaction !== null\n                ? ((await blocksModule.getBlockExpanded(\n                      transaction.meta.blockID\n                  )) as ExpandedBlockDetail)\n                : null;\n\n        // Block or transaction not found\n        if (block === null || transaction === null) return null;\n\n        // 4 - Get the transaction index into the block (we know the transaction is in the block)\n        const transactionIndex = getTransactionIndexIntoBlock(\n            blocksFormatter.formatToRPCStandard(block, ''),\n            transactionHash\n        );\n\n        // 5 - Get the error or panic reason. By iterating over the clauses of the transaction\n        for (\n            let transactionClauseIndex = 0;\n            transactionClauseIndex < transaction.clauses.length;\n            transactionClauseIndex++\n        ) {\n            // 5.1 - Debug the clause\n            const debuggedClause = (await debugModule.traceTransactionClause(\n                {\n                    target: {\n                        blockId: ThorId.of(block.id),\n                        transaction: transactionIndex,\n                        clauseIndex: transactionClauseIndex\n                    },\n                    // Optimized for top call\n                    config: {\n                        OnlyTopCall: true\n                    }\n                },\n                'call'\n            )) as CallNameReturnType;\n\n            // 5.2 - Error or panic present, so decode the revert reason\n            if (debuggedClause.output !== undefined) {\n                return this.decodeRevertReason(\n                    debuggedClause.output,\n                    errorFragment\n                );\n            }\n        }\n\n        // No revert reason found\n        return null;\n    }\n\n    /**\n     * Estimates the amount of gas required to execute a set of transaction clauses.\n     *\n     * @param {SimulateTransactionClause[]} clauses - An array of clauses to be simulated. Must contain at least one clause.\n     * @param {string} [caller] - The address initiating the transaction. Optional.\n     * @param {EstimateGasOptions} [options] - Additional options for the estimation, including gas padding.\n     * @return {Promise<EstimateGasResult>} - The estimated gas result, including total gas required, whether the transaction reverted, revert reasons, and any VM errors.\n     * @throws {InvalidDataType} - If clauses array is empty or if gas padding is not within the range (0, 1].\n     *\n     * @see {@link TransactionsModule#simulateTransaction}\n     */\n    public async estimateGas(\n        clauses: SimulateTransactionClause[],\n        caller?: string,\n        options?: EstimateGasOptions\n    ): Promise<EstimateGasResult> {\n        // Clauses must be an array of clauses with at least one clause\n        if (clauses.length <= 0) {\n            throw new InvalidDataType(\n                'GasModule.estimateGas()',\n                'Invalid clauses. Clauses must be an array of clauses with at least one clause.',\n                { clauses, caller, options }\n            );\n        }\n\n        // gasPadding must be a number between (0, 1]\n        if (\n            options?.gasPadding !== undefined &&\n            (options.gasPadding <= 0 || options.gasPadding > 1)\n        ) {\n            throw new InvalidDataType(\n                'GasModule.estimateGas()',\n                'Invalid gasPadding. gasPadding must be a number between (0, 1].',\n                { gasPadding: options?.gasPadding }\n            );\n        }\n\n        // Simulate the transaction to get the simulations of each clause\n        const simulations = await this.simulateTransaction(clauses, {\n            caller,\n            ...options\n        });\n\n        // If any of the clauses reverted, then the transaction reverted\n        const isReverted = simulations.some((simulation) => {\n            return simulation.reverted;\n        });\n\n        // The intrinsic gas of the transaction\n        const intrinsicGas = Number(Transaction.intrinsicGas(clauses).wei);\n\n        // totalSimulatedGas represents the summation of all clauses' gasUsed\n        const totalSimulatedGas = simulations.reduce((sum, simulation) => {\n            return sum + simulation.gasUsed;\n        }, 0);\n\n        // The total gas of the transaction\n        // If the transaction involves contract interaction, a constant 15000 gas is added to the total gas\n        const totalGas = Math.ceil(\n            (intrinsicGas +\n                (totalSimulatedGas !== 0 ? totalSimulatedGas + 15000 : 0)) *\n                (1 + (options?.gasPadding ?? 0))\n        ); // Add gasPadding if it is defined\n        return isReverted\n            ? {\n                  totalGas,\n                  reverted: true,\n                  revertReasons: simulations.map((simulation) => {\n                      /**\n                       * The decoded revert reason of the transaction.\n                       * Solidity may revert with Error(string) or Panic(uint256).\n                       *\n                       * @link see [Error handling: Assert, Require, Revert and Exceptions](https://docs.soliditylang.org/en/latest/control-structures.html#error-handling-assert-require-revert-and-exceptions)\n                       */\n                      return decodeRevertReason(simulation.data) ?? '';\n                  }),\n                  vmErrors: simulations.map((simulation) => {\n                      return simulation.vmError;\n                  })\n              }\n            : {\n                  totalGas,\n                  reverted: false,\n                  revertReasons: [],\n                  vmErrors: []\n              };\n    }\n\n    /**\n     * Executes a read-only call to a smart contract function, simulating the transaction to obtain the result.\n     *\n     * The method simulates a transaction using the provided parameters\n     * without submitting it to the blockchain, allowing read-only operations\n     * to be tested without incurring gas costs or modifying the blockchain state.\n     *\n     * @param {string} contractAddress - The address of the smart contract.\n     * @param {ABIFunction} functionAbi - The ABI definition of the smart contract function to be called.\n     * @param {unknown[]} functionData - The arguments to be passed to the smart contract function.\n     * @param {ContractCallOptions} [contractCallOptions] - Optional parameters for the contract call execution.\n     * @return {Promise<ContractCallResult>} The result of the contract call.\n     */\n    public async executeCall(\n        contractAddress: string,\n        functionAbi: ABIFunction,\n        functionData: unknown[],\n        contractCallOptions?: ContractCallOptions\n    ): Promise<ContractCallResult> {\n        // Simulate the transaction to get the result of the contract call\n        const response = await this.simulateTransaction(\n            [\n                {\n                    to: contractAddress,\n                    value: '0',\n                    data: functionAbi.encodeData(functionData).toString()\n                }\n            ],\n            contractCallOptions\n        );\n\n        return this.getContractCallResult(\n            response[0].data,\n            functionAbi,\n            response[0].reverted\n        );\n    }\n\n    /**\n     * Executes and simulates multiple read-only smart-contract clause calls,\n     * simulating the transaction to obtain the results.\n     *\n     * @param {ContractClause[]} clauses - The array of contract clauses to be executed.\n     * @param {SimulateTransactionOptions} [options] - Optional simulation transaction settings.\n     * @return {Promise<ContractCallResult[]>} - The decoded results of the contract calls.\n     */\n    public async executeMultipleClausesCall(\n        clauses: ContractClause[],\n        options?: SimulateTransactionOptions\n    ): Promise<ContractCallResult[]> {\n        // Simulate the transaction to get the result of the contract call\n        const response = await this.simulateTransaction(\n            clauses.map((clause) => clause.clause),\n            options\n        );\n        // Returning the decoded results both as plain and array.\n        return response.map((res, index) =>\n            this.getContractCallResult(\n                res.data,\n                clauses[index].functionAbi,\n                res.reverted\n            )\n        );\n    }\n\n    /**\n     * Executes a transaction with a smart-contract on the VeChain blockchain.\n     *\n     * @param {VeChainSigner} signer - The signer instance to sign the transaction.\n     * @param {string} contractAddress - The address of the smart contract.\n     * @param {ABIFunction} functionAbi - The ABI of the contract function to be called.\n     * @param {unknown[]} functionData - The input parameters for the contract function.\n     * @param {ContractTransactionOptions} [options] - Optional transaction parameters.\n     * @return {Promise<SendTransactionResult>} - A promise that resolves to the result of the transaction.\n     *\n     * @see {@link TransactionsModule.buildTransactionBody}\n     */\n    public async executeTransaction(\n        signer: VeChainSigner,\n        contractAddress: string,\n        functionAbi: ABIFunction,\n        functionData: unknown[],\n        options?: ContractTransactionOptions\n    ): Promise<SendTransactionResult> {\n        // Sign the transaction\n        const id = await signer.sendTransaction({\n            clauses: [\n                // Build a clause to interact with the contract function\n                Clause.callFunction(\n                    Address.of(contractAddress),\n                    functionAbi,\n                    functionData,\n                    VET.of(options?.value ?? 0, Units.wei)\n                )\n            ],\n            gas: options?.gas,\n            gasLimit: options?.gasLimit,\n            gasPrice: options?.gasPrice,\n            gasPriceCoef: options?.gasPriceCoef,\n            maxFeePerGas: options?.maxFeePerGas,\n            maxPriorityFeePerGas: options?.maxPriorityFeePerGas,\n            nonce: options?.nonce,\n            value: options?.value,\n            dependsOn: options?.dependsOn,\n            expiration: options?.expiration,\n            chainTag: options?.chainTag,\n            blockRef: options?.blockRef,\n            delegationUrl: options?.delegationUrl,\n            comment: options?.comment\n        });\n\n        return {\n            id,\n            wait: async () => await this.waitForTransaction(id)\n        };\n    }\n\n    /**\n     * Executes a transaction with multiple clauses on the VeChain blockchain.\n     *\n     * @param {ContractClause[]} clauses - Array of contract clauses to be included in the transaction.\n     * @param {VeChainSigner} signer - A VeChain signer instance used to sign and send the transaction.\n     * @param {ContractTransactionOptions} [options] - Optional parameters to customize the transaction.\n     * @return {Promise<SendTransactionResult>} The result of the transaction, including transaction ID and a wait function.\n     */\n    public async executeMultipleClausesTransaction(\n        clauses: ContractClause[],\n        signer: VeChainSigner,\n        options?: ContractTransactionOptions\n    ): Promise<SendTransactionResult> {\n        const id = await signer.sendTransaction({\n            clauses: clauses.map((clause) => clause.clause),\n            gas: options?.gas,\n            gasLimit: options?.gasLimit,\n            gasPrice: options?.gasPrice,\n            gasPriceCoef: options?.gasPriceCoef,\n            maxFeePerGas: options?.maxFeePerGas,\n            maxPriorityFeePerGas: options?.maxPriorityFeePerGas,\n            nonce: options?.nonce,\n            value: options?.value,\n            dependsOn: options?.dependsOn,\n            expiration: options?.expiration,\n            chainTag: options?.chainTag,\n            blockRef: options?.blockRef,\n            delegationUrl: options?.delegationUrl,\n            comment: options?.comment\n        });\n\n        return {\n            id,\n            wait: async () => await this.waitForTransaction(id)\n        };\n    }\n\n    /**\n     * Retrieves the base gas price from the blockchain parameters.\n     *\n     * This method sends a call to the blockchain parameters contract to fetch the current base gas price.\n     * The base gas price is the minimum gas price that can be used for a transaction.\n     * It is used to obtain the VTHO (energy) cost of a transaction.\n     * @link [Total Gas Price](https://docs.vechain.org/core-concepts/transactions/transaction-calculation#total-gas-price)\n     *\n     * @return {Promise<ContractCallResult>} A promise that resolves to the result of the contract call, containing the base gas price.\n     */\n    public async getLegacyBaseGasPrice(): Promise<ContractCallResult> {\n        return await this.executeCall(\n            BUILT_IN_CONTRACTS.PARAMS_ADDRESS,\n            ABIContract.ofAbi(BUILT_IN_CONTRACTS.PARAMS_ABI).getFunction('get'),\n            [dataUtils.encodeBytes32String('base-gas-price', 'left')]\n        );\n    }\n\n    /**\n     * Decode the result of a contract call from the result of a simulated transaction.\n     *\n     * @param {string} encodedData - The encoded data received from the contract call.\n     * @param {ABIFunction} functionAbi - The ABI function definition used for decoding the result.\n     * @param {boolean} reverted - Indicates if the contract call reverted.\n     * @return {ContractCallResult} An object containing the success status and the decoded result.\n     */\n    private getContractCallResult(\n        encodedData: string,\n        functionAbi: ABIFunction,\n        reverted: boolean\n    ): ContractCallResult {\n        if (reverted) {\n            const errorMessage = decodeRevertReason(encodedData) ?? '';\n            return {\n                success: false,\n                result: {\n                    errorMessage\n                }\n            };\n        }\n\n        // Returning the decoded result both as plain and array.\n        const encodedResult = Hex.of(encodedData);\n        const plain = functionAbi.decodeResult(encodedResult);\n        const array = functionAbi.decodeOutputAsArray(encodedResult);\n        return {\n            success: true,\n            result: {\n                plain,\n                array\n            }\n        };\n    }\n}\n\nexport { TransactionsModule };\n","import { Hex, HexUInt, type Transaction } from '@vechain/sdk-core';\nimport { NotDelegatedTransaction } from '@vechain/sdk-errors';\nimport {\n    type GetDelegationSignatureResult,\n    type SignTransactionOptions\n} from '../types';\nimport { type HttpClient, HttpMethod } from '../../../http';\n\n/**\n * Retrieves the signature of a delegation transaction from a gasPayer given the endpoint\n * from which to retrieve the signature.\n *\n * @see [Simple Gas Payer Standard](https://github.com/vechain/VIPs/blob/master/vips/VIP-201.md)\n *\n * @param tx - The transaction to delegate.\n * @param gasPayerServiceUrl - The URL of the endpoint of the gasPayer service.\n * @param originAddress - The address of the origin account.\n * @param httpClient - The HTTP client instance used for making HTTP requests.\n * @returns A promise that resolves to the signature of the delegation transaction.\n * @throws {NotDelegatedTransaction}\n */\nconst _getDelegationSignature = async (\n    tx: Transaction,\n    gasPayerServiceUrl: string,\n    originAddress: string,\n    httpClient: HttpClient\n): Promise<Uint8Array> => {\n    const rawTx = Hex.of(tx.encoded).toString();\n\n    /**\n     * The request body for the delegation transaction.\n     *\n     * @see [Obtaining Gas Payer Signature](https://github.com/vechain/VIPs/blob/master/vips/VIP-201.md#obtaining-gas-payer-signature)\n     */\n    const sponsorRequestBody = {\n        origin: originAddress,\n        raw: rawTx\n    };\n\n    try {\n        const response = (await httpClient.http(\n            HttpMethod.POST,\n            gasPayerServiceUrl,\n            {\n                body: sponsorRequestBody,\n                headers: { 'Content-Type': 'application/json' }\n            }\n        )) as GetDelegationSignatureResult;\n\n        return HexUInt.of(response.signature.slice(2)).bytes;\n    } catch (error) {\n        throw new NotDelegatedTransaction(\n            '_getDelegationSignature()',\n            'Delegation failed: Cannot get signature from gasPayerUrl.',\n            {\n                gasPayerUrl: gasPayerServiceUrl\n            },\n            error\n        );\n    }\n};\n\n/**\n * Provide a set of utils for the delegation type.\n * It is a mutual exclusion between gasPayerPrivateKey and gasPayerServiceUrl. (@see SignTransactionOptions)\n *\n * The aim of this handler is to:\n *   - Understand the kind of delegation and the delegation info\n *   - Provide a method to get the delegation signature\n *\n * @param gasPayer - The gasPayer options.\n */\nconst DelegationHandler = (\n    gasPayer?: SignTransactionOptions | null\n): {\n    isDelegated: () => boolean;\n    gasPayerOrUndefined: () => SignTransactionOptions | undefined;\n    gasPayerOrNull: () => SignTransactionOptions | null;\n    getDelegationSignatureUsingUrl: (\n        tx: Transaction,\n        originAddress: string,\n        httpClient: HttpClient\n    ) => Promise<Uint8Array>;\n} => {\n    // Check if gasPayer is undefined (null or undefined)\n    const gasPayerIsUndefined = gasPayer === undefined || gasPayer === null;\n\n    // Check if is delegated by url\n    const isDelegatedWithUrl =\n        !gasPayerIsUndefined && gasPayer?.gasPayerServiceUrl !== undefined;\n\n    // Check if is delegated by private key\n    const isDelegatedWithPrivateKey =\n        !gasPayerIsUndefined && gasPayer?.gasPayerPrivateKey !== undefined;\n\n    return {\n        /**\n         * Check if the transaction is delegated.\n         *\n         * @returns true if the transaction is delegated, false otherwise.\n         */\n        isDelegated: (): boolean =>\n            isDelegatedWithUrl || isDelegatedWithPrivateKey,\n\n        /**\n         * Get the gasPayer options or undefined.\n         * (if gasPayer is undefined or null).\n         *\n         * @returns The gasPayer options or undefined.\n         */\n        gasPayerOrUndefined: (): SignTransactionOptions | undefined =>\n            gasPayerIsUndefined ? undefined : gasPayer,\n\n        /**\n         * Get the gasPayer options or null.\n         * (if gasPayer is undefined or null).\n         *\n         * @returns The gasPayer options or null.\n         */\n        gasPayerOrNull: (): SignTransactionOptions | null =>\n            gasPayerIsUndefined ? null : gasPayer,\n\n        /**\n         * Retrieves the signature of a delegation transaction from a gasPayer given the endpoint\n         * from which to retrieve the signature.\n         *\n         * @see [Simple Gas Payer Standard](https://github.com/vechain/VIPs/blob/master/vips/VIP-201.md)\n         *\n         * @param tx - The transaction to delegate.\n         * @param originAddress - The address of the origin account.\n         * @param httpClient - The HTTP client instance used for making HTTP requests.\n         * @returns A promise that resolves to the signature of the delegation transaction.\n         * @throws {NotDelegatedTransaction}\n         */\n        getDelegationSignatureUsingUrl: async (\n            tx: Transaction,\n            originAddress: string,\n            httpClient: HttpClient\n        ): Promise<Uint8Array> => {\n            // Cannot be delegated by private key\n            if (!isDelegatedWithUrl) {\n                throw new NotDelegatedTransaction(\n                    'DelegationHandler.getDelegationSignatureUsingUrl()',\n                    'Delegation with url failed: gasPayerServiceUrl is not defined.',\n                    undefined\n                );\n            }\n\n            return await _getDelegationSignature(\n                tx,\n                gasPayer?.gasPayerServiceUrl,\n                originAddress,\n                httpClient\n            );\n        }\n    };\n};\n\nexport { DelegationHandler };\n","import { InvalidDataType } from '@vechain/sdk-errors';\nimport { buildQuery, thorest } from '../../utils';\nimport { type BlockDetail } from '../blocks/types';\nimport { Revision } from '@vechain/sdk-core';\nimport { type HttpClient, HttpMethod } from '../../http';\n\n// In-memory cache for fork detection results\ninterface CacheEntry {\n    result: boolean;\n    timestamp: number;\n}\nconst galacticaForkCache = new Map<string, CacheEntry>();\n// Cache TTL in milliseconds for negative results (5 minutes)\nconst NEGATIVE_CACHE_TTL = 5 * 60 * 1000;\n// Track if we've found the Galactica fork on any revision\nlet galacticaForkDetected = false;\n\nclass ForkDetector {\n    constructor(private readonly httpClient: HttpClient) {}\n\n    /**\n     * Checks if the given block is Galactica-forked by inspecting the block details.\n     *\n     * Criteria:\n     * - baseFeePerGas is defined (indicating a possible Galactica fork).\n     *\n     * @param revision Block number or ID (e.g., 'best', 'finalized', or numeric).\n     * @returns `true` if Galactica-forked, otherwise `false`.\n     * @throws {InvalidDataType} If the revision is invalid.\n     */\n    public async isGalacticaForked(\n        revision?: string | number\n    ): Promise<boolean> {\n        // If we've already detected Galactica fork on any revision, return true immediately\n        // This is because once a hard fork happens, it's permanent\n        if (galacticaForkDetected) {\n            return true;\n        }\n\n        if (revision === undefined) {\n            revision = 'best';\n        }\n        if (!Revision.isValid(revision)) {\n            throw new InvalidDataType(\n                'GalacticaForkDetector.isGalacticaForked()',\n                'Invalid revision. Must be a valid block number or ID.',\n                { revision }\n            );\n        }\n\n        const revisionKey = String(revision);\n\n        // Check cache first\n        const cachedResult = galacticaForkCache.get(revisionKey);\n        const now = Date.now();\n\n        // If we have a cached positive result or a non-expired negative result\n        if (cachedResult !== undefined) {\n            // Positive results are kept indefinitely\n            if (cachedResult.result) {\n                galacticaForkDetected = true;\n                return true;\n            }\n\n            // Negative results expire after TTL\n            if (now - cachedResult.timestamp < NEGATIVE_CACHE_TTL) {\n                return false;\n            }\n        }\n\n        // If cache miss or expired negative result, make the request\n        const block = (await this.httpClient.http(\n            HttpMethod.GET,\n            thorest.blocks.get.BLOCK_DETAIL(revision),\n            {\n                query: buildQuery({ expanded: true })\n            }\n        )) as BlockDetail | null;\n\n        if (block === null) {\n            // Cache the negative result with TTL\n            galacticaForkCache.set(revisionKey, {\n                result: false,\n                timestamp: now\n            });\n            return false;\n        }\n\n        const result = block.baseFeePerGas !== undefined;\n\n        // Cache the result\n        galacticaForkCache.set(revisionKey, { result, timestamp: now });\n\n        // If fork is detected, set the global flag\n        if (result) {\n            galacticaForkDetected = true;\n        }\n\n        return result;\n    }\n\n    /**\n     * Detects if the current network is on the Galactica fork by checking the best block.\n     * This is an alias for isGalacticaForked('best').\n     *\n     * @param {string | number} revision - Block number or ID (e.g., 'best', 'finalized', or numeric)\n     * @returns {Promise<boolean>} A promise that resolves to true if Galactica fork is detected, false otherwise.\n     */\n    public async detectGalactica(\n        revision: string | number = 'best'\n    ): Promise<boolean> {\n        return await this.isGalacticaForked(revision);\n    }\n\n    /**\n     * Clears the Galactica fork detection cache.\n     * This is mainly useful for testing purposes.\n     */\n    public clearCache(): void {\n        galacticaForkCache.clear();\n        galacticaForkDetected = false;\n    }\n}\n\nexport { ForkDetector };\n","import {\n    AccountsModule,\n    BlocksModule,\n    type BlocksModuleOptions,\n    ContractsModule,\n    DebugModule,\n    GasModule,\n    LogsModule,\n    NodesModule,\n    TransactionsModule,\n    ForkDetector\n} from '.';\nimport { SimpleHttpClient, type HttpClient } from '../http';\n\n/**\n * The `ThorClient` class serves as an interface to interact with the VeChainThor blockchain.\n * It provides various methods.\n */\nclass ThorClient {\n    /**\n     * The `AccountsModule` instance\n     */\n    public readonly accounts: AccountsModule;\n\n    /**\n     * The `NodesModule` instance\n     */\n    public readonly nodes: NodesModule;\n\n    /**\n     * The `BlocksModule` instance\n     */\n    public readonly blocks: BlocksModule;\n\n    /**\n     * The `LogsModule` instance used for interacting with log-related endpoints.\n     */\n    public readonly logs: LogsModule;\n\n    /*\n     * The `TransactionsModule` instance\n     */\n    public readonly transactions: TransactionsModule;\n\n    /**\n     * The 'ContractClient' instance\n     */\n    public readonly contracts: ContractsModule;\n\n    /**\n     * The 'GalacticaForkDetector' instance\n     */\n    public readonly forkDetector: ForkDetector;\n\n    /**\n     * The `GasModule` instance\n     */\n    public readonly gas: GasModule;\n\n    /**\n     * The `DebugModule` instance\n     */\n    public readonly debug: DebugModule;\n\n    /**\n     * Constructs a new `ThorClient` instance with a given HTTP client.\n     *\n     * @param httpClient - The HTTP client instance used for making network requests.\n     * @param options - (Optional) Other optional parameters for polling and error handling.\n     */\n    constructor(\n        readonly httpClient: HttpClient,\n        options?: BlocksModuleOptions\n    ) {\n        this.accounts = new AccountsModule(httpClient);\n        this.debug = new DebugModule(httpClient);\n        this.blocks = new BlocksModule(httpClient, options);\n        this.logs = new LogsModule(this.blocks);\n        this.nodes = new NodesModule(this.blocks);\n        this.gas = new GasModule(this.httpClient);\n        this.forkDetector = new ForkDetector(this.httpClient);\n        this.transactions = new TransactionsModule(\n            this.blocks,\n            this.debug,\n            this.logs,\n            this.gas,\n            this.forkDetector\n        );\n        this.gas.setTransactionsModule(this.transactions); // gas module requires transaction module\n        this.contracts = new ContractsModule(this.transactions);\n    }\n\n    /**\n     * Creates a new `ThorClient` instance from a given URL.\n     *\n     * @param {string} networkUrl - The URL of the network to connect to.\n     * @param {BlocksModuleOptions} [options] - Optional configuration settings for the Blocks module.\n     * @return {ThorClient} A ThorClient instance connected to the specified network URL.\n     */\n    public static at(\n        networkUrl: string,\n        options?: BlocksModuleOptions\n    ): ThorClient {\n        return new ThorClient(new SimpleHttpClient(networkUrl), options);\n    }\n\n    /**\n     * Destroys the `ThorClient` instance by stopping the event polling\n     * and any other cleanup.\n     */\n    public destroy(): void {\n        this.blocks.destroy();\n    }\n\n    /**\n     * Creates a ThorClient instance from a network URL.\n     *\n     * @param {string} networkUrl - The URL of the network to connect to.\n     * @param {BlocksModuleOptions} [options] - Optional configuration settings for the Blocks module.\n     * @return {ThorClient} A ThorClient instance connected to the specified network URL.\n     *\n     * @deprecated Use {@link ThorClient.at} instead.\n     */\n    public static fromUrl(\n        networkUrl: string,\n        options?: BlocksModuleOptions\n    ): ThorClient {\n        return ThorClient.at(networkUrl, options);\n    }\n}\n\nexport { ThorClient };\n","import { concatBytes } from '@noble/curves/abstract/utils';\nimport {\n    Address,\n    Clause,\n    Hex,\n    HexUInt,\n    Keccak256,\n    Txt,\n    type TransactionBody,\n    type TransactionClause\n} from '@vechain/sdk-core';\nimport {\n    InvalidDataType,\n    JSONRPCInvalidParams,\n    SignerMethodError\n} from '@vechain/sdk-errors';\nimport { hashTypedData } from 'viem';\nimport { RPC_METHODS } from '../../../provider/utils/const/rpc-mapper/rpc-methods';\nimport { type TransactionSimulationResult } from '../../../thor-client';\nimport { vnsUtils } from '../../../utils';\nimport {\n    type AvailableVeChainProviders,\n    type TransactionRequestInput,\n    type TypedDataDomain,\n    type TypedDataParameter,\n    type VeChainSigner\n} from '../types';\n\n/**\n * Abstract VeChain signer.\n * This abstract class avoids people every time implementing standard signer\n * methods.\n * By implementing this abstract class, it will be easier to create new signers\n */\nabstract class VeChainAbstractSigner implements VeChainSigner {\n    protected readonly MESSAGE_PREFIX = Txt.of('\\x19Ethereum Signed Message:\\n')\n        .bytes;\n\n    /**\n     * The provider attached to this Signer (if any).\n     */\n    provider?: AvailableVeChainProviders;\n\n    /**\n     * Create a new VeChainPrivateKeySigner.\n     * A signer can be initialized using a private key.\n     *\n     * @param provider - The provider to connect to\n     */\n    protected constructor(provider?: AvailableVeChainProviders) {\n        // Store provider and gasPayer\n        this.provider = provider;\n    }\n\n    /**\n     *  Returns a new instance of this Signer connected to //provider// or detached\n     *  from any Provider if undefined.\n     *\n     * @param provider - The provider to connect to\n     * @returns a new instance of this Signer connected to //provider// or detached\n     */\n    abstract connect(provider: AvailableVeChainProviders): this;\n\n    /**\n     * Get the address of the Signer.\n     *\n     * @returns the address of the signer\n     */\n    abstract getAddress(): Promise<string>;\n\n    /**\n     *  Prepares a {@link TransactionRequestInput} for calling:\n     *  - resolves ``to`` and ``from`` addresses\n     *  - if ``from`` is specified, check that it matches this Signer\n     *\n     *  @note: Here the base support of multi-clause transaction is added.\n     *  So, if clauses are provided in the transaction, it will be used as it is.\n     *  Otherwise, standard transaction will be prepared.\n     *\n     *  @param transactionToPopulate - The call to prepare\n     *  @returns the prepared call transaction\n     * @throws {InvalidDataType}\n     */\n    async populateCall(\n        transactionToPopulate: TransactionRequestInput\n    ): Promise<TransactionRequestInput> {\n        // 1 - Add from field (if not provided)\n        if (\n            transactionToPopulate.from === undefined ||\n            transactionToPopulate.from === null\n        )\n            transactionToPopulate.from = Address.checksum(\n                HexUInt.of(await this.getAddress())\n            );\n        // Throw an error if the from address does not match the signer address\n        // @note: this because we cannot sign a transaction with a different address\n        else if (\n            Address.checksum(HexUInt.of(transactionToPopulate.from)) !==\n            Address.checksum(HexUInt.of(await this.getAddress()))\n        ) {\n            throw new InvalidDataType(\n                'VeChainAbstractSigner.populateCall()',\n                'From address does not match the signer address.',\n                {\n                    signerAddress: Address.checksum(\n                        HexUInt.of(await this.getAddress())\n                    ),\n                    fromAddress: Address.checksum(\n                        HexUInt.of(transactionToPopulate.from)\n                    )\n                }\n            );\n        }\n\n        // 2 - Set to field\n        if (transactionToPopulate.to === undefined)\n            transactionToPopulate.to = null;\n\n        // 3 - Use directly clauses, if they are provided\n        if (\n            transactionToPopulate.clauses !== undefined &&\n            transactionToPopulate.clauses.length > 0\n        ) {\n            // 2.1 - Set to, value and data fields to be consistent\n            transactionToPopulate.to = transactionToPopulate.clauses[0].to;\n            transactionToPopulate.value =\n                transactionToPopulate.clauses[0].value;\n            transactionToPopulate.data = transactionToPopulate.clauses[0].data;\n        }\n\n        // Return the transaction\n        return transactionToPopulate;\n    }\n\n    /**\n     *  Prepares a {@link TransactionRequestInput} for sending to the network by\n     *  populating any missing properties:\n     *  - resolves ``to`` and ``from`` addresses\n     *  - if ``from`` is specified , check that it matches this Signer\n     *  - populates ``nonce`` via ``signer.getNonce(\"pending\")``\n     *  - populates gas parameters via ``signer.estimateGas(tx)``\n     *  - ... and other necessary properties\n     *\n     *  @param transactionToPopulate - The call to prepare\n     *  @returns the prepared transaction\n     *  @throws {JSONRPCInvalidParams}\n     */\n    async populateTransaction(\n        transactionToPopulate: TransactionRequestInput\n    ): Promise<TransactionBody> {\n        // 1 - Get the thor client\n        if ((this.provider as AvailableVeChainProviders) === undefined) {\n            throw new JSONRPCInvalidParams(\n                'VechainAbstractSigner.populateTransaction()',\n                'Thor client not found into the signer. Please attach a Provider with a thor client to your signer instance.',\n                { provider: this.provider }\n            );\n        }\n\n        const thorClient = (this.provider as AvailableVeChainProviders)\n            .thorClient;\n\n        // 2 - Populate the call, to get proper 'from' and 'to' address (compatible with multi-clause transactions)\n        const populatedTransaction = await this.populateCall(\n            transactionToPopulate\n        );\n\n        // 3 - Estimate gas\n        const totalGasResult =\n            transactionToPopulate.gas !== undefined\n                ? Number(transactionToPopulate.gas)\n                : await this.estimateGas(transactionToPopulate);\n\n        // 4 - Build the transaction body\n        return await thorClient.transactions.buildTransactionBody(\n            populatedTransaction.clauses ??\n                this._buildClauses(populatedTransaction),\n            totalGasResult,\n            {\n                isDelegated: this.provider?.enableDelegation as boolean,\n                nonce:\n                    populatedTransaction.nonce ??\n                    (await this.getNonce('pending')),\n                blockRef: populatedTransaction.blockRef ?? undefined,\n                chainTag: populatedTransaction.chainTag ?? undefined,\n                dependsOn: populatedTransaction.dependsOn ?? undefined,\n                expiration: populatedTransaction.expiration,\n                gasPriceCoef: populatedTransaction.gasPriceCoef ?? undefined,\n                maxPriorityFeePerGas:\n                    populatedTransaction.maxPriorityFeePerGas ?? undefined,\n                maxFeePerGas: populatedTransaction.maxFeePerGas ?? undefined\n            }\n        );\n    }\n\n    /**\n     * Estimates the gas required to execute //tx// on the Blockchain. This\n     * will be the expected amount a transaction will need\n     * to successfully run all the necessary computations and store the changed state\n     * that the transaction intends.\n     *\n     * @param transactionToEstimate - The transaction to estimate gas for\n     * @returns the total estimated gas required\n     * @throws {JSONRPCInvalidParams}\n     */\n    async estimateGas(\n        transactionToEstimate: TransactionRequestInput\n    ): Promise<number> {\n        // 1 - Get the thor client\n        if ((this.provider as AvailableVeChainProviders) === undefined) {\n            throw new JSONRPCInvalidParams(\n                'VechainAbstractSigner.estimateGas()',\n                'Thor client not found into the signer. Please attach a Provider with a thor client to your signer instance.',\n                { provider: this.provider }\n            );\n        }\n\n        const thorClient = (this.provider as AvailableVeChainProviders)\n            .thorClient;\n\n        // 2 - Populate the call, to get proper from and to address (compatible with multi-clause transactions)\n        const populatedTransaction = await this.populateCall(\n            transactionToEstimate\n        );\n\n        // 3 - Estimate gas\n        const gasEstimation = await thorClient.transactions.estimateGas(\n            populatedTransaction.clauses ??\n                this._buildClauses(populatedTransaction),\n            populatedTransaction.from as string\n        );\n\n        // Return the gas estimation\n        return gasEstimation.totalGas;\n    }\n\n    /**\n     * Evaluates the //tx// by running it against the current Blockchain state. This\n     * cannot change state and has no cost, as it is effectively simulating\n     * execution.\n     *\n     * This can be used to have the Blockchain perform computations based on its state\n     * (e.g. running a Contract's getters) or to simulate the effect of a transaction\n     * before actually performing an operation.\n     *\n     * @param transactionToEvaluate - The transaction to evaluate\n     * @param revision - The block number or block ID of which the transaction simulation is based on\n     * @returns the result of the evaluation\n     * @throws {JSONRPCInvalidParams}\n     */\n    async call(\n        transactionToEvaluate: TransactionRequestInput,\n        revision?: string\n    ): Promise<string> {\n        // 1 - Get the thor client\n        if ((this.provider as AvailableVeChainProviders) === undefined) {\n            throw new JSONRPCInvalidParams(\n                'VechainAbstractSigner.call()',\n                'Thor client not found into the signer. Please attach a Provider with a thor client to your signer instance.',\n                { provider: this.provider }\n            );\n        }\n        const thorClient = (this.provider as AvailableVeChainProviders)\n            .thorClient;\n\n        // 2 - Populate the call, to get proper from and to address (compatible with multi-clause transactions)\n        const populatedTransaction = await this.populateCall(\n            transactionToEvaluate\n        );\n\n        // 3 - Evaluate the transaction\n        const simulation: TransactionSimulationResult[] =\n            await thorClient.transactions.simulateTransaction(\n                populatedTransaction.clauses ??\n                    this._buildClauses(populatedTransaction),\n                {\n                    revision: revision ?? undefined,\n                    gas: (populatedTransaction.gas as number) ?? undefined,\n                    gasPrice: populatedTransaction.gasPrice ?? undefined,\n                    caller: populatedTransaction.from as string,\n                    provedWork: populatedTransaction.provedWork ?? undefined,\n                    gasPayer: populatedTransaction.gasPayer ?? undefined,\n                    expiration: populatedTransaction.expiration ?? undefined,\n                    blockRef: populatedTransaction.blockRef ?? undefined\n                }\n            );\n\n        // 4 - Return the result of the evaluation\n        return simulation[0].data;\n    }\n\n    /**\n     *  Gets the next nonce required for this Signer to send a transaction.\n     *\n     *  @param blockTag - The blocktag to base the transaction count on, keep in mind\n     *         many nodes do not honour this value and silently ignore it [default: ``\"latest\"``]\n     *\n     *  @NOTE: This method generates a random number as nonce. It is because the nonce in VeChain is a 6-byte number.\n     */\n    async getNonce(blockTag?: string): Promise<string> {\n        // If provider is available, get the nonce from the provider using eth_getTransactionCount\n        if (this.provider !== undefined) {\n            return (await this.provider.request({\n                method: RPC_METHODS.eth_getTransactionCount,\n                params: [await this.getAddress(), blockTag]\n            })) as string;\n        }\n\n        // Otherwise return a random number\n        return Hex.random(6).toString();\n    }\n\n    /**\n     * Signs %%transactionToSign%%, returning the fully signed transaction. This does not\n     * populate any additional properties with eth_getTransactionCount: RPC_METHODS, p0: (string | undefined)[], args: EIP1193RequestArguments* @param transactionToSign - The transaction to sign\n     * @returns The fully signed transaction\n     */\n    abstract signTransaction(\n        transactionToSign: TransactionRequestInput\n    ): Promise<string>;\n\n    /**\n     *  Sends %%transactionToSend%% to the Network. The ``signer.populateTransaction(transactionToSend)``\n     *  is called first to ensure all necessary properties for the\n     *  transaction to be valid have been populated first.\n     *\n     *  @param transactionToSend - The transaction to send\n     *  @returns The transaction response\n     */\n    abstract sendTransaction(\n        transactionToSend: TransactionRequestInput\n    ): Promise<string>;\n\n    /**\n     * Signs a bytes payload returning the VeChain signature in hexadecimal format.\n     * @param {Uint8Array} payload in bytes to sign.\n     * @returns {string} The VeChain signature in hexadecimal format.\n     */\n    abstract signPayload(payload: Uint8Array): Promise<string>;\n\n    /**\n     * Signs an [[link-eip-191]] prefixed a personal message.\n     *\n     * @param {string|Uint8Array} message - The message to be signed.\n     *                                      If the %%message%% is a string, it is signed as UTF-8 encoded bytes.\n     *                                      It is **not** interpreted as a [[BytesLike]];\n     *                                      so the string ``\"0x1234\"`` is signed as six characters, **not** two bytes.\n     * @return {Promise<string>} - A Promise that resolves to the signature as a string.\n     */\n    public async signMessage(message: string | Uint8Array): Promise<string> {\n        try {\n            const payload =\n                typeof message === 'string' ? Txt.of(message).bytes : message;\n            const payloadHashed = Keccak256.of(\n                concatBytes(\n                    this.MESSAGE_PREFIX,\n                    Txt.of(payload.length).bytes,\n                    payload\n                )\n            ).bytes;\n            return await this.signPayload(payloadHashed);\n        } catch (error) {\n            throw new SignerMethodError(\n                'VeChainAbstractSigner.signMessage',\n                'The message could not be signed.',\n                { message },\n                error\n            );\n        }\n    }\n\n    /**\n     * Deduces the primary from the types if not given.\n     * The primary type will be the only type that is not used in any other type.\n     * @param {Record<string, TypedDataParameter[]>} types - The types used for EIP712.\n     * @returns {string} The primary type.\n     */\n    private deducePrimaryType(\n        types: Record<string, TypedDataParameter[]>\n    ): string {\n        const parents = new Map<string, string[]>();\n\n        // Initialize parents map\n        Object.keys(types).forEach((type) => {\n            parents.set(type, []);\n        });\n\n        // Populate parents map\n        for (const name in types) {\n            for (const field of types[name]) {\n                // In case the type is an array, we get its prefix\n                const type = field.type.split('[')[0];\n                if (parents.has(type)) {\n                    parents.get(type)?.push(name);\n                }\n            }\n        }\n\n        // Find primary types\n        const primaryTypes = Array.from(parents.keys()).filter(\n            (n) => parents.get(n)?.length === 0\n        );\n\n        if (primaryTypes.length !== 1) {\n            throw new SignerMethodError(\n                'VeChainAbstractSigner.deducePrimaryType',\n                'Ambiguous primary types or unused types.',\n                { primaryTypes: primaryTypes.join(', ') }\n            );\n        }\n\n        return primaryTypes[0];\n    }\n\n    /**\n     * Signs the [[link-eip-712]] typed data.\n     *\n     * @param {TypedDataDomain} domain - The domain parameters used for signing.\n     * @param {Record<string, TypedDataParameter[]>} types - The types used for signing.\n     * @param {Record<string, unknown>} message - The message data to be signed.\n     * @param {string} primaryType - The primary type used for signing.\n     *\n     * @return {Promise<string>} - A promise that resolves with the signature string.\n     */\n    public async signTypedData(\n        domain: TypedDataDomain,\n        types: Record<string, TypedDataParameter[]>,\n        message: Record<string, unknown>,\n        primaryType?: string\n    ): Promise<string> {\n        try {\n            const payload = Hex.of(\n                hashTypedData({\n                    domain,\n                    types,\n                    primaryType: primaryType ?? this.deducePrimaryType(types), // Deduce the primary type if not provided\n                    message\n                })\n            ).bytes;\n\n            return await this.signPayload(payload);\n        } catch (error) {\n            throw new SignerMethodError(\n                'VeChainAbstractSigner.signTypedData',\n                'The typed data could not be signed.',\n                { domain, types, message, primaryType },\n                error\n            );\n        }\n    }\n\n    /**\n     * Use vet.domains to resolve name to address\n     * @param vnsName - The name to resolve\n     * @returns the address for a name or null\n     */\n    async resolveName(vnsName: string): Promise<null | string> {\n        if (this.provider === undefined) {\n            return null;\n        }\n\n        return await vnsUtils.resolveName(this.provider.thorClient, vnsName);\n    }\n\n    /**\n     * Build the transaction clauses\n     * form a transaction given as input\n     *\n     * @param transaction - The transaction to sign\n     * @returns The transaction clauses\n     */\n    protected _buildClauses(\n        transaction: TransactionRequestInput\n    ): TransactionClause[] {\n        return transaction.to !== undefined && transaction.to !== null\n            ? // Normal transaction\n              [\n                  {\n                      to: transaction.to,\n                      data: transaction.data ?? '0x',\n                      value: transaction.value ?? '0x0'\n                  } satisfies TransactionClause\n              ]\n            : // If 'to' address is not provided, it will be assumed that the transaction is a contract creation transaction.\n              [\n                  Clause.deployContract(\n                      HexUInt.of(transaction.data ?? 0),\n                      undefined,\n                      {\n                          value:\n                              transaction.value === undefined\n                                  ? transaction.value\n                                  : HexUInt.of(transaction.value).toString(\n                                        true\n                                    ),\n                          comment: transaction.comment\n                      }\n                  ) as TransactionClause\n              ];\n    }\n}\n\nexport { VeChainAbstractSigner };\n","import {\n    Address,\n    Hex,\n    HexUInt,\n    Secp256k1,\n    Transaction,\n    type TransactionBody\n} from '@vechain/sdk-core';\nimport {\n    InvalidSecp256k1PrivateKey,\n    JSONRPCInvalidParams\n} from '@vechain/sdk-errors';\nimport { RPC_METHODS } from '../../../provider/utils/const/rpc-mapper/rpc-methods';\nimport {\n    DelegationHandler,\n    type SignTransactionOptions,\n    type ThorClient\n} from '../../../thor-client';\nimport {\n    type AvailableVeChainProviders,\n    type TransactionRequestInput\n} from '../types';\nimport { VeChainAbstractSigner } from '../vechain-abstract-signer/vechain-abstract-signer';\n\n/**\n * Basic VeChain signer with the private key.\n * This signer can be initialized using a private key.\n */\nclass VeChainPrivateKeySigner extends VeChainAbstractSigner {\n    /**\n     * Create a new VeChainPrivateKeySigner.\n     * A signer can be initialized using a private key.\n     *\n     * @param privateKey - The private key of the signer\n     * @param provider - The provider to connect to\n     */\n    constructor(\n        private readonly privateKey: Uint8Array,\n        provider?: AvailableVeChainProviders\n    ) {\n        // Assert if the transaction can be signed\n        if (!Secp256k1.isValidPrivateKey(privateKey)) {\n            throw new InvalidSecp256k1PrivateKey(\n                `VeChainPrivateKeySigner.constructor()`,\n                \"Invalid private key used to sign initialize the signer. Ensure it's a valid Secp256k1 private key.\",\n                undefined\n            );\n        }\n\n        // Call the parent constructor\n        super(provider);\n    }\n\n    /**\n     *  Returns a new instance of this Signer connected to //provider// or detached\n     *  from any Provider if null.\n     *\n     * @param provider - The provider to connect to\n     * @returns a new instance of this Signer connected to //provider// or detached\n     */\n    connect(provider: AvailableVeChainProviders): this {\n        return new VeChainPrivateKeySigner(this.privateKey, provider) as this;\n    }\n\n    /**\n     * Get the address checksum of the Signer.\n     *\n     * @returns the address checksum of the signer\n     */\n    async getAddress(): Promise<string> {\n        return Address.checksum(\n            HexUInt.of(\n                await Promise.resolve(\n                    Address.ofPrivateKey(this.privateKey).toString()\n                )\n            )\n        );\n    }\n\n    /**\n     * Signs %%transactionToSign%%, returning the fully signed transaction. This does not\n     * populate any additional properties with eth_getTransactionCount: RPC_METHODS, p0: (string | undefined)[], args: EIP1193RequestArguments* @param transactionToSign - The transaction to sign\n     * @returns The fully signed transaction\n     */\n    async signTransaction(\n        transactionToSign: TransactionRequestInput\n    ): Promise<string> {\n        // Check the provider (needed to sign the transaction)\n        if (this.provider === undefined) {\n            throw new JSONRPCInvalidParams(\n                'VeChainPrivateKeySigner.signTransaction()',\n                'Thor provider is not found into the signer. Please attach a Provider to your signer instance.',\n                { transactionToSign }\n            );\n        }\n\n        let gasPayer = DelegationHandler(\n            await this.provider.wallet?.getGasPayer()\n        ).gasPayerOrNull();\n\n        // Override the gasPayer if the transaction has a delegation URL\n        if (transactionToSign.delegationUrl !== undefined) {\n            gasPayer = {\n                gasPayerServiceUrl: transactionToSign.delegationUrl\n            };\n        }\n\n        // Sign the transaction\n        return await this._signFlow(\n            transactionToSign,\n            gasPayer,\n            this.provider.thorClient\n        );\n    }\n\n    /**\n     * Sends a transaction to the blockchain.\n     *\n     * @param {TransactionRequestInput} transactionToSend - The transaction object to be sent.\n     * This includes all the necessary details such as `to`, `value`, `data`, `gasLimit`, etc.\n     * @return {Promise<string>} A promise that resolves to the transaction hash as a string\n     * once the transaction is successfully sent.\n     * @throws {JSONRPCInvalidParams} Throws an error if the provider is not attached\n     * to the signer, indicating the signer's inability to send the transaction.\n     */\n    async sendTransaction(\n        transactionToSend: TransactionRequestInput\n    ): Promise<string> {\n        // 1 - Get the provider (needed to send the raw transaction)\n        if (this.provider === undefined) {\n            throw new JSONRPCInvalidParams(\n                'VeChainPrivateKeySigner.sendTransaction()',\n                'Thor provider is not found into the signer. Please attach a Provider to your signer instance.',\n                { transactionToSend }\n            );\n        }\n\n        const provider = this.provider;\n\n        // 2 - Sign the transaction\n        const signedTransaction = await this.signTransaction(transactionToSend);\n\n        // 3 - Send the signed transaction\n        return (await provider.request({\n            method: RPC_METHODS.eth_sendRawTransaction,\n            params: [signedTransaction]\n        })) as string;\n    }\n\n    /**\n     * Signs a payload.\n     *\n     * @param {Uint8Array} payload - The payload to be signed as a byte array\n     * @return {Promise<string>} - A Promise that resolves to the signature as a string.\n     */\n    async signPayload(payload: Uint8Array): Promise<string> {\n        const sign = Secp256k1.sign(payload, new Uint8Array(this.privateKey));\n        // SCP256K1 encodes the recovery flag in the last byte. EIP-191 adds 27 to it.\n        sign[sign.length - 1] += 27;\n        return await Promise.resolve(Hex.of(sign).toString());\n    }\n\n    /**\n     * Signs a transaction internal method\n     *\n     * @param transaction - The transaction to sign\n     * @param gasPayer - The gasPayer to use\n     * @param thorClient - The ThorClient instance\n     * @returns The fully signed transaction\n     * @throws {InvalidSecp256k1PrivateKey, InvalidDataType}\n     */\n    async _signFlow(\n        transaction: TransactionRequestInput,\n        gasPayer: SignTransactionOptions | null,\n        thorClient: ThorClient\n    ): Promise<string> {\n        // Populate the call, to get proper from and to address (compatible with multi-clause transactions)\n        const populatedTransaction =\n            await this.populateTransaction(transaction);\n\n        // Sign the transaction\n        return gasPayer !== null\n            ? await this._signWithGasPayer(\n                  populatedTransaction,\n                  this.privateKey,\n                  thorClient,\n                  gasPayer\n              )\n            : Hex.of(\n                  Transaction.of(populatedTransaction).sign(this.privateKey)\n                      .encoded\n              ).toString();\n    }\n\n    /**\n     * Signs a transaction where the gas fee is paid by a gasPayer.\n     *\n     * @param unsignedTransactionBody - The unsigned transaction body to sign.\n     * @param originPrivateKey - The private key of the origin account.\n     * @param thorClient - The ThorClient instance.\n     * @param gasPayerOptions - Optional parameters for the request. Includes the `gasPayerServiceUrl` and `gasPayerPrivateKey` fields.\n     *                  Only one of the following options can be specified: `gasPayerServiceUrl`, `gasPayerPrivateKey`.\n     * @returns A promise that resolves to the signed transaction.\n     * @throws {NotDelegatedTransaction}\n     */\n    private async _signWithGasPayer(\n        unsignedTransactionBody: TransactionBody,\n        originPrivateKey: Uint8Array,\n        thorClient: ThorClient,\n        gasPayerOptions?: SignTransactionOptions\n    ): Promise<string> {\n        // Address of the origin account\n        const originAddress = Address.ofPrivateKey(originPrivateKey).toString();\n\n        const unsignedTx = Transaction.of(unsignedTransactionBody);\n\n        // Sign transaction with origin private key and gasPayer private key\n        if (gasPayerOptions?.gasPayerPrivateKey !== undefined)\n            return Hex.of(\n                Transaction.of(unsignedTransactionBody).signAsSenderAndGasPayer(\n                    originPrivateKey,\n                    HexUInt.of(gasPayerOptions?.gasPayerPrivateKey).bytes\n                ).encoded\n            ).toString();\n\n        // Otherwise, get the signature of the gasPayer from the gasPayer endpoint\n        const gasPayerSignature = await DelegationHandler(\n            gasPayerOptions\n        ).getDelegationSignatureUsingUrl(\n            unsignedTx,\n            originAddress,\n            thorClient.httpClient\n        );\n\n        // Sign transaction with origin private key\n        const originSignature = Secp256k1.sign(\n            unsignedTx.getTransactionHash().bytes,\n            originPrivateKey\n        );\n\n        // Sign the transaction with both signatures. Concat both signatures to get the final signature\n        const signature = new Uint8Array(\n            originSignature.length + gasPayerSignature.length\n        );\n        signature.set(originSignature);\n        signature.set(gasPayerSignature, originSignature.length);\n\n        // Return new signed transaction\n        return Hex.of(\n            Transaction.of(unsignedTx.body, signature).encoded\n        ).toString();\n    }\n}\n\nexport { VeChainPrivateKeySigner };\n","import { Address, HexUInt } from '@vechain/sdk-core';\nimport { InvalidDataType } from '@vechain/sdk-errors';\nimport {\n    type AvailableVeChainProviders,\n    VeChainPrivateKeySigner,\n    type VeChainSigner\n} from '../../../../signer';\nimport {\n    DelegationHandler,\n    type SignTransactionOptions\n} from '../../../../thor-client';\nimport {\n    type ProviderInternalWallet,\n    type ProviderInternalWalletAccount\n} from '../types';\n\n/**\n * Abstract implementation of Provider internal wallet class.\n */\nabstract class AbstractProviderInternalWallet\n    implements ProviderInternalWallet\n{\n    /**\n     * List of accounts in the wallet.\n     */\n    readonly accounts: ProviderInternalWalletAccount[];\n\n    /**\n     * Options for signing a transaction with gasPayer.\n     */\n    readonly gasPayer?: SignTransactionOptions;\n\n    /**\n     * Create a new wallet.\n     *\n     * @param accounts List of accounts in the wallet.\n     * @param options Optional options for signing a transaction with gasPayer.\n     */\n    constructor(\n        accounts: ProviderInternalWalletAccount[],\n        options?: {\n            gasPayer?: SignTransactionOptions;\n        }\n    ) {\n        this.accounts = accounts;\n        this.gasPayer = options?.gasPayer;\n    }\n\n    /**\n     * Get a signer into the internal wallet provider\n     * for the given address.\n     *\n     * @param parentProvider - The parent provider of the Internal Wallet.\n     * @param addressOrIndex - Address of the account.\n     * @returns The signer for the given address.\n     */\n    abstract getSigner(\n        parentProvider: AvailableVeChainProviders,\n        addressOrIndex?: string | number\n    ): Promise<VeChainSigner | null>;\n\n    /**\n     * SYNC Version of getSigner()\n     *\n     * Get a signer into the internal wallet provider\n     * for the given address.\n     *\n     * @param parentProvider - The parent provider of the Internal Wallet.\n     * @param addressOrIndex - Address or index of the account.\n     * @returns The signer for the given address.\n     */\n    getSignerSync(\n        parentProvider: AvailableVeChainProviders,\n        addressOrIndex?: string | number\n    ): VeChainSigner | null {\n        // Get the account from the wallet\n        const signerAccount = this.getAccountSync(addressOrIndex);\n\n        // Return a new signer (if exists)\n        if (signerAccount?.privateKey !== undefined) {\n            return new VeChainPrivateKeySigner(\n                signerAccount.privateKey,\n                parentProvider\n            );\n        }\n\n        // Return null if the account is not found\n        return null;\n    }\n\n    /**\n     * Get the list of addresses in the wallet.\n     *\n     * @returns The list of addresses in the wallet.\n     */\n    abstract getAddresses(): Promise<string[]>;\n\n    /**\n     * SYNC Version of getAddresses()\n     *\n     * Get the list of addresses in the wallet.\n     *\n     * @returns The list of addresses in the wallet.\n     */\n    getAddressesSync(): string[] {\n        return this.accounts.map((account) => account.address);\n    }\n\n    /**\n     * Get an account given an address or an index.\n     *\n     * @param addressOrIndex - Address or index of the account.\n     * @returns The account with the given address, or null if not found.\n     */\n    abstract getAccount(\n        addressOrIndex?: string | number\n    ): Promise<ProviderInternalWalletAccount | null>;\n\n    /**\n     * SYNC Version of getAccount()\n     *\n     * Get an account given an address or an index.\n     *\n     * @param addressOrIndex - Address or index of the account.\n     * @returns The account with the given address, or null if not found.\n     * @throws {InvalidDataType}\n     */\n    getAccountSync(\n        addressOrIndex?: string | number\n    ): ProviderInternalWalletAccount | null {\n        if (\n            addressOrIndex === undefined ||\n            typeof addressOrIndex === 'number'\n        ) {\n            return this.accounts[addressOrIndex ?? 0] ?? null;\n        }\n\n        // Check if the address is valid\n        if (!Address.isValid(addressOrIndex)) {\n            throw new InvalidDataType(\n                'AbstractProviderInternalWallet.getAccountSync()',\n                'Invalid params expected an address.',\n                { addressOrIndex }\n            );\n        }\n\n        // Get the account by address\n        const account = this.accounts.find(\n            (account) =>\n                Address.checksum(HexUInt.of(account.address)) ===\n                Address.checksum(HexUInt.of(addressOrIndex))\n        );\n        return account ?? null;\n    }\n\n    /**\n     * Get the options for signing a transaction with gasPayer (if any).\n     *\n     * @returns The options for signing a transaction with gasPayer.\n     */\n    abstract getGasPayer(): Promise<SignTransactionOptions | null>;\n\n    /**\n     * SYNC Version of getGasPayer()\n     *\n     * Get the options for signing a transaction with gasPayer (if any).\n     *\n     * @returns The options for signing a transaction with gasPayer.\n     */\n    getGasPayerSync(): SignTransactionOptions | null {\n        return DelegationHandler(this.gasPayer).gasPayerOrNull();\n    }\n}\n\nexport { AbstractProviderInternalWallet };\n","import { type ProviderInternalWalletAccount } from '../types';\nimport { type SignTransactionOptions } from '../../../../thor-client/transactions/types';\nimport {\n    type AvailableVeChainProviders,\n    type VeChainSigner\n} from '../../../../signer/signers/types';\nimport { AbstractProviderInternalWallet } from '../abstract-wallet/abstract-provider-internal-wallet';\n\n/**\n * Provider internal Base wallet class.\n *\n * This is the most basic wallet implementation we can have:\n * * This wallet is generated by a list of private keys\n */\nclass ProviderInternalBaseWallet extends AbstractProviderInternalWallet {\n    /**\n     * Get a signer into the internal wallet provider\n     * for the given address.\n     *\n     * @param parentProvider - The parent provider of the Internal Wallet.\n     * @param addressOrIndex - Address of the account.\n     * @returns The signer for the given address.\n     */\n    async getSigner(\n        parentProvider: AvailableVeChainProviders,\n        addressOrIndex?: string | number\n    ): Promise<VeChainSigner | null> {\n        return await Promise.resolve(\n            this.getSignerSync(parentProvider, addressOrIndex)\n        );\n    }\n\n    /**\n     * Get the list of addresses in the wallet.\n     *\n     * @returns The list of addresses in the wallet.\n     */\n    async getAddresses(): Promise<string[]> {\n        return await Promise.resolve(this.getAddressesSync());\n    }\n\n    /**\n     * Get an account given an address or an index.\n     *\n     * @param addressOrIndex - Address or index of the account.\n     * @returns The account with the given address, or null if not found.\n     */\n    async getAccount(\n        addressOrIndex?: string | number\n    ): Promise<ProviderInternalWalletAccount | null> {\n        return await Promise.resolve(this.getAccountSync(addressOrIndex));\n    }\n\n    /**\n     * Get the options for signing a transaction with gasPayer (if any).\n     *\n     * @returns The options for signing a transaction with gasPayer.\n     */\n    async getGasPayer(): Promise<SignTransactionOptions | null> {\n        return await Promise.resolve(this.getGasPayerSync());\n    }\n}\n\nexport { ProviderInternalBaseWallet };\n","import { Address, HDKey, Secp256k1 } from '@vechain/sdk-core';\nimport { type SignTransactionOptions } from '../../../../thor-client';\nimport { ProviderInternalBaseWallet } from '../base-wallet';\n\nclass ProviderInternalHDWallet extends ProviderInternalBaseWallet {\n    /**\n     * Mnemonic of the wallet.\n     */\n    readonly mnemonic: string[];\n\n    /**\n     * Derivation path of the wallet.\n     */\n    readonly derivationPath: string;\n\n    /**\n     * Number of accounts to generate.\n     */\n    readonly count: number;\n\n    /**\n     * Initial index of the accounts to generate.\n     */\n    readonly initialIndex: number;\n\n    /**\n     * Create a new HD wallet.\n     *\n     * @param mnemonic - Mnemonic of the wallet as an array of words.\n     * @param count - Number of accounts to generate.\n     * @param initialIndex - Initial index of the accounts to generate.\n     * @param derivationPath - Derivation path of the wallet.\n     * @param options - Options for signing a transaction with gasPayer.\n     */\n    constructor(\n        mnemonic: string[],\n        count: number = 1,\n        initialIndex: number = 0,\n        derivationPath: string = HDKey.VET_DERIVATION_PATH,\n        options?: {\n            gasPayer?: SignTransactionOptions;\n        }\n    ) {\n        // Initialize the base wallet with the generated accounts\n        super(\n            [...Array(count).keys()].map((path: number) => {\n                // Convert the private key to a buffer\n                const privateKeyBuffer = HDKey.fromMnemonic(\n                    mnemonic,\n                    derivationPath\n                ).deriveChild(path + initialIndex).privateKey as Uint8Array;\n\n                // Derive the public key and address from the private key\n                return {\n                    privateKey: privateKeyBuffer,\n                    publicKey: Secp256k1.derivePublicKey(privateKeyBuffer),\n                    address: Address.ofPrivateKey(privateKeyBuffer).toString()\n                };\n            }),\n            options\n        );\n\n        // Set the wallet properties\n        this.mnemonic = mnemonic;\n        this.derivationPath = derivationPath;\n        this.count = count;\n        this.initialIndex = initialIndex;\n    }\n}\n\nexport { ProviderInternalHDWallet };\n","import { stringifyData } from '@vechain/sdk-errors';\nimport {\n    JsonRpcApiProvider,\n    type JsonRpcError,\n    type JsonRpcPayload,\n    type JsonRpcResult\n} from 'ethers';\nimport { type HardhatVeChainProvider } from '../hardhat-provider/hardhat-provider';\n\n/**\n * JSON RPC provider for ethers.\n * Needed to customize ethers functionality into hardhat plugin.\n */\nclass JSONRPCEthersProvider extends JsonRpcApiProvider {\n    /**\n     * Instance of Hardhat VeChain provider to wrap\n     */\n    hardhatProvider: HardhatVeChainProvider;\n\n    /**\n     * Constructor with parameters.\n     *\n     * @param chainId - The chain id of the network\n     * @param networkName - The name of the network\n     * @param hardhatProvider - The hardhat provider to wrap\n     */\n    constructor(\n        chainId: number,\n        networkName: string,\n        hardhatProvider: HardhatVeChainProvider\n    ) {\n        super({ name: networkName, chainId });\n        this.hardhatProvider = hardhatProvider;\n    }\n\n    /**\n     * Override the send method to use the hardhat provider and to call _start method.\n     *\n     * @param method - The method to call\n     * @param params - The parameters of the method\n     */\n    async send(\n        method: string,\n        params: unknown[] | Record<string, unknown>\n    ): Promise<unknown> {\n        // Call the _start method\n        this._start();\n\n        // Call the _send method\n        return (await super.send(method, params)) as unknown;\n    }\n\n    /**\n     * Internal method to send the payload to the hardhat provider.\n     * This method is able to send multiple payloads. (send in batch)\n     *\n     * @param payload - The payload to send (request and method)'s\n     */\n    async _send(\n        payload: JsonRpcPayload | JsonRpcPayload[]\n    ): Promise<Array<JsonRpcResult | JsonRpcError>> {\n        // Initialize the request array\n        const requestPayloadArray = Array.isArray(payload)\n            ? payload\n            : [payload];\n\n        // Empty response array\n        const responses: Array<JsonRpcResult | JsonRpcError> = [];\n\n        // Call the hardhat provider for each request\n        for (const jsonRpcPayload of requestPayloadArray) {\n            // Do the request\n            try {\n                const result = (await this.hardhatProvider.send(\n                    jsonRpcPayload.method,\n                    jsonRpcPayload.params as unknown[]\n                )) as JsonRpcResult;\n\n                // Push the result to the response array\n                responses.push({\n                    id: jsonRpcPayload.id,\n                    result\n                });\n            } catch (e) {\n                // Push the error to the response array\n                responses.push({\n                    id: jsonRpcPayload.id,\n                    error: {\n                        code: -32603,\n                        message: stringifyData(e)\n                    }\n                });\n            }\n        }\n\n        return responses;\n    }\n}\n\nexport { JSONRPCEthersProvider };\n","/**\n * Polling interval for the subscription events polling mechanism for the VeChain provider.\n */\nconst POLLING_INTERVAL: number = 5000;\n\nexport { POLLING_INTERVAL };\n","import { HexUInt, Revision } from '@vechain/sdk-core';\nimport { JSONRPCInvalidDefaultBlock } from '@vechain/sdk-errors';\n\ntype DefaultBlock =\n    | `0x${string}`\n    | 'latest'\n    | 'earliest'\n    | 'pending'\n    | 'safe'\n    | 'finalized';\nconst defaultBlockTags: DefaultBlock[] = [\n    'latest',\n    'earliest',\n    'pending',\n    'safe',\n    'finalized'\n];\n\n/**\n * Maps the Ethereum \"default block\" type to VeChainThor Revision type.\n * Ethereum \"default block\" can be:\n * - 'latest' or 'earliest' or 'pending' or 'safe' or 'finalized'\n * - a hexadecimal block number\n * VeChainThor revision type can be:\n * - 'best', 'next', 'justified', 'finalized'\n * - a hexadecimal block Id\n * - a integer block number\n *\n * @param defaultBlock - The Ethereum default block type to convert\n * @returns The VeChainThor revision type\n */\nconst DefaultBlockToRevision = (defaultBlock: DefaultBlock): Revision => {\n    // if valid hex then return integer block number\n    if (HexUInt.isValid(defaultBlock)) {\n        return Revision.of(HexUInt.of(defaultBlock).n.toString());\n    }\n    // check if default block is a valid block tag\n    if (!defaultBlockTags.includes(defaultBlock)) {\n        const defaultBlockValue = defaultBlock.toString();\n        throw new JSONRPCInvalidDefaultBlock(\n            'DefaultBlockToRevision',\n            `Invalid default block: ${defaultBlockValue}`,\n            defaultBlockValue,\n            null\n        );\n    }\n    // map block tag to VeChainThor revision\n    if (defaultBlock === 'earliest') {\n        return Revision.of(HexUInt.of(0));\n    } else if (defaultBlock === 'safe') {\n        return Revision.of('justified');\n    } else if (defaultBlock === 'finalized') {\n        return Revision.of('finalized');\n    } else {\n        return Revision.of('best');\n    }\n};\n\nexport { type DefaultBlock, DefaultBlockToRevision };\n","import { HexUInt } from '@vechain/sdk-core';\n\n/**\n * Chain ID's this is the blockId of the genesis block\n */\nconst CHAIN_ID = {\n    MAINNET: '0x186a9',\n    TESTNET: '0x186aa',\n    SOLO_DEFAULT: '0xf6'\n};\n\nconst CHAIN_TAG = {\n    MAINNET: '0x4a',\n    TESTNET: '0x27',\n    SOLO_DEFAULT: '0xf6'\n};\n\n/**\n * Converts a chain tag to a chain Id\n * @param chainTag chain tag as last byte of genesis block id\n * @returns chain id\n */\nconst chainTagToChainId = (chainTag: HexUInt): HexUInt => {\n    if (chainTag.isEqual(HexUInt.of(CHAIN_TAG.MAINNET))) {\n        return HexUInt.of(CHAIN_ID.MAINNET);\n    } else if (chainTag.isEqual(HexUInt.of(CHAIN_TAG.TESTNET))) {\n        return HexUInt.of(CHAIN_ID.TESTNET);\n    } else if (chainTag.isEqual(HexUInt.of(CHAIN_TAG.SOLO_DEFAULT))) {\n        return HexUInt.of(CHAIN_ID.SOLO_DEFAULT);\n    } else {\n        return chainTag;\n    }\n};\n\nexport { CHAIN_ID, CHAIN_TAG, chainTagToChainId };\n","import { InvalidDataType } from '@vechain/sdk-errors';\nimport {\n    blocksFormatter,\n    type BlocksRPC,\n    type TransactionRPC\n} from '../../formatter';\nimport { type ExpandedBlockDetail } from '../../../../thor-client';\n\n/**\n * Get the index of the transaction in the specified block.\n *\n * @param block - The block to search in.\n * @param hash - The hash of the transaction to search for.\n * @returns the index of the transaction in the block or null if the transaction is not in the block.\n * @throws {InvalidDataType}\n */\nconst getTransactionIndexIntoBlock = (\n    block: BlocksRPC,\n    hash: string\n): number => {\n    const idx =\n        typeof block.transactions[0] === 'string'\n            ? (block.transactions as string[]).findIndex(\n                  (tx: string) => tx === hash\n              )\n            : block.transactions.findIndex(\n                  (tx) => (tx as TransactionRPC).hash === hash\n              );\n\n    if (idx === -1) {\n        throw new InvalidDataType(\n            'getTransactionIndexIntoBlock()',\n            'Transaction not found in block.',\n            { block, hash }\n        );\n    }\n\n    return idx;\n};\n\n/**\n * Get the number of logs ahead of a transaction into a block.\n *\n * @param blockExpanded - The block to search in.\n * @param transactionId - The hash of the transaction to search for.\n * @param chainId - The chain ID of the network.\n */\nconst getNumberOfLogsAheadOfTransactionIntoBlockExpanded = (\n    blockExpanded: ExpandedBlockDetail,\n    transactionId: string,\n    chainId: string\n): number => {\n    // Get transaction index into the block\n    const transactionIndex = getTransactionIndexIntoBlock(\n        blocksFormatter.formatToRPCStandard(blockExpanded, chainId),\n        transactionId\n    );\n\n    // Count the number of logs in the txs whose number is lower than txId\n    let logIndex: number = 0;\n\n    // Iterate over the transactions into the block bounded by the transaction index\n    for (let i = 0; i < transactionIndex; i++) {\n        const currentTransaction = blockExpanded.transactions[i];\n\n        // Iterate over the outputs of the current transaction\n        for (const output of currentTransaction.outputs) {\n            logIndex += output.events.length;\n        }\n    }\n\n    return logIndex;\n};\n\nexport {\n    getTransactionIndexIntoBlock,\n    getNumberOfLogsAheadOfTransactionIntoBlockExpanded\n};\n","import {\n    type TransactionReceiptLogsRPC,\n    type TransactionReceiptRPC,\n    type TransactionRPC\n} from './types';\nimport {\n    fromTransactionType,\n    Hex,\n    HexUInt,\n    Quantity,\n    TransactionType,\n    ZERO_BYTES\n} from '@vechain/sdk-core';\nimport {\n    getNumberOfLogsAheadOfTransactionIntoBlockExpanded,\n    getTransactionIndexIntoBlock\n} from '../../helpers/transaction/transaction-helpers';\nimport { blocksFormatter } from '../blocks';\nimport {\n    type ExpandedBlockDetail,\n    type TransactionDetailNoRaw,\n    type TransactionReceipt,\n    type TransactionsExpandedBlockDetail\n} from '../../../../thor-client';\n\n/**\n * Maps VeChain transaction types to Ethereum transaction types.\n * - VeChain Type 0 (legacy) maps to Ethereum Type 0 (legacy) -> '0x0'\n * - VeChain Type 81 (0x51, EIP1559) maps to Ethereum Type 2 (EIP-1559) -> '0x2'\n *\n * @param vechainType - The VeChain transaction type (0 or 81)\n * @returns The Ethereum transaction type as a hex string ('0x0' or '0x2')\n */\nconst mapVeChainTypeToEthereumType = (\n    vechainType: number | undefined | null\n): '0x0' | '0x2' => {\n    // If vechainType is undefined, null, or not a number, default to 0 (legacy)\n    if (\n        vechainType === undefined ||\n        vechainType === null ||\n        typeof vechainType !== 'number'\n    ) {\n        return '0x0';\n    }\n\n    // Type 81 (EIP1559) in VeChain corresponds to Type 2 (EIP-1559) in Ethereum\n    if (vechainType === fromTransactionType(TransactionType.EIP1559)) {\n        return '0x2';\n    }\n    // Default to legacy transaction type (0x0)\n    return '0x0';\n};\n\n/**\n * Output formatter for Transaction details.\n *\n * @param tx - The Transaction details to be formatted.\n * @param blockHash - The hash of the block where the transaction is in.\n * @param blockNumber - The number of the block where the transaction is in.\n * @param chainId - The chain ID of the network.\n * @param txIndex - The index of the transaction in the block.\n *\n * @returns The RPC standard formatted transaction.\n */\nconst _formatTransactionToRPC = (\n    tx: TransactionDetailNoRaw | TransactionsExpandedBlockDetail,\n    blockHash: string,\n    blockNumber: number,\n    chainId: string,\n    txIndex: number\n): TransactionRPC => {\n    // Default to legacy transaction type if 'type' property doesn't exist\n    const txType = 'type' in tx ? tx.type : 0;\n\n    return {\n        // Supported fields\n        blockHash,\n        blockNumber: Quantity.of(blockNumber).toString(),\n        from: tx.origin,\n        gas: Quantity.of(HexUInt.of(tx.gas).bi).toString(),\n        chainId,\n        hash: tx.id,\n        nonce: tx.nonce as string,\n        transactionIndex: Quantity.of(txIndex).toString(),\n\n        /**\n         * `input`, `to`, `value` are being referred to the first clause.\n         * VeChain supports multiple clauses in one transaction, thus the actual data should be obtained by looking into each clause.\n         * Due to the single clause limitation of Ethereum, we assume the first clause is the clause from which we obtain the data.\n         */\n        input: tx.clauses[0]?.data ?? '',\n        to: tx.clauses[0]?.to ?? null,\n        value:\n            tx.clauses[0]?.value !== undefined\n                ? Quantity.of(HexUInt.of(tx.clauses[0].value).bi).toString()\n                : '',\n\n        type: mapVeChainTypeToEthereumType(txType),\n        maxFeePerGas:\n            tx.maxFeePerGas !== undefined && tx.maxFeePerGas !== null\n                ? Quantity.of(HexUInt.of(tx.maxFeePerGas).bi).toString()\n                : undefined,\n        maxPriorityFeePerGas:\n            tx.maxPriorityFeePerGas !== undefined &&\n            tx.maxPriorityFeePerGas !== null\n                ? Quantity.of(HexUInt.of(tx.maxPriorityFeePerGas).bi).toString()\n                : undefined,\n\n        // Unsupported fields\n        gasPrice: '0x0',\n        v: '0x0',\n        r: '0x0',\n        s: '0x0',\n        accessList: [],\n        yParity: '0x0'\n    };\n};\n\n/**\n * Output formatter for Transaction details.\n * It converts the Transaction details into the RPC standard.\n *\n * @param tx - The Transaction details to be formatted.\n * @param chainId - The chain ID of the network.\n * @param txIndex - The index of the transaction in the block.\n *\n * @returns The RPC standard formatted transaction.\n */\nconst formatToRPCStandard = (\n    tx: TransactionDetailNoRaw,\n    chainId: string,\n    txIndex: number\n): TransactionRPC => {\n    return _formatTransactionToRPC(\n        tx,\n        tx.meta.blockID,\n        tx.meta.blockNumber,\n        chainId,\n        txIndex\n    );\n};\n\n/**\n * Output formatter for Transaction details from expanded block.\n * It converts the Transaction details into the RPC standard.\n *\n * @param tx - The Transaction details to be formatted.\n * @param block - The block details to be formatted.\n * @param chainId - The chain ID of the network.\n * @param txIndex - The index of the transaction in the block.\n *\n * @returns The RPC standard formatted transaction.\n */\nconst formatExpandedBlockToRPCStandard = (\n    tx: TransactionsExpandedBlockDetail,\n    block: ExpandedBlockDetail,\n    txIndex: number,\n    chainId: string\n): TransactionRPC => {\n    return _formatTransactionToRPC(\n        tx,\n        block.id,\n        block.number,\n        chainId,\n        txIndex\n    );\n};\n\n/**\n * Output formatter for Transaction Receipt details.\n * It converts the Transaction Receipt details, Transaction details and block into the RPC standard.\n *\n * @param transactionHash - The hash of the transaction to be formatted.\n * @param receipt - The Transaction Receipt to be formatted.\n * @param transaction - The Transaction details to be formatted.\n * @param blockContainsTransaction - The block contains the transaction to be formatted.\n * @param chainId - The chain ID of the network.\n */\nfunction formatTransactionReceiptToRPCStandard(\n    transactionHash: string,\n    receipt: TransactionReceipt,\n    transaction: TransactionDetailNoRaw,\n    blockContainsTransaction: ExpandedBlockDetail,\n    chainId: string\n): TransactionReceiptRPC {\n    // Get transaction index\n    const transactionIndex = getTransactionIndexIntoBlock(\n        blocksFormatter.formatToRPCStandard(blockContainsTransaction, chainId),\n        transactionHash\n    );\n\n    // Format transaction receipt logs\n    const logIndexOffset = getNumberOfLogsAheadOfTransactionIntoBlockExpanded(\n        blockContainsTransaction,\n        transactionHash,\n        chainId\n    );\n\n    const logs: TransactionReceiptLogsRPC[] = [];\n    let logIndex = logIndexOffset;\n    receipt.outputs.forEach((output) => {\n        output.events.forEach((event) => {\n            logs.push({\n                blockHash: receipt.meta.blockID,\n                blockNumber: Quantity.of(receipt.meta.blockNumber).toString(),\n                transactionHash: receipt.meta.txID as string,\n                address: event.address,\n                topics: event.topics.map((topic) => topic),\n                data: event.data,\n                removed: false,\n                transactionIndex: Quantity.of(transactionIndex).toString(),\n                logIndex: Quantity.of(logIndex).toString()\n            });\n            logIndex++;\n        });\n    });\n\n    // Default to legacy transaction type if 'type' property doesn't exist\n    const txType = 'type' in transaction ? transaction.type : 0;\n\n    return {\n        blockHash: receipt.meta.blockID,\n        blockNumber: Quantity.of(receipt.meta.blockNumber).toString(),\n        contractAddress:\n            receipt.outputs.length > 0\n                ? receipt.outputs[0].contractAddress\n                : null,\n        from: transaction.origin,\n        gasUsed: Quantity.of(receipt.gasUsed).toString(),\n        logs,\n        status: receipt.reverted ? '0x0' : '0x1',\n        to: transaction.clauses[0].to,\n        transactionHash: receipt.meta.txID as string,\n        transactionIndex: Quantity.of(transactionIndex).toString(),\n\n        // Incompatible fields\n        logsBloom: Hex.of(ZERO_BYTES(256)).toString(),\n        cumulativeGasUsed: '0x0',\n        effectiveGasPrice: '0x0',\n        type: mapVeChainTypeToEthereumType(txType)\n    };\n}\n\nexport {\n    formatToRPCStandard,\n    formatExpandedBlockToRPCStandard,\n    formatTransactionReceiptToRPCStandard\n};\n","import {\n    formatExpandedBlockToRPCStandard,\n    formatTransactionReceiptToRPCStandard,\n    formatToRPCStandard\n} from './formatter';\n\nexport type * from './types.d';\n\nexport const transactionsFormatter = {\n    formatToRPCStandard,\n    formatExpandedBlockToRPCStandard,\n    formatTransactionReceiptToRPCStandard\n};\n","import { HexUInt, Quantity, ZERO_BYTES } from '@vechain/sdk-core';\nimport {\n    type CompressedBlockDetail,\n    type ExpandedBlockDetail,\n    type TransactionsExpandedBlockDetail\n} from '../../../../thor-client';\nimport { transactionsFormatter } from '../transactions';\nimport { type BlocksRPC } from './types';\n\n/**\n * Output formatter for block details.\n * It converts the block details into the RPC standard.\n *\n * @param block - The block details to be formatted.\n * @param chainId - The chain id to use for the transaction formatting.\n */\nconst formatToRPCStandard = (\n    block: CompressedBlockDetail | ExpandedBlockDetail,\n    chainId: string\n): BlocksRPC => {\n    // Return the transactions array formatted based on the requested expanded flag\n    const transactions =\n        typeof block.transactions[0] === 'string'\n            ? (block.transactions as string[])\n            : block.transactions.map((tx, index) => {\n                  return transactionsFormatter.formatExpandedBlockToRPCStandard(\n                      tx as TransactionsExpandedBlockDetail,\n                      block as ExpandedBlockDetail,\n                      index,\n                      chainId\n                  );\n              });\n\n    return {\n        // Supported fields converted to RPC standard\n        hash: block.id,\n        parentHash: block.parentID,\n        number: Quantity.of(block.number).toString(),\n        size: Quantity.of(block.size).toString(),\n        stateRoot: block.stateRoot,\n        receiptsRoot: block.receiptsRoot,\n        transactionsRoot: block.txsRoot,\n        timestamp: Quantity.of(block.timestamp).toString(),\n        gasLimit: Quantity.of(block.gasLimit).toString(),\n        gasUsed: Quantity.of(block.gasUsed).toString(),\n        transactions,\n        miner: block.beneficiary,\n        baseFeePerGas: block.baseFeePerGas,\n\n        // Unsupported fields\n        difficulty: '0x0',\n        totalDifficulty: '0x0',\n        uncles: [],\n        sha3Uncles: HexUInt.of(ZERO_BYTES(32)).toString(),\n        nonce: HexUInt.of(ZERO_BYTES(8)).toString(),\n        logsBloom: HexUInt.of(ZERO_BYTES(256)).toString(),\n        extraData: '0x',\n        ...(block.baseFeePerGas !== undefined\n            ? { baseFeePerGas: block.baseFeePerGas }\n            : {}),\n        mixHash: HexUInt.of(ZERO_BYTES(32)).toString()\n    };\n};\n\nexport { formatToRPCStandard };\n","import { formatToRPCStandard } from './formatter';\nexport type * from './types.d';\n\nexport const blocksFormatter = { formatToRPCStandard };\n","import { type TracerNameRPC, type TracerReturnTypeRPC } from './types';\nimport { type TraceReturnType } from '../../../../thor-client';\n\n/**\n * Output formatter for RPC debug endpoints:\n * * debug_traceTransaction\n * * debug_traceCall\n * It converts our endpoint calls output to the RPC standard output.\n *\n * @param tracerName - Tracer name used for the debug endpoint.\n * @param debugDetails - Debug details to be formatted.\n */\nfunction formatToRPCStandard<TDebugType extends TracerNameRPC>(\n    tracerName: TDebugType,\n    debugDetails: TraceReturnType<TDebugType>\n): TracerReturnTypeRPC<'call'> | TracerReturnTypeRPC<'prestate'> {\n    if (tracerName === 'call') {\n        return {\n            ...(debugDetails as TraceReturnType<'call'>),\n\n            // Empty revert reason\n            revertReason: ''\n        } satisfies TracerReturnTypeRPC<'call'>;\n    }\n\n    return Object.fromEntries(\n        Object.entries(debugDetails as TraceReturnType<'prestate'>).map(\n            ([key, value]) => {\n                const valueWithoutEnergy = {\n                    balance: value.balance,\n                    code: value.code,\n                    storage: value.storage\n                } satisfies Omit<\n                    {\n                        balance: string;\n                        energy: string;\n                        code?: string;\n                        storage?: Record<string, string>;\n                    },\n                    'energy'\n                >;\n\n                return [key, { ...valueWithoutEnergy, nonce: 0 }];\n            }\n        )\n    ) satisfies TracerReturnTypeRPC<'prestate'>;\n}\n\nexport { formatToRPCStandard };\n","import { formatToRPCStandard } from './formatter';\n\nexport * from './formatter';\nexport type * from './types.d';\n\nexport const debugFormatter = {\n    formatToRPCStandard\n};\n","import { HexInt } from '@vechain/sdk-core';\nimport { type EventCriteria, type EventLogs } from '../../../../thor-client';\nimport { type LogsRPC } from './types';\n\n/**\n * Output formatter for Event logs.\n * It converts the Event logs into the RPC standard.\n *\n * @param eventLogs - The Event logs to be formatted.\n */\nconst formatToLogsRPC = (eventLogs: EventLogs[]): LogsRPC[] => {\n    // Final RPC event logs formatted\n    return eventLogs.map((eventLog: EventLogs) => {\n        return {\n            address: eventLog.address,\n            blockHash: eventLog.meta.blockID,\n            blockNumber: HexInt.of(eventLog.meta.blockNumber).toString(),\n            data: eventLog.data,\n            logIndex: '0x0',\n            // Always false for now\n            removed: false,\n            topics: eventLog.topics,\n            transactionHash: eventLog.meta.txID,\n            transactionIndex: '0x0'\n\n            // @NOTE: logIndex and transactionIndex are not implemented yet. This for performance reasons.\n            //\n            /**\n             * @NOTE: These two fields are not implemented yet.\n             * This for performance reasons.\n             * We can implement them later if needed.\n             *\n             * To have these two fields, we need to query a block for each entry into the logs.\n             * After from the block, we can get the transaction index and the log index.\n             * This is a performance issue because we have to query a block for each entry into the logs.\n             */\n        } satisfies LogsRPC;\n    });\n};\n\n/**\n * Convert the criteria topics into an array of topics.\n *\n * This because the criteria topics are not an array of topics in VeChain,\n * but they are directly enumerated (topic0, topic1, topic2, topic3, topic4).\n *\n * RPC standard requires an array of topics instead.\n *\n * @param criteriaTopicsArray - The criteria topics array.\n * @param address - The address to filter.\n */\nconst _scatterArrayTopic = (\n    criteriaTopicsArray: string[],\n    address?: string\n): EventCriteria => {\n    return {\n        address,\n        topic0: criteriaTopicsArray[0] ?? undefined,\n        topic1: criteriaTopicsArray[1] ?? undefined,\n        topic2: criteriaTopicsArray[2] ?? undefined,\n        topic3: criteriaTopicsArray[3] ?? undefined,\n        topic4: criteriaTopicsArray[4] ?? undefined\n    };\n};\n\n/**\n * Function to generate a set of event criteria based on input criteria.\n * The function takes an object with optional address and topics properties,\n * and returns an array of EventCriteria objects.\n *\n * @param {Object} criteria - The input criteria object.\n * @param {string|string[]} [criteria.address] - A single address string or an array of address strings.\n * @param {string[]|string[][]} [criteria.topics] - A single array of topics or an array of arrays of topics.\n * @returns {EventCriteria[]} An array of EventCriteria objects.\n */\nconst getCriteriaSetForInput = (criteria: {\n    address?: string | string[];\n    topics?: string[] | string[][];\n}): EventCriteria[] => {\n    // String to an array of addresses and topics\n    let criteriaAddress: string[] | undefined[] = [];\n\n    // Convert in any case to an array of addresses\n    if (criteria.address !== undefined) {\n        criteriaAddress =\n            typeof criteria.address === 'string'\n                ? [criteria.address]\n                : criteria.address;\n    } else {\n        criteriaAddress = [undefined];\n    }\n\n    const eventsCriteriaToFlat: EventCriteria[][] = criteriaAddress.map(\n        (addr) => {\n            return getTopicsPerAddress(addr, criteria.topics ?? []);\n        }\n    );\n\n    // Flat the array\n    return eventsCriteriaToFlat.flat();\n};\n\n/**\n * Function to generate a set of event criteria based on input topics and address.\n * The function takes an address and an array of topics and returns an array of EventCriteria objects.\n *\n * @param {string} address - The address to filter.\n * @param {string[]|string[][]} topics - A single array of topics or an array of arrays of topics.\n * @returns {EventCriteria[]} An array of EventCriteria objects.\n */\nconst getTopicsPerAddress = (\n    address: string | undefined,\n    topics: string[] | string[][]\n): EventCriteria[] => {\n    const notArrayTopics: string[] = [];\n    const arrayTopics: string[][] = [];\n\n    topics.forEach((topic) => {\n        if (!Array.isArray(topic)) {\n            notArrayTopics.push(topic);\n        }\n        if (Array.isArray(topic)) {\n            arrayTopics.push(topic);\n        }\n    });\n\n    const criteriaSet: EventCriteria[] = [];\n\n    if (notArrayTopics.length > 0) {\n        criteriaSet.push(_scatterArrayTopic(notArrayTopics, address));\n    }\n\n    arrayTopics.forEach((topics) => {\n        topics.forEach((topic) => {\n            criteriaSet.push({\n                address,\n                topic0: topic,\n                topic1: undefined,\n                topic2: undefined,\n                topic3: undefined,\n                topic4: undefined\n            });\n        });\n    });\n\n    // If no topics are provided, we add an empty criteria set\n    if (criteriaSet.length === 0) {\n        criteriaSet.push({\n            address,\n            topic0: undefined,\n            topic1: undefined,\n            topic2: undefined,\n            topic3: undefined,\n            topic4: undefined\n        });\n    }\n\n    return criteriaSet;\n};\n\nexport { formatToLogsRPC, getCriteriaSetForInput };\n","import { Hex, HexUInt } from '@vechain/sdk-core';\nimport { type ThorClient } from '../../../../../thor-client';\nimport {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport { chainTagToChainId } from '../../../const';\n\n// In-memory cache\nlet cachedChainId: HexUInt | null = null;\nlet cachedChainTag: HexUInt | null = null;\nlet cachedGenesisBlockId: Hex | null = null;\n\n/**\n * RPC Method eth_chainId implementation\n *\n * @link [eth_chainId](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @param thorClient - ThorClient instance.\n * @returns Returns the block id of the genesis block.\n * @throws {JSONRPCInvalidParams, JSONRPCInternalError}\n */\nconst ethChainId = async (thorClient: ThorClient): Promise<string> => {\n    try {\n        if (cachedChainId !== null) return cachedChainId.toString();\n        const genesisBlock = await thorClient.blocks.getGenesisBlock();\n        if (genesisBlock?.id === null || genesisBlock?.id === undefined) {\n            throw new JSONRPCInvalidParams(\n                'eth_chainId()',\n                'The genesis block id is null or undefined. Unable to get the chain id.',\n                {\n                    url: thorClient.httpClient.baseURL\n                }\n            );\n        }\n        if (!Hex.isValid(genesisBlock.id)) {\n            throw new JSONRPCInvalidParams(\n                'eth_chainId()',\n                'The genesis block id is invalid. Unable to get the chain id.',\n                {\n                    url: thorClient.httpClient.baseURL\n                }\n            );\n        }\n        cachedGenesisBlockId = Hex.of(genesisBlock.id);\n        cachedChainTag = HexUInt.of(cachedGenesisBlockId.bytes.slice(-1));\n        cachedChainId = chainTagToChainId(cachedChainTag);\n        return cachedChainId.toString();\n    } catch (e) {\n        throw new JSONRPCInternalError(\n            'eth_chainId()',\n            'Method \"eth_chainId\" failed.',\n            {\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\n/*\n * Get the chain id from the cached value or fetch it from the network.\n *\n * @param thorClient - ThorClient instance.\n * @returns The chain id.\n */\nconst getCachedChainId = async (thorClient: ThorClient): Promise<string> => {\n    return cachedChainId !== null\n        ? cachedChainId.toString()\n        : await ethChainId(thorClient);\n};\n\n/*\n * Get the chain tag from the cached value or fetch it from the network.\n *\n * @param thorClient - ThorClient instance.\n * @returns The chain tag.\n */\nconst getCachedChainTag = async (thorClient: ThorClient): Promise<string> => {\n    return cachedChainTag !== null\n        ? cachedChainTag.toString()\n        : await ethChainId(thorClient);\n};\n\nexport { ethChainId, getCachedChainId, getCachedChainTag };\n","import { ThorId } from '@vechain/sdk-core';\nimport {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport {\n    type ExpandedBlockDetail,\n    type ThorClient\n} from '../../../../../thor-client';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils/const/rpc/rpc';\nimport {\n    type TransactionReceiptRPC,\n    transactionsFormatter\n} from '../../../formatter';\nimport { ethChainId } from '../eth_chainId';\n\n/**\n * RPC Method eth_getTransactionReceipt implementation\n *\n * @link [eth_getTransactionReceipt](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @param thorClient - The thor client instance to use.\n *\n * @param params - The standard array of rpc call parameters.\n *                 * params[0]: The transaction hash to get as a hex string.\n *\n * @throws {ProviderRpcError} - Will throw an error if the retrieval of the transaction fails.\n */\nconst ethGetTransactionReceipt = async (\n    thorClient: ThorClient,\n    params: unknown[]\n): Promise<TransactionReceiptRPC | null> => {\n    // Input validation\n    if (params.length !== 1 || typeof params[0] !== 'string')\n        throw new JSONRPCInvalidParams(\n            'eth_getTransactionReceipt',\n            `Invalid input params for \"eth_getTransactionReceipt\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n\n    // Invalid transaction ID\n    if (!ThorId.isValid(params[0])) {\n        throw new JSONRPCInvalidParams(\n            'eth_getTransactionReceipt',\n            'Invalid transaction ID given as input. Input must be an hex string of length 64.',\n            { params }\n        );\n    }\n\n    try {\n        // Get hash by params\n        const [hash] = params as [string];\n\n        // Get transaction receipt\n        const receipt =\n            await thorClient.transactions.getTransactionReceipt(hash);\n\n        // Receipt is not null (transaction exists. This implies: Block exists and Transaction details exists)\n        if (receipt !== null) {\n            // Get the block containing the transaction. @note: It cannot be null!. If some error occurs, it will be thrown.\n            const blockContainsTransaction =\n                (await thorClient.blocks.getBlockExpanded(\n                    receipt.meta.blockID\n                )) as ExpandedBlockDetail;\n\n            // Get transaction detail. @note: It cannot be null!. If some error occurs, it will be thrown.\n            const transactionDetail =\n                await thorClient.transactions.getTransaction(hash);\n\n            // Get the chain id\n            const chainId = await ethChainId(thorClient);\n\n            // Initialize the result\n            if (transactionDetail !== null)\n                return transactionsFormatter.formatTransactionReceiptToRPCStandard(\n                    hash,\n                    receipt,\n                    transactionDetail,\n                    blockContainsTransaction,\n                    chainId\n                );\n            else return null;\n        } else {\n            return null;\n        }\n    } catch (e) {\n        throw new JSONRPCInternalError(\n            'eth_getTransactionReceipt()',\n            'Method \"eth_getTransactionReceipt\" failed.',\n            {\n                params: stringifyData(params),\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { ethGetTransactionReceipt };\n","import { ThorId } from '@vechain/sdk-core';\nimport {\n    InvalidDataType,\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport {\n    type ThorClient,\n    type TraceReturnType,\n    type TracerName\n} from '../../../../../thor-client';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\nimport { debugFormatter, type TracerReturnTypeRPC } from '../../../formatter';\nimport { ethGetTransactionReceipt } from '../eth_getTransactionReceipt';\nimport { type TraceOptionsRPC } from './types';\n\n/**\n * RPC Method debug_traceTransaction implementation\n *\n * @link [debug_traceTransaction](https://www.quicknode.com/docs/ethereum/debug_traceTransaction)\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n *                 * params[0]: transactionHash - hex string - This describes the transaction hash of the transaction that needs to be traced.\n *                 * params[1]: options - object - This describes the options for the trace. It has the following parameters:\n *                    * tracer - string to specify the type of tracer. Currently, it supports callTracer and prestateTracer.\n *                    * timeout - string - A duration string of decimal numbers that overrides the default timeout of 5 seconds for JavaScript-based tracing calls.\n *                      Max timeout is \"10s\". Valid time units are \"ns\", \"us\", \"ms\", \"s\" each with an optional fraction, such as \"300ms\" or \"2s45ms\"\n *                    * tracerConfig - Object to specify configurations for the tracer. It has the following parameter:\n *                       * onlyTopCall - boolean Setting this to true will only trace the main (top-level) call and none of the sub-calls.\n *                         This avoids extra processing for each call frame if only the top-level call info are required (useful for getting revertReason).\n *\n * @throws {JSONRPCInvalidParams, JSONRPCInternalError}\n */\nconst debugTraceTransaction = async (\n    thorClient: ThorClient,\n    params: unknown[]\n): Promise<TracerReturnTypeRPC<'call'> | TracerReturnTypeRPC<'prestate'>> => {\n    // Input validation\n    if (\n        params.length !== 2 ||\n        typeof params[0] !== 'string' ||\n        typeof params[1] !== 'object'\n    )\n        throw new JSONRPCInvalidParams(\n            'debug_traceTransaction',\n            `Invalid input params for \"debug_traceTransaction\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n\n    // Init params\n    const [transactionId, traceOptions] = params as [string, TraceOptionsRPC];\n\n    // Invalid transaction ID\n    if (!ThorId.isValid(transactionId)) {\n        throw new InvalidDataType(\n            'debug_traceTransaction()',\n            'Invalid transaction ID given as input. Input must be an hex string of length 64.',\n            { transactionId }\n        );\n    }\n\n    // Tracer to use\n    const tracerToUse: TracerName =\n        traceOptions.tracer === 'callTracer' ? 'call' : 'prestate';\n\n    try {\n        const transactionReceipt = await ethGetTransactionReceipt(thorClient, [\n            transactionId\n        ]);\n\n        const trace = (await thorClient.debug.traceTransactionClause(\n            {\n                target: {\n                    blockId: ThorId.of(transactionReceipt?.blockHash as string),\n                    transaction: ThorId.of(\n                        transactionReceipt?.transactionHash as string\n                    ),\n                    clauseIndex: 0\n                },\n                config: {}\n            },\n            tracerToUse\n        )) as TraceReturnType<'call'> | TraceReturnType<'prestate'>;\n\n        return debugFormatter.formatToRPCStandard(tracerToUse, trace);\n    } catch (e) {\n        throw new JSONRPCInternalError(\n            'debug_traceTransaction()',\n            'Method \"debug_traceTransaction\" failed.',\n            {\n                params: stringifyData(params),\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { debugTraceTransaction };\n","import { ThorId } from '@vechain/sdk-core';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\nimport {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport { blocksFormatter, type BlocksRPC } from '../../../formatter';\nimport { type ThorClient } from '../../../../../thor-client';\nimport { ethChainId } from '../eth_chainId';\n\n/**\n * RPC Method eth_getBlockByHash implementation\n *\n * @link [eth_getBlockByHash](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n *                 * params[0]: The block hash of block to get.\n *                 * params[1]: The transaction hydrated detail flag. If true, the block will contain the transaction details, otherwise it will only contain the transaction hashes.\n * @returns the block at the given block hash formatted to the RPC standard or null if the block does not exist.\n * @note Ethereum block hash is passed to Thor as the block id.\n * @throws {JSONRPCInvalidParams, JSONRPCInternalError}\n */\nconst ethGetBlockByHash = async (\n    thorClient: ThorClient,\n    params: unknown[]\n): Promise<BlocksRPC | null> => {\n    // Input validation\n    if (\n        params.length !== 2 ||\n        typeof params[0] !== 'string' ||\n        !ThorId.isValid(params[0]) ||\n        typeof params[1] !== 'boolean'\n    )\n        throw new JSONRPCInvalidParams(\n            'eth_getBlockByHash',\n            `Invalid input params for \"eth_getBlockByHash\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n\n    try {\n        const [blockHash, isTxDetail] = params as [string, boolean];\n\n        let chainId: string = '0x0';\n\n        // If the transaction detail flag is set, we need to get the chain id\n        if (isTxDetail) {\n            chainId = await ethChainId(thorClient);\n        }\n\n        const block = isTxDetail\n            ? await thorClient.blocks.getBlockExpanded(blockHash)\n            : await thorClient.blocks.getBlockCompressed(blockHash);\n\n        return block !== null\n            ? blocksFormatter.formatToRPCStandard(block, chainId)\n            : null;\n    } catch (e) {\n        throw new JSONRPCInternalError(\n            'eth_getBlockByHash()',\n            'Method \"eth_getBlockByHash\" failed.',\n            {\n                params: stringifyData(params),\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { ethGetBlockByHash };\n","import { ThorId } from '@vechain/sdk-core';\nimport {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport { type ThorClient } from '../../../../../thor-client';\nimport {\n    debugTraceTransaction,\n    type TraceOptionsRPC\n} from '../debug_traceTransaction';\nimport { ethGetBlockByHash } from '../eth_getBlockByHash';\nimport { type TracerReturnTypeRPC } from '../../../formatter/debug/types';\n\n/**\n * RPC Method debug_traceBlockByHash implementation\n *\n * @link [debug_traceBlockByHash](https://www.quicknode.com/docs/ethereum/debug_traceBlockByHash)\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n *                 * params[0]: The block hash of block to get.\n *                 * params[1]: options - object - This describes the options for the trace. It has the following parameters:\n *                    * tracer - string to specify the type of tracer. Currently, it supports callTracer and prestateTracer.\n *                    * tracerConfig - Object to specify configurations for the tracer. It has the following parameter:\n *                       * onlyTopCall - boolean Setting this to true will only trace the main (top-level) call and none of the sub-calls.\n *                         This avoids extra processing for each call frame if only the top-level call info are required (useful for getting revertReason).\n *\n * @throws {JSONRPCInvalidParams, JSONRPCInternalError}\n */\nconst debugTraceBlockByHash = async (\n    thorClient: ThorClient,\n    params: unknown[]\n): Promise<\n    Array<{\n        txHash: string;\n        result: TracerReturnTypeRPC<'call'> | TracerReturnTypeRPC<'prestate'>;\n    }>\n> => {\n    // Input validation\n    if (\n        params.length !== 2 ||\n        typeof params[0] !== 'string' ||\n        !ThorId.isValid(params[0]) ||\n        typeof params[1] !== 'object'\n    )\n        throw new JSONRPCInvalidParams(\n            'debug_traceBlockByHash',\n            `Invalid input params for \"debug_traceBlockByHash\" method. See https://www.quicknode.com/docs/ethereum/debug_traceBlockByHash for details.`,\n            { params }\n        );\n\n    // Init params\n    const [blockHash, traceOptions] = params as [\n        string,\n        Omit<TraceOptionsRPC, 'timeout'>\n    ];\n\n    try {\n        // Get block and transaction receipts\n        const block = await ethGetBlockByHash(thorClient, [blockHash, false]);\n\n        // if block does not exist\n        if (block === null) {\n            return [];\n        }\n\n        // Block exist, get traces\n        const traces = [];\n\n        // Trace each transaction in the block\n        for (const transaction of block.transactions as string[]) {\n            const trace = await debugTraceTransaction(thorClient, [\n                transaction,\n                { ...traceOptions, timeout: '5s' }\n            ]);\n            traces.push({\n                txHash: transaction,\n                result: trace\n            });\n        }\n\n        // Return traces\n        return traces;\n    } catch (e) {\n        throw new JSONRPCInternalError(\n            'debug_traceBlockByHash()',\n            'Method \"debug_traceBlockByHash\" failed.',\n            {\n                params: stringifyData(params),\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { debugTraceBlockByHash };\n","import {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport { type ThorClient } from '../../../../../thor-client';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\nimport { type DefaultBlock, DefaultBlockToRevision } from '../../../const';\nimport { blocksFormatter, type BlocksRPC } from '../../../formatter';\nimport { ethChainId } from '../eth_chainId';\n\n/**\n * RPC Method eth_getBlockByNumber implementation\n *\n * @link [eth_getBlockByNumber](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @note\n *  * Standard RPC method `eth_getBlockByNumber` support following block numbers: hex number of block, 'earliest', 'latest', 'safe', 'finalized', 'pending'. (@see https://ethereum.org/en/developers/docs/apis/json-rpc#default-block)\n *  * Currently, VeChainonly supports hex number of block, 'latest' and 'finalized'.\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n *                 * params[0]: The block number to get as a hex string or \"latest\" or \"finalized\".\n *                 * params[1]: The transaction detail flag. If true, the block will contain the transaction details, otherwise it will only contain the transaction hashes.\n * @returns the block at the given block number formatted to the RPC standard or null if the block does not exist.\n * @throws {JSONRPCInvalidParams, JSONRPCInternalError}\n */\nconst ethGetBlockByNumber = async (\n    thorClient: ThorClient,\n    params: unknown[]\n): Promise<BlocksRPC | null> => {\n    // Input validation\n    if (\n        params.length !== 2 ||\n        typeof params[0] !== 'string' ||\n        typeof params[1] !== 'boolean'\n    )\n        throw new JSONRPCInvalidParams(\n            'eth_getBlockByNumber',\n            `Invalid input params for \"eth_getBlockByNumber\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n\n    try {\n        const [blockNumber, isTxDetail] = params as [DefaultBlock, boolean];\n        const revision = DefaultBlockToRevision(blockNumber);\n\n        let chainId: string = '0x0';\n\n        // If the transaction detail flag is set, we need to get the chain id\n        if (isTxDetail) {\n            chainId = await ethChainId(thorClient);\n        }\n\n        const block = isTxDetail\n            ? await thorClient.blocks.getBlockExpanded(revision.toString())\n            : await thorClient.blocks.getBlockCompressed(revision.toString());\n\n        return block !== null\n            ? blocksFormatter.formatToRPCStandard(block, chainId)\n            : null;\n    } catch (e) {\n        throw new JSONRPCInternalError(\n            'eth_getBlockByNumber()',\n            'Method \"eth_getBlockByNumber\" failed.',\n            {\n                params: stringifyData(params),\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { ethGetBlockByNumber };\n","import {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport { type ThorClient } from '../../../../../thor-client';\nimport {\n    debugTraceTransaction,\n    type TraceOptionsRPC\n} from '../debug_traceTransaction';\nimport { type TracerReturnTypeRPC } from '../../../formatter';\nimport { ethGetBlockByNumber } from '../eth_getBlockByNumber';\n\n/**\n * RPC Method debug_traceBlockByNumber implementation\n *\n * @link [debug_traceBlockByNumber](https://www.quicknode.com/docs/ethereum/debug_traceBlockByNumber)\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n *                 * params[0]: The block number to get as a hex string or \"latest\" or \"finalized\".\n *                 * params[1]: options - object - This describes the options for the trace. It has the following parameters:\n *                    * tracer - string to specify the type of tracer. Currently, it supports callTracer and prestateTracer.\n *                    * tracerConfig - Object to specify configurations for the tracer. It has the following parameter:\n *                       * onlyTopCall - boolean Setting this to true will only trace the main (top-level) call and none of the sub-calls.\n *                         This avoids extra processing for each call frame if only the top-level call info are required (useful for getting revertReason).\n *\n * @throws {JSONRPCInvalidParams, JSONRPCInternalError}\n */\nconst debugTraceBlockByNumber = async (\n    thorClient: ThorClient,\n    params: unknown[]\n): Promise<\n    Array<{\n        txHash: string;\n        result: TracerReturnTypeRPC<'call'> | TracerReturnTypeRPC<'prestate'>;\n    }>\n> => {\n    // Input validation\n    if (\n        params.length !== 2 ||\n        typeof params[0] !== 'string' ||\n        typeof params[1] !== 'object'\n    )\n        throw new JSONRPCInvalidParams(\n            'debug_traceBlockByNumber',\n            `Invalid input params for \"debug_traceBlockByNumber\" method. See https://www.quicknode.com/docs/ethereum/debug_traceBlockByNumber for details.`,\n            { params }\n        );\n\n    // Init params\n    const [blockNumber, traceOptions] = params as [\n        string,\n        Omit<TraceOptionsRPC, 'timeout'>\n    ];\n\n    try {\n        // Get block and transaction receipts\n        const block = await ethGetBlockByNumber(thorClient, [\n            blockNumber,\n            false\n        ]);\n\n        // if block does not exist\n        if (block === null) {\n            return [];\n        }\n\n        // Block exist, get traces\n        const traces = [];\n\n        // Trace each transaction in the block\n        for (const transaction of block.transactions as string[]) {\n            const trace = await debugTraceTransaction(thorClient, [\n                transaction,\n                { ...traceOptions, timeout: '5s' }\n            ]);\n            traces.push({\n                txHash: transaction,\n                result: trace\n            });\n        }\n\n        // Return traces\n        return traces;\n    } catch (e) {\n        throw new JSONRPCInternalError(\n            'debug_traceBlockByNumber()',\n            'Method \"debug_traceBlockByNumber\" failed.',\n            {\n                params: stringifyData(params),\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { debugTraceBlockByNumber };\n","import {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport {\n    type ThorClient,\n    type TraceReturnType,\n    type TracerName\n} from '../../../../../thor-client';\nimport { debugFormatter, type TracerReturnTypeRPC } from '../../../formatter';\n\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\nimport { type TraceCallRPC, type TransactionObjectInput } from './types';\nimport { Address, HexUInt } from '@vechain/sdk-core';\n\n/**\n * RPC Method debug_traceCall implementation\n *\n * @link [debug_traceCall](https://www.quicknode.com/docs/ethereum/debug_traceCall)\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n *                * params[0]: transaction - object - This describes the transaction info with following properties:\n *                   * from - 20 bytes - Address the transaction is sent from.\n *                   * to - 20 bytes [Required] - Address the transaction is directed to.\n *                   * gas - Hexadecimal value of the gas provided for the transaction execution as hex string.\n *                   * gasPrice - Hexadecimal value of the gasPrice used for each paid gas.\n *                   * value - Hexadecimal of the value sent with this transaction.\n *                   * data - Hash of the method signature and encoded parameters.\n *                * params[1]: blockNumber - string - The block number parameter. A hexadecimal number or (latest, earliest or pending). (NOT SUPPORTED YET)\n *                * params[2]: options - object - This describes the options for the trace. It has the following parameters:\n *                   * tracer - string to specify the type of tracer. Currently, it supports callTracer and prestateTracer.\n *                   * tracerConfig - Object to specify configurations for the tracer. It has the following parameters:\n *                      * onlyTopCall - boolean Setting this to true will only trace the main (top-level) call and none of the sub-calls. This avoids extra processing for each call frame if only the top-level call info are required (useful for getting revertReason).\n * @throws {JSONRPCInvalidParams, JSONRPCInternalError}\n */\nconst debugTraceCall = async (\n    thorClient: ThorClient,\n    params: unknown[]\n): Promise<TracerReturnTypeRPC<'call'> | TracerReturnTypeRPC<'prestate'>> => {\n    // Input validation\n    if (\n        params.length !== 3 ||\n        typeof params[0] !== 'object' ||\n        typeof params[1] !== 'string' ||\n        typeof params[2] !== 'object'\n    )\n        throw new JSONRPCInvalidParams(\n            'debug_traceCall',\n            `Invalid input params for \"debug_traceCall\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n\n    // Init params\n    const transactionOptions = params[0] as TransactionObjectInput;\n    const tracerOptions = params[2] as TraceCallRPC;\n\n    // Tracer to use\n    const tracerToUse: TracerName =\n        tracerOptions.tracer === 'callTracer' ? 'call' : 'prestate';\n\n    try {\n        const trace = (await thorClient.debug.traceContractCall(\n            {\n                options: {\n                    caller: transactionOptions.from,\n                    gas:\n                        transactionOptions.gas !== undefined\n                            ? parseInt(transactionOptions.gas, 16)\n                            : undefined,\n                    gasPrice: transactionOptions.gasPrice\n                },\n                target: {\n                    to:\n                        typeof transactionOptions.to === 'string'\n                            ? Address.of(transactionOptions.to)\n                            : transactionOptions.to,\n                    data:\n                        typeof transactionOptions.data === 'string'\n                            ? HexUInt.of(transactionOptions.data)\n                            : undefined\n                },\n                config: tracerOptions.tracerConfig\n            },\n            tracerToUse\n        )) as TraceReturnType<'call'> | TraceReturnType<'prestate'>;\n\n        return debugFormatter.formatToRPCStandard(tracerToUse, trace);\n    } catch (e) {\n        throw new JSONRPCInternalError(\n            'debug_traceCall()',\n            'Method \"debug_traceCall\" failed.',\n            {\n                params: stringifyData(params),\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { debugTraceCall };\n","import { VeChainSDKLogger } from '@vechain/sdk-logging';\n\n/**\n * RPC Method engine_getPayloadBodiesByHashV1 implementation\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n * @note:\n * * params[0]: ...\n * * params[1]: ...\n * * params[n]: ...\n */\nconst engineGetPayloadBodiesByHashV1 =\n    async (): Promise<'METHOD NOT IMPLEMENTED'> => {\n        // Not implemented yet\n        VeChainSDKLogger('warning').log({\n            title: 'engine_getPayloadBodiesByHashV1',\n            messages: [\n                'Method \"engine_getPayloadBodiesByHashV1\" has not been implemented yet.'\n            ]\n        });\n\n        // To avoid eslint error\n        return await Promise.resolve('METHOD NOT IMPLEMENTED');\n    };\n\nexport { engineGetPayloadBodiesByHashV1 };\n","import { VeChainSDKLogger } from '@vechain/sdk-logging';\n\n/**\n * RPC Method engine_getPayloadBodiesByRangeV1 implementation\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n * @note:\n * * params[0]: ...\n * * params[1]: ...\n * * params[n]: ...\n */\nconst engineGetPayloadBodiesByRangeV1 =\n    async (): Promise<'METHOD NOT IMPLEMENTED'> => {\n        // Not implemented yet\n        VeChainSDKLogger('warning').log({\n            title: 'engine_getPayloadBodiesByRangeV1',\n            messages: [\n                'Method \"engine_getPayloadBodiesByRangeV1\" has not been implemented yet.'\n            ]\n        });\n\n        // To avoid eslint error\n        return await Promise.resolve('METHOD NOT IMPLEMENTED');\n    };\n\nexport { engineGetPayloadBodiesByRangeV1 };\n","import { type VeChainProvider } from '../../../../providers/vechain-provider';\n\n/**\n * RPC Method eth_accounts implementation\n *\n * @param provider - Provider with ProviderInternalWallet instance to use.\n */\nconst ethAccounts = async (provider?: VeChainProvider): Promise<string[]> => {\n    // ProviderInternalWallet exists\n    if (provider?.wallet !== undefined)\n        return await provider?.wallet.getAddresses();\n\n    // In error case (if wallet is not defined), return an empty array\n    return [];\n};\n\nexport { ethAccounts };\n","import { JSONRPCInternalError, stringifyData } from '@vechain/sdk-errors';\nimport { type ThorClient } from '../../../../../thor-client';\n\n/**\n * RPC Method eth_blockNumber implementation\n *\n * @link [eth_blockNumber](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @param thorClient - The thor client instance to use.\n * @returns the latest block number as a hex string. If the block number cannot be retrieved, it will return '0x0'\n * @throws {JSONRPCInternalError}\n */\nconst ethBlockNumber = async (thorClient: ThorClient): Promise<string> => {\n    try {\n        // 'best' is the alias for 'latest' in VeChainThorest\n        const latestBlock = await thorClient.blocks.getBestBlockCompressed();\n\n        return latestBlock?.number !== undefined\n            ? `0x${latestBlock.number.toString(16)}`\n            : '0x0';\n    } catch (e) {\n        throw new JSONRPCInternalError(\n            'eth_blockNumber()',\n            'Method \"eth_blockNumber\" failed.',\n            {\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { ethBlockNumber };\n","import {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport {\n    type SimulateTransactionClause,\n    type SimulateTransactionOptions,\n    type ThorClient\n} from '../../../../../thor-client';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\nimport { type DefaultBlock, DefaultBlockToRevision } from '../../../const';\nimport { type TransactionObjectInput } from './types';\n\n/**\n * RPC Method eth_call implementation\n *\n * @link [eth_call](https://ethereum.github.io/execution-apis/api-documentation/)\n * @param thorClient - The thor client instance to use.\n * @param params - The transaction call object\n * @returns The return value of executed contract.\n * @throws {JSONRPCInvalidParams, JSONRPCInternalError}\n */\nconst ethCall = async (\n    thorClient: ThorClient,\n    params: unknown[]\n): Promise<string> => {\n    // Input validation\n    if (\n        params.length !== 2 ||\n        typeof params[0] !== 'object' ||\n        (typeof params[1] !== 'object' && typeof params[1] !== 'string')\n    ) {\n        throw new JSONRPCInvalidParams(\n            'eth_call',\n            `Invalid input params for \"eth_call\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n    }\n\n    try {\n        const [inputOptions, block] = params as [\n            TransactionObjectInput,\n            DefaultBlock\n        ];\n\n        // Simulate transaction\n        const simulatedTx = await thorClient.transactions.simulateTransaction(\n            [\n                {\n                    to: inputOptions.to ?? null,\n                    value: inputOptions.value ?? '0x0',\n                    data: inputOptions.data ?? '0x0'\n                } satisfies SimulateTransactionClause\n            ],\n            {\n                revision: DefaultBlockToRevision(block).toString(),\n                gas:\n                    inputOptions.gas !== undefined\n                        ? parseInt(inputOptions.gas, 16)\n                        : undefined,\n                gasPrice: inputOptions.gasPrice ?? inputOptions.gasPrice,\n                caller: inputOptions.from\n            } satisfies SimulateTransactionOptions\n        );\n\n        if (simulatedTx[0].reverted) {\n            throw new JSONRPCInternalError(\n                'eth_call()',\n                'Method \"eth_call\" failed when simulating the transaction.',\n                {\n                    params: stringifyData(params),\n                    innerError: simulatedTx[0].vmError\n                }\n            );\n        }\n\n        // Return simulated transaction data\n        return simulatedTx[0].data;\n    } catch (e) {\n        if (e instanceof JSONRPCInternalError) {\n            throw e;\n        }\n        throw new JSONRPCInternalError(\n            'eth_call()',\n            'Method \"eth_call\" failed.',\n            {\n                params: stringifyData(params),\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { ethCall };\n","import { HexUInt } from '@vechain/sdk-core';\nimport {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport {\n    type SimulateTransactionClause,\n    type ThorClient\n} from '../../../../../thor-client';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\nimport { type DefaultBlock, DefaultBlockToRevision } from '../../../const';\nimport { type TransactionObjectInput } from './types';\n\n/**\n * RPC Method eth_estimateGas implementation\n *\n * @link [eth_estimateGas](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @note At the moment only the `to`, `value` and `data` fields are supported.\n *\n * @param thorClient - ThorClient instance.\n * @param params - The standard array of rpc call parameters.\n *                 * params[0]: The transaction call object.\n *                 * params[1]: A string representing a block number, or one of the string tags latest, earliest, or pending.\n * @returns A hexadecimal number representing the estimation of the gas for a given transaction.\n * @throws {JSONRPCInvalidParams, JSONRPCInternalError}\n */\nconst ethEstimateGas = async (\n    thorClient: ThorClient,\n    params: unknown[]\n): Promise<string> => {\n    // Input validation\n    if (params.length < 1 || params.length > 2 || typeof params[0] !== 'object')\n        throw new JSONRPCInvalidParams(\n            'eth_estimateGas',\n            `Invalid input params for \"eth_estimateGas\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n\n    try {\n        if (params.length === 1) {\n            params.push('latest');\n        }\n        // NOTE: The standard requires block parameter.\n        // Here it is ignored and can be added in the future compatibility reasons.\n        // (INPUT CHECK TAKE CARE OF THIS)\n        const [inputOptions, defaultBlock] = params as [\n            TransactionObjectInput,\n            DefaultBlock\n        ];\n        const revision = DefaultBlockToRevision(defaultBlock);\n\n        const estimatedGas = await thorClient.transactions.estimateGas(\n            [\n                {\n                    to: inputOptions.to ?? null,\n                    value: inputOptions.value ?? '0x0',\n                    data: inputOptions.data ?? '0x'\n                } satisfies SimulateTransactionClause\n            ],\n            inputOptions.from,\n            {\n                revision: revision.toString()\n            }\n        );\n\n        // Convert intrinsic gas to hex string and return\n        return HexUInt.of(estimatedGas.totalGas).toString(true);\n    } catch (e) {\n        throw new JSONRPCInternalError(\n            'eth_estimateGas()',\n            'Method \"eth_estimateGas\" failed.',\n            {\n                params: stringifyData(params),\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { ethEstimateGas };\n","import {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    JSONRPCMethodNotImplemented,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport { type ThorClient } from '../../../../../thor-client';\nimport { type FeeHistoryResponse } from '../../../../../thor-client/gas/types';\nimport { type VeChainProvider } from '../../../../providers/vechain-provider';\nimport { type DefaultBlock, DefaultBlockToRevision } from '../../../const';\n\n/**\n * RPC Method eth_feeHistory implementation for Galactica hardfork\n *\n * @link [eth_feeHistory](https://ethereum.github.io/execution-apis/api-documentation/)\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n *                 * params[0]: blockCount - number of blocks in the requested range\n *                 * params[1]: newestBlock - highest block of the requested range\n *                 * params[2]: rewardPercentiles - optional array of percentiles to compute\n * @param provider - The provider instance to use.\n * @returns Fee history for the returned block range\n * @throws {JSONRPCInvalidParams} | {JSONRPCInternalError} | {JSONRPCMethodNotImplemented}\n */\nconst ethFeeHistory = async (\n    thorClient: ThorClient,\n    params: unknown[],\n    _provider?: VeChainProvider\n): Promise<FeeHistoryResponse> => {\n    if (!Array.isArray(params) || params.length < 2) {\n        throw new JSONRPCInvalidParams(\n            'eth_feeHistory',\n            'Invalid input params for \"eth_feeHistory\" method.',\n            { params }\n        );\n    }\n\n    // Check if Galactica hardfork has happened\n    const galacticaForked = await thorClient.forkDetector.detectGalactica();\n    if (!galacticaForked) {\n        throw new JSONRPCMethodNotImplemented(\n            'eth_feeHistory',\n            'Method \"eth_feeHistory\" is not available before Galactica hardfork.',\n            { url: thorClient.httpClient.baseURL }\n        );\n    }\n\n    const blockCount = params[0];\n    const newestBlock = params[1];\n    const rewardPercentiles = params[2] as number[] | undefined;\n\n    // Validate newestBlock is a string or number\n    if (typeof newestBlock !== 'string' && typeof newestBlock !== 'number') {\n        throw new JSONRPCInvalidParams(\n            'eth_feeHistory',\n            'Invalid newestBlock parameter. Must be a string or number.',\n            { newestBlock }\n        );\n    }\n\n    // Validate blockCount is a valid number\n    const blockCountNum = Number(blockCount);\n    if (!Number.isFinite(blockCountNum) || blockCountNum <= 0) {\n        throw new JSONRPCInvalidParams(\n            'eth_feeHistory',\n            'blockCount must be a positive finite number.',\n            { blockCount, blockCountNum }\n        );\n    }\n\n    // convert default block to revision\n    const revision = DefaultBlockToRevision(newestBlock as DefaultBlock);\n\n    try {\n        return await thorClient.gas.getFeeHistory({\n            blockCount: blockCountNum,\n            newestBlock: revision.toString(),\n            rewardPercentiles\n        });\n    } catch (e) {\n        if (e instanceof JSONRPCInvalidParams) {\n            throw e;\n        }\n        throw new JSONRPCInternalError(\n            'eth_feeHistory()',\n            'Method \"eth_feeHistory\" failed.',\n            {\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { ethFeeHistory };\n","import { HexUInt } from '@vechain/sdk-core';\nimport { JSONRPCInternalError } from '@vechain/sdk-errors';\nimport { type ThorClient } from '../../../../../thor-client';\n\n/**\n * RPC Method eth_gasPrice implementation\n * @link [ethGasPrice](https://ethereum.github.io/execution-apis/api-documentation/)\n * @returns The current gas price in Wei unit considering that 1 VTHO equals 1e18 Wei.\n */\nconst ethGasPrice = async (thorClient: ThorClient): Promise<string> => {\n    // Check if Galactica hardfork has happened\n    const galacticaForked = await thorClient.forkDetector.detectGalactica();\n    if (!galacticaForked) {\n        const {\n            result: { plain }\n        } = await thorClient.contracts.getLegacyBaseGasPrice();\n        return HexUInt.of(plain as bigint).toString(true);\n    }\n\n    const bestBlock = await thorClient.blocks.getBestBlockCompressed();\n    const baseFeePerGas = bestBlock?.baseFeePerGas;\n\n    if (baseFeePerGas === undefined) {\n        throw new JSONRPCInternalError(\n            'eth_gasPrice',\n            'Last block should have baseFeePerGas defined.',\n            { params: bestBlock, url: thorClient.httpClient.baseURL }\n        );\n    }\n    const maxPriorityFeePerGas = await thorClient.gas.getMaxPriorityFeePerGas();\n\n    const baseFee = HexUInt.of(baseFeePerGas).bi;\n    const priority = HexUInt.of(maxPriorityFeePerGas).bi;\n\n    return HexUInt.of(baseFee + priority).toString(true);\n};\n\nexport { ethGasPrice };\n","import { type ThorClient } from '../../../../../thor-client';\nimport {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport { type DefaultBlock, DefaultBlockToRevision } from '../../../const';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\nimport { Address } from '@vechain/sdk-core';\n\n/**\n * RPC Method eth_getBalance implementation\n *\n * @link [eth_getBalance](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @note Only 'latest' and 'finalized' block numbers are supported.\n *\n * @param thorClient - ThorClient instance.\n * @param params - The standard array of rpc call parameters.\n *                * params[0]: The address to get the balance for as a hex string.\n *                * params[1]: The block number to get the balance at as a hex string or \"latest\".\n * @returns the balance of the account at the given address formatted to the RPC standard.\n * @throws {JSONRPCInvalidParams, JSONRPCInternalError}\n */\nconst ethGetBalance = async (\n    thorClient: ThorClient,\n    params: unknown[]\n): Promise<string> => {\n    // Input validation\n    if (\n        params.length !== 2 ||\n        typeof params[0] !== 'string' ||\n        (typeof params[1] !== 'object' && typeof params[1] !== 'string')\n    )\n        throw new JSONRPCInvalidParams(\n            'eth_getBalance',\n            `Invalid input params for \"eth_getBalance\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n\n    try {\n        const [address, block] = params as [string, DefaultBlock];\n\n        // Get the account details\n        const accountDetails = await thorClient.accounts.getAccount(\n            Address.of(address),\n            {\n                revision: DefaultBlockToRevision(block)\n            }\n        );\n\n        return accountDetails.balance;\n    } catch (e) {\n        throw new JSONRPCInternalError(\n            'eth_getBalance()',\n            'Method \"eth_getBalance\" failed.',\n            {\n                params: stringifyData(params),\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { ethGetBalance };\n","import { type ThorClient } from '../../../../../thor-client';\nimport {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport {\n    type TransactionReceiptRPC,\n    type TransactionRPC\n} from '../../../formatter';\nimport { ethGetBlockByNumber } from '../eth_getBlockByNumber';\nimport { ethGetTransactionReceipt } from '../eth_getTransactionReceipt';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\n\n/**\n * RPC Method eth_getBlockReceipts implementation\n *\n * @link [eth_getBlockReceipts](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n * @note:\n * * params[0]: blockNumber - The block number to get the receipts for as a hex string or \"latest\".\n * @throws {JSONRPCInvalidParams, JSONRPCInternalError}\n */\nconst ethGetBlockReceipts = async (\n    thorClient: ThorClient,\n    params: unknown[]\n): Promise<TransactionReceiptRPC[] | null> => {\n    // Input validation\n    if (params.length !== 1 || typeof params[0] !== 'string')\n        throw new JSONRPCInvalidParams(\n            'eth_getBlockReceipts',\n            `Invalid input params for \"eth_getBlockReceipts\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n\n    try {\n        // Initialize the block number from the params\n        const [blockNumber] = params as [string];\n\n        // Get the block by number\n        const block = await ethGetBlockByNumber(thorClient, [\n            blockNumber,\n            true\n        ]);\n\n        // Return the block receipts\n\n        // Block is null, return null\n        if (block === null) return null;\n\n        // Block is not null, return the block receipts\n        const transactionsIntoTheBlock: TransactionRPC[] =\n            block.transactions as TransactionRPC[];\n\n        const transactionReceipts: TransactionReceiptRPC[] = [];\n\n        for (const tx of transactionsIntoTheBlock) {\n            const receipt = (await ethGetTransactionReceipt(thorClient, [\n                tx.hash\n            ])) as TransactionReceiptRPC;\n\n            transactionReceipts.push(receipt);\n        }\n\n        return transactionReceipts;\n    } catch (e) {\n        throw new JSONRPCInternalError(\n            'eth_getBlockReceipts()',\n            'Method \"eth_getBlockReceipts\" failed.',\n            {\n                params: stringifyData(params),\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { ethGetBlockReceipts };\n","import type { ThorClient } from '../../../../../thor-client';\nimport { JSONRPCInvalidParams } from '@vechain/sdk-errors';\nimport { ethGetBlockByHash } from '../eth_getBlockByHash';\nimport { ThorId } from '@vechain/sdk-core';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\n\n/**\n * RPC Method eth_getBlockTransactionCountByHash implementation\n *\n * @link [eth_getBlockTransactionCountByHash](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n *                 * params[0]: The block hash of block to get.\n * @returns The number of transactions in the block with the given block hash.\n * @throws {JSONRPCInvalidParams, JSONRPCInternalError}\n */\nconst ethGetBlockTransactionCountByHash = async (\n    thorClient: ThorClient,\n    params: unknown[]\n): Promise<number> => {\n    // Input validation\n    if (\n        params.length !== 1 ||\n        typeof params[0] !== 'string' ||\n        !ThorId.isValid(params[0])\n    )\n        throw new JSONRPCInvalidParams(\n            'eth_getBlockTransactionCountByHash',\n            `Invalid input params for \"eth_getBlockTransactionCountByHash\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n\n    const block = await ethGetBlockByHash(thorClient, [params[0], false]);\n    if (block !== null) return block.transactions.length;\n    return 0;\n};\n\nexport { ethGetBlockTransactionCountByHash };\n","import { JSONRPCInvalidParams } from '@vechain/sdk-errors';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\nimport type { ThorClient } from '../../../../../thor-client';\nimport { ethGetBlockByNumber } from '../eth_getBlockByNumber';\n\n/**\n * RPC Method eth_getBlockTransactionCountByNumber implementation\n *\n * @link [eth_getBlockTransactionCountByNumber](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n *                 * params[0]: The block hash of block to get.\n * @returns The number of transactions in the block with the given block hash.\n * @throws {JSONRPCInvalidParams, JSONRPCInternalError}\n */\nconst ethGetBlockTransactionCountByNumber = async (\n    thorClient: ThorClient,\n    params: unknown[]\n): Promise<number> => {\n    // Input validation\n    if (params.length !== 1 || typeof params[0] !== 'string')\n        throw new JSONRPCInvalidParams(\n            'eth_getBlockTransactionCountByNumber',\n            `Invalid input params for \"eth_getBlockTransactionCountByNumber\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n\n    const block = await ethGetBlockByNumber(thorClient, [params[0], true]);\n    if (block !== null) return block.transactions.length;\n    return 0;\n};\n\nexport { ethGetBlockTransactionCountByNumber };\n","import { Address } from '@vechain/sdk-core';\nimport {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport { type ThorClient } from '../../../../../thor-client';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\nimport { type DefaultBlock, DefaultBlockToRevision } from '../../../const';\n\n/**\n * RPC Method eth_getCode implementation\n *\n * @link [eth_getCode](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @note Only 'latest' and 'finalized' block numbers are supported.\n *\n * @param thorClient - ThorClient instance.\n * @param params - The standard array of rpc call parameters.\n *               * params[0]: The address to get the code for as a hex string.\n *               * params[1]: The block number to get the code at as a hex string or \"latest\".\n * @returns The code of the account at the given address formatted to the RPC standard.\n * @throws {JSONRPCInternalError}\n */\nconst ethGetCode = async (\n    thorClient: ThorClient,\n    params: unknown[]\n): Promise<string> => {\n    // Input validation\n    if (\n        params.length !== 2 ||\n        typeof params[0] !== 'string' ||\n        (typeof params[1] !== 'object' && typeof params[1] !== 'string')\n    )\n        throw new JSONRPCInvalidParams(\n            'eth_getCode',\n            `Invalid input params for \"eth_getCode\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n\n    try {\n        const [address, block] = params as [string, DefaultBlock];\n\n        // Get the account bytecode\n        const bytecode = await thorClient.accounts.getBytecode(\n            Address.of(address),\n            {\n                revision: DefaultBlockToRevision(block)\n            }\n        );\n\n        return bytecode.toString();\n    } catch (e) {\n        throw new JSONRPCInternalError(\n            'eth_getCode()',\n            'Method \"eth_getCode\" failed.',\n            {\n                params: stringifyData(params),\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { ethGetCode };\n","import { VeChainSDKLogger } from '@vechain/sdk-logging';\n\n/**\n * RPC Method eth_getFilterChanges implementation\n *\n * @link [eth_getFilterChanges](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n * @note:\n * * params[0]: ...\n * * params[1]: ...\n * * params[n]: ...\n */\nconst ethGetFilterChanges = async (): Promise<'METHOD NOT IMPLEMENTED'> => {\n    // Not implemented yet\n    VeChainSDKLogger('warning').log({\n        title: 'eth_getFilterChanges',\n        messages: [\n            'Method \"eth_getFilterChanges\" has not been implemented yet.'\n        ]\n    });\n\n    // To avoid eslint error\n    return await Promise.resolve('METHOD NOT IMPLEMENTED');\n};\n\nexport { ethGetFilterChanges };\n","import { VeChainSDKLogger } from '@vechain/sdk-logging';\n\n/**\n * RPC Method eth_getFilterLogs implementation\n *\n * @link [eth_getFilterLogs](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n * @note:\n * * params[0]: ...\n * * params[1]: ...\n * * params[n]: ...\n */\nconst ethGetFilterLogs = async (): Promise<'METHOD NOT IMPLEMENTED'> => {\n    // Not implemented yet\n    VeChainSDKLogger('warning').log({\n        title: 'eth_getFilterLogs',\n        messages: ['Method \"eth_getFilterLogs\" has not been implemented yet.']\n    });\n\n    // To avoid eslint error\n    return await Promise.resolve('METHOD NOT IMPLEMENTED');\n};\n\nexport { ethGetFilterLogs };\n","import {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport {\n    formatToLogsRPC,\n    getCriteriaSetForInput,\n    type LogsRPC\n} from '../../../formatter';\nimport {\n    type CompressedBlockDetail,\n    type EventCriteria,\n    type EventLogs,\n    type ThorClient\n} from '../../../../../thor-client';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\n\n/**\n * RPC Method eth_getLogs implementation\n *\n * @link [eth_getLogs](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n * @returns An array of log objects, or an empty array if nothing has changed since last poll\n * @throws {JSONRPCInvalidParams, JSONRPCInternalError}\n */\nconst ethGetLogs = async (\n    thorClient: ThorClient,\n    params: unknown[]\n): Promise<LogsRPC[]> => {\n    // Input validation\n    if (params.length !== 1 || typeof params[0] !== 'object')\n        throw new JSONRPCInvalidParams(\n            'eth_getLogs',\n            `Invalid input params for \"eth_getLogs\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n\n    // Block max limit\n    const MAX_LIMIT = 1000;\n\n    // Input params\n    const [filterOptions] = params as [\n        {\n            address?: string | string[] | null;\n            fromBlock?: string;\n            toBlock?: string;\n            topics?: string[] | string[][];\n            blockhash?: string;\n        }\n    ];\n\n    try {\n        // Get the latest block (if fromBlock or toBlock is not defined, we will use the latest block)\n        const latestBlock =\n            (await thorClient.blocks.getBestBlockCompressed()) as CompressedBlockDetail;\n\n        // Get criteria set from input\n        const criteriaSet: EventCriteria[] = getCriteriaSetForInput({\n            address:\n                filterOptions.address !== null\n                    ? filterOptions.address\n                    : undefined,\n            topics: filterOptions.topics\n        });\n\n        // Call thor client to get logs\n        const logs: EventLogs[] = await thorClient.logs.filterRawEventLogs({\n            range: {\n                unit: 'block',\n                from:\n                    filterOptions.fromBlock !== undefined\n                        ? parseInt(filterOptions.fromBlock, 16)\n                        : latestBlock.number,\n                to:\n                    filterOptions.toBlock !== undefined\n                        ? parseInt(filterOptions.toBlock, 16)\n                        : latestBlock.number\n            },\n            criteriaSet,\n            order: 'asc',\n            options: {\n                offset: 0,\n                limit: MAX_LIMIT\n            }\n        });\n\n        // Format logs to RPC\n        return formatToLogsRPC(logs);\n    } catch (e) {\n        throw new JSONRPCInternalError(\n            'eth_getLogs()',\n            'Method \"eth_getLogs\" failed.',\n            {\n                params: stringifyData(params),\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { ethGetLogs };\n","import { Address, ThorId } from '@vechain/sdk-core';\nimport {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport { type ThorClient } from '../../../../../thor-client';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\nimport { type DefaultBlock, DefaultBlockToRevision } from '../../../const';\n\n/**\n * RPC Method eth_getStorageAt implementation\n *\n * @link [eth_getStorageAt](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @note Only 'latest' and 'finalized' block numbers are supported.\n *\n * @param thorClient - ThorClient instance.\n * @param params - The standard array of rpc call parameters.\n *               * params[0]: The address to get the storage slot for as a hex string.\n *               * params[1]: The storage position to get as a hex string.\n *               * params[2]: The block number to get the storage slot at as a hex string or \"latest\".\n * @returns The storage slot of the account at the given address formatted to the RPC standard.\n * @throws {JSONRPCInvalidParams, JSONRPCInternalError}\n */\nconst ethGetStorageAt = async (\n    thorClient: ThorClient,\n    params: unknown[]\n): Promise<string> => {\n    // Input validation\n    if (\n        params.length !== 3 ||\n        typeof params[0] !== 'string' ||\n        (typeof params[1] !== 'string' && typeof params[1] !== 'bigint') ||\n        (params[2] != null &&\n            typeof params[2] !== 'object' &&\n            typeof params[2] !== 'string')\n    ) {\n        throw new JSONRPCInvalidParams(\n            'eth_getStorageAt',\n            `Invalid input params for \"eth_getStorageAt\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n    }\n\n    try {\n        if (params[2] == null) {\n            params[2] = 'latest';\n        }\n        const [address, storagePosition, block] = params as [\n            string,\n            string,\n            DefaultBlock\n        ];\n\n        // Get the account details\n        const storage = await thorClient.accounts.getStorageAt(\n            Address.of(address),\n            ThorId.of(storagePosition),\n            {\n                revision: DefaultBlockToRevision(block)\n            }\n        );\n        return storage.toString();\n    } catch (e) {\n        throw new JSONRPCInternalError(\n            'eth_getStorageAt()',\n            'Method \"eth_getStorageAt\" failed.',\n            {\n                params: stringifyData(params),\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { ethGetStorageAt };\n","import {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport { type ThorClient } from '../../../../../thor-client';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\nimport { type TransactionRPC, transactionsFormatter } from '../../../formatter';\nimport { getTransactionIndexIntoBlock } from '../../../helpers';\nimport { ethChainId } from '../eth_chainId';\nimport { ethGetBlockByHash } from '../eth_getBlockByHash';\n\n/**\n * RPC Method eth_getTransactionByHash implementation\n *\n * @link [eth_getTransactionByHash](https://docs.infura.io/networks/ethereum/json-rpc-methods/eth_gettransactionbyhash)\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n *                 * params[0]: The transaction hash to get as a hex string.\n * @returns the transaction at the given hash formatted to the RPC standard or null if the transaction does not exist.\n * @throws {JSONRPCInvalidParams, JSONRPCInternalError}\n */\nconst ethGetTransactionByHash = async (\n    thorClient: ThorClient,\n    params: unknown[]\n): Promise<TransactionRPC | null> => {\n    // Input validation\n    if (params.length !== 1 || typeof params[0] !== 'string')\n        throw new JSONRPCInvalidParams(\n            'eth_getTransactionByHash',\n            `Invalid input params for \"eth_getTransactionByHash\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n\n    try {\n        const [hash] = params as [string];\n\n        // Get the VeChainThor transaction\n        const tx = await thorClient.transactions.getTransaction(hash);\n\n        if (tx === null) return null;\n\n        // Get the block containing the transaction\n        const block = await ethGetBlockByHash(thorClient, [\n            tx.meta.blockID,\n            false\n        ]);\n\n        if (block === null) return null;\n\n        // Get the index of the transaction in the block\n        const txIndex = getTransactionIndexIntoBlock(block, hash);\n\n        // Get the chain id\n        const chainId = await ethChainId(thorClient);\n\n        return transactionsFormatter.formatToRPCStandard(tx, chainId, txIndex);\n    } catch (e) {\n        throw new JSONRPCInternalError(\n            'eth_getTransactionByHash()',\n            'Method \"eth_getTransactionByHash\" failed.',\n            {\n                params: stringifyData(params),\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { ethGetTransactionByHash };\n","import {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport { type ThorClient } from '../../../../../thor-client';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\nimport { type BlocksRPC, type TransactionRPC } from '../../../formatter';\nimport { ethGetBlockByHash } from '../eth_getBlockByHash';\nimport { ethGetTransactionByHash } from '../eth_getTransactionByHash';\n\n/**\n * RPC Method eth_getTransactionByBlockHashAndIndex implementation\n *\n * @link [eth_getTransactionByBlockHashAndIndex](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n * @note:\n * * params[0]: ...\n * * params[1]: ...\n * * params[n]: ...\n */\nconst ethGetTransactionByBlockHashAndIndex = async (\n    thorClient: ThorClient,\n    params: unknown[]\n): Promise<TransactionRPC | null> => {\n    if (\n        params.length !== 2 ||\n        typeof params[0] !== 'string' ||\n        typeof params[1] !== 'string'\n    )\n        throw new JSONRPCInvalidParams(\n            'eth_getTransactionByBlockHashAndIndex',\n            `Invalid input params for \"eth_getTransactionByBlockHashAndIndex\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n\n    try {\n        const [blockHash, index] = params as [string, string];\n\n        // Get the block containing the transactions\n        const block = (await ethGetBlockByHash(thorClient, [\n            blockHash,\n            false\n        ])) as BlocksRPC;\n\n        for (const transactionHash of block.transactions) {\n            const transaction = (await ethGetTransactionByHash(thorClient, [\n                transactionHash\n            ])) as TransactionRPC;\n            if (transaction.transactionIndex === index) {\n                return transaction;\n            }\n        }\n\n        return null;\n    } catch (e) {\n        throw new JSONRPCInternalError(\n            'eth_getTransactionByBlockHashAndIndex()',\n            'Method \"eth_getTransactionByBlockHashAndIndex\" failed.',\n            {\n                params: stringifyData(params),\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { ethGetTransactionByBlockHashAndIndex };\n","import {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport { type ThorClient } from '../../../../../thor-client';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\nimport { type BlocksRPC, type TransactionRPC } from '../../../formatter';\nimport { ethGetBlockByNumber } from '../eth_getBlockByNumber';\nimport { ethGetTransactionByHash } from '../eth_getTransactionByHash';\n\n/**\n * RPC Method eth_getTransactionByBlockNumberAndIndex implementation\n *\n * @link [eth_getTransactionByBlockNumberAndIndex](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n * @note:\n * * params[0]: block parameter, a hexadecimal block number (or best, latest, finalized).\n * * params[1]: transaction index position, a hexadecimal of the integer representing the position in the block.\n * @returns A transaction object, or null when no transaction was found.\n */\nconst ethGetTransactionByBlockNumberAndIndex = async (\n    thorClient: ThorClient,\n    params: unknown[]\n): Promise<TransactionRPC | null> => {\n    if (\n        params.length !== 2 ||\n        typeof params[0] !== 'string' ||\n        typeof params[1] !== 'string'\n    )\n        throw new JSONRPCInvalidParams(\n            'eth_getTransactionByBlockNumberAndIndex',\n            `Invalid input params for \"eth_getTransactionByBlockNumberAndIndex\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n\n    try {\n        const [blockHash, index] = params as [string, string];\n\n        // Get the block containing the transactions\n        const block = (await ethGetBlockByNumber(thorClient, [\n            blockHash,\n            false\n        ])) as BlocksRPC;\n\n        for (const transactionHash of block.transactions) {\n            const transaction = (await ethGetTransactionByHash(thorClient, [\n                transactionHash\n            ])) as TransactionRPC;\n            if (transaction.transactionIndex === index) {\n                return transaction;\n            }\n        }\n\n        return null;\n    } catch (e) {\n        throw new JSONRPCInternalError(\n            'eth_getTransactionByBlockNumberAndIndex()',\n            'Method \"eth_getTransactionByBlockNumberAndIndex\" failed.',\n            {\n                params: stringifyData(params),\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { ethGetTransactionByBlockNumberAndIndex };\n","import { JSONRPCInvalidParams } from '@vechain/sdk-errors';\nimport { Address, Hex, Secp256k1 } from '@vechain/sdk-core';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\n\n/**\n * RPC Method eth_getTransactionCount implementation\n *\n * @link [eth_getTransactionCount](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @note: To respect differences between VeChain and Ethereum, in this function we will give a random number as output.\n * Basically Ethereum to get nonce to use the number of transactions sent from an address,\n * while VeChain uses a random number.\n *\n * @param params - The standard array of rpc call parameters.\n *                * params[0]: address: string, is the address to get the number of transactions from.\n *                * params[1]: A string representing a block number, or one of the string tags latest, earliest, or pending.\n * @throws {JSONRPCInvalidParams, JSONRPCInternalError}\n */\nconst ethGetTransactionCount = async (params: unknown[]): Promise<string> => {\n    // Input validation\n    if (\n        typeof params[0] !== 'string' ||\n        (typeof params[1] !== 'object' && typeof params[1] !== 'string')\n    )\n        throw new JSONRPCInvalidParams(\n            'eth_getTransactionCount',\n            `Invalid input params for \"eth_getTransactionCount\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n\n    // Invalid address\n    if (!Address.isValid(params[0])) {\n        throw new JSONRPCInvalidParams(\n            'eth_getTransactionCount',\n            'Invalid address, expected a 20 bytes address string.',\n            { params }\n        );\n    }\n\n    // Return a random number\n    return await Promise.resolve(Hex.of(Secp256k1.randomBytes(6)).toString());\n};\n\nexport { ethGetTransactionCount };\n","import { JSONRPCInvalidParams } from '@vechain/sdk-errors';\nimport { ThorId } from '@vechain/sdk-core';\n\n/**\n * RPC Method eth_getUncleByBlockHashAndIndex implementation\n *\n * @link [eth_getUncleByBlockHashAndIndex](https://docs.infura.io/api/networks/ethereum/json-rpc-methods/eth_getunclebyblockhashandindex)\n *\n * @note\n *  * Standard RPC method `eth_getUncleByBlockHashAndIndex` support following block numbers: hex number of block, 'earliest', 'latest', 'safe', 'finalized', 'pending'. (@see https://ethereum.org/en/developers/docs/apis/json-rpc#default-block)\n *  * Currently, VeChain only supports hex number of block, 'latest' and 'finalized'.\n *  * We return a constant empty object for now.\n *\n * @param params - The standard array of rpc call parameters.\n *                 * params[0]: The block hash to get as a hex string.\n *                 * params[1]: A hexadecimal equivalent of the integer indicating the uncle's index position.\n * @returns The uncle block at the given block number and index.\n * @throws {JSONRPCInvalidParams}\n */\nconst ethGetUncleByBlockHashAndIndex = async (\n    params: unknown[]\n): Promise<object | null> => {\n    // Input validation\n    if (\n        params.length !== 2 ||\n        typeof params[0] !== 'string' ||\n        !ThorId.isValid(params[0]) ||\n        typeof params[1] !== 'string'\n    )\n        throw new JSONRPCInvalidParams(\n            'eth_getUncleByBlockHashAndIndex',\n            'Invalid input params for \"eth_getUncleByBlockHashAndIndex\" method. See https://docs.infura.io/api/networks/ethereum/json-rpc-methods/eth_getunclebyblockhashandindex for details.',\n            { params }\n        );\n\n    return await Promise.resolve(null);\n};\n\nexport { ethGetUncleByBlockHashAndIndex };\n","import { JSONRPCInvalidParams } from '@vechain/sdk-errors';\n\n/**\n * RPC Method eth_getUncleByBlockNumberAndIndex implementation\n *\n * @link [eth_getUncleByBlockNumberAndIndex](https://docs.infura.io/api/networks/ethereum/json-rpc-methods/eth_getunclebyblocknumberandindex)\n *\n * @note\n *  * Standard RPC method `eth_getUncleByBlockNumberAndIndex` support following block numbers: hex number of block, 'earliest', 'latest', 'safe', 'finalized', 'pending'. (@see https://ethereum.org/en/developers/docs/apis/json-rpc#default-block)\n *  * Currently, VeChain only supports hex number of block, 'latest' and 'finalized'.\n *  * We return a constant empty object for now.\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n *                 * params[0]: The block number to get as a hex string or \"latest\" or \"finalized\".\n *                 * params[1]: A hexadecimal equivalent of the integer indicating the uncle's index position.\n * @returns The uncle block at the given block number and index.\n * @throws {JSONRPCInvalidParams}\n */\nconst ethGetUncleByBlockNumberAndIndex = async (\n    params: unknown[]\n): Promise<object | null> => {\n    // Input validation\n    if (\n        params.length !== 2 ||\n        typeof params[0] !== 'string' ||\n        typeof params[1] !== 'string'\n    )\n        throw new JSONRPCInvalidParams(\n            'eth_getUncleByBlockNumberAndIndex',\n            'Invalid input params for \"eth_getUncleByBlockNumberAndIndex\" method. See https://docs.infura.io/api/networks/ethereum/json-rpc-methods/eth_getunclebyblocknumberandindex for details.',\n            { params }\n        );\n\n    return await Promise.resolve(null);\n};\n\nexport { ethGetUncleByBlockNumberAndIndex };\n","import { ThorId } from '@vechain/sdk-core';\nimport { JSONRPCInvalidParams } from '@vechain/sdk-errors';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\n\n/**\n * RPC Method eth_getUncleCountByBlockHash implementation\n *\n * @param params - The standard array of rpc call parameters.\n *                 * params[0]: The block hash to get as a hex string.\n */\nconst ethGetUncleCountByBlockHash = async (\n    params: unknown[]\n): Promise<number> => {\n    // Input validation\n    if (\n        params.length !== 1 ||\n        typeof params[0] !== 'string' ||\n        !ThorId.isValid(params[0])\n    )\n        throw new JSONRPCInvalidParams(\n            'eth_getUncleCountByBlockHash',\n            `Invalid input params for \"eth_getUncleCountByBlockHash\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n\n    return await Promise.resolve(0);\n};\n\nexport { ethGetUncleCountByBlockHash };\n","import { JSONRPCInvalidParams } from '@vechain/sdk-errors';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\n\n/**\n * RPC Method eth_getUncleCountByBlockNumber implementation\n *\n * @param params - The standard array of rpc call parameters.\n *                 * params[0]: The block number to get as a hex string or \"latest\" or \"finalized\".\n */\nconst ethGetUncleCountByBlockNumber = async (\n    params: unknown[]\n): Promise<number> => {\n    // Input validation\n    if (params.length !== 1 || typeof params[0] !== 'string')\n        throw new JSONRPCInvalidParams(\n            'eth_getUncleCountByBlockNumber',\n            `Invalid input params for \"eth_getUncleCountByBlockNumber\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n\n    return await Promise.resolve(0);\n};\n\nexport { ethGetUncleCountByBlockNumber };\n","import { type ThorClient } from '../../../../../thor-client';\nimport { type VeChainProvider } from '../../../../providers/vechain-provider';\nimport {\n    JSONRPCInternalError,\n    JSONRPCMethodNotImplemented,\n    stringifyData\n} from '@vechain/sdk-errors';\n\n/**\n * RPC Method eth_maxPriorityFeePerGas implementation for Galactica hardfork\n * Returns the suggested priority fee per gas in wei.\n * This is calculated based on the current base fee and network conditions.\n *\n * @link [eth_maxPriorityFeePerGas](https://ethereum.github.io/execution-apis/api-documentation/)\n * @param thorClient - The thor client instance to use.\n * @param _params - The standard array of rpc call parameters.\n * @param _provider - The provider instance to use.\n * @returns Suggested priority fee per gas in wei (hex string)\n * @throws {JSONRPCInternalError} | {JSONRPCMethodNotImplemented}\n */\nconst ethMaxPriorityFeePerGas = async (\n    thorClient: ThorClient,\n    _params: unknown[],\n    _provider?: VeChainProvider\n): Promise<string> => {\n    try {\n        // Check if Galactica hardfork has happened\n        const galacticaForked = await thorClient.forkDetector.detectGalactica();\n        if (!galacticaForked) {\n            throw new JSONRPCMethodNotImplemented(\n                'eth_maxPriorityFeePerGas',\n                'Method \"eth_maxPriorityFeePerGas\" is not available before Galactica hardfork.',\n                { url: thorClient.httpClient.baseURL }\n            );\n        }\n\n        return await thorClient.gas.getMaxPriorityFeePerGas();\n    } catch (e) {\n        if (\n            e instanceof JSONRPCInternalError ||\n            e instanceof JSONRPCMethodNotImplemented\n        ) {\n            throw e;\n        }\n        throw new JSONRPCInternalError(\n            'eth_maxPriorityFeePerGas()',\n            'Method \"eth_maxPriorityFeePerGas\" failed.',\n            {\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { ethMaxPriorityFeePerGas };\n","import { JSONRPCInvalidParams, stringifyData } from '@vechain/sdk-errors';\nimport { type VeChainProvider } from '../../../../providers/vechain-provider';\nimport { ethAccounts } from '../eth_accounts/eth_accounts';\n\n/**\n * RPC Method eth_requestAccounts implementation\n *\n * @param provider - Provider with ProviderInternalWallet instance to use.\n * @throws {JSONRPCInvalidParams}\n */\nconst ethRequestAccounts = async (\n    provider?: VeChainProvider\n): Promise<string[]> => {\n    // Get the accounts from the wallet\n    const accounts = await ethAccounts(provider);\n\n    // If there are no accounts, throw error\n    // @NOTE: eth_accounts returns an empty array if there are no accounts OR wallet is not defined.\n    // Here, instead, if there are no accounts into wallet OR wallet is not defined, we throw an error\n    if (accounts.length === 0)\n        throw new JSONRPCInvalidParams(\n            'eth_requestAccounts()',\n            'Method \"eth_requestAccounts\" failed.',\n            {\n                provider: stringifyData(provider)\n            }\n        );\n\n    // Otherwise, return the accounts\n    return accounts;\n};\n\nexport { ethRequestAccounts };\n","import { Hex } from '@vechain/sdk-core';\nimport {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport { type ThorClient } from '../../../../../thor-client';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\n\n/**\n * RPC Method eth_sendRawTransaction implementation\n *\n * @link [eth_sendrawtransaction](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n *                 * params[0]: The signed transaction data as a hex string.\n * @throws {JSONRPCInvalidParams, JSONRPCInternalError}\n */\nconst ethSendRawTransaction = async (\n    thorClient: ThorClient,\n    params: unknown[]\n): Promise<string> => {\n    // Input validation\n    if (params.length !== 1 || typeof params[0] !== 'string')\n        throw new JSONRPCInvalidParams(\n            'eth_sendRawTransaction()',\n            `Invalid input params for \"eth_sendRawTransaction\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n\n    // Invalid transaction encoded data\n    if (!Hex.isValid0x(params[0])) {\n        throw new JSONRPCInvalidParams(\n            'eth_sendRawTransaction()',\n            'Invalid transaction encoded data given as input. Input must be a hex string.',\n            { params }\n        );\n    }\n\n    try {\n        const [signedTransactionData] = params as [string];\n\n        const sentTransaction =\n            await thorClient.transactions.sendRawTransaction(\n                signedTransactionData\n            );\n\n        return sentTransaction.id;\n    } catch (error) {\n        throw new JSONRPCInternalError(\n            'eth_sendRawTransaction()',\n            'Method \"eth_sendRawTransaction\" failed.',\n            {\n                params: stringifyData(params),\n                url: thorClient.httpClient.baseURL\n            },\n            error\n        );\n    }\n};\n\nexport { ethSendRawTransaction };\n","import {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport { type VeChainSigner } from '../../../../../signer';\nimport { type ThorClient } from '../../../../../thor-client';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\nimport { type VeChainProvider } from '../../../../providers/vechain-provider';\nimport { getCachedChainId } from '../eth_chainId';\nimport { type TransactionObjectInput } from './types';\n\n/**\n * RPC Method eth_sendTransaction implementation\n *\n * @link [eth_sendTransaction](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @NOTE: If 'to' address is not provided.\n * It will be assumed that the transaction is a contract creation transaction.\n * The 'data' field of the transaction will be used as the contract initialization code.\n *\n * @NOTE: 'gasPrice' cannot be used together with 'maxPriorityFeePerGas' and 'maxFeePerGas'.\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n *               * params[0]: transaction - object - This describes the transaction info with following properties:\n *                   * to: 20 bytes - Address the transaction is directed to.\n *                   * from: 20 bytes [Required] - Address the transaction is sent from.\n *                   * gas: Hexadecimal value of the gas provided for the transaction execution as hex string.\n *                   * gasPrice: Hexadecimal value of the gasPrice used for each paid gas.\n *                   * value: Hexadecimal of the value sent with this transaction.\n *                   * data: Hash of the method signature and encoded parameters.\n *                   * maxPriorityFeePerGas: Maximum fee per gas the sender is willing to pay to miners in wei. Used in 1559 transactions.\n *                   * maxFeePerGas: The maximum total fee per gas the sender is willing to pay (includes the network / base fee and miner / priority fee) in wei. Used in 1559 transactions.\n * @param provider - The provider instance to use.\n * @throws {JSONRPCInvalidParams, JSONRPCInternalError}\n */\nconst ethSendTransaction = async (\n    thorClient: ThorClient,\n    params: unknown[],\n    provider?: VeChainProvider\n): Promise<string> => {\n    // Input validation\n    if (\n        params === undefined ||\n        params.length !== 1 ||\n        typeof params[0] !== 'object'\n    )\n        throw new JSONRPCInvalidParams(\n            'eth_sendTransaction',\n            `Invalid input params for \"eth_sendTransaction\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n\n    // Provider must be defined\n    if (provider?.wallet === undefined) {\n        throw new JSONRPCInvalidParams(\n            'eth_sendTransaction',\n            'Provider must be defined with a wallet. Ensure that the provider is defined and connected to the network.',\n            { provider }\n        );\n    }\n\n    // From field is required\n    if ((params[0] as TransactionObjectInput).from === undefined) {\n        throw new JSONRPCInvalidParams(\n            'eth_sendTransaction',\n            'From field is required in the transaction object.',\n            { provider }\n        );\n    }\n\n    // default value for value is 0x0\n    if ((params[0] as TransactionObjectInput).value === undefined) {\n        (params[0] as TransactionObjectInput).value = '0x0';\n    }\n\n    // Input params\n    const [transaction] = params as [TransactionObjectInput];\n\n    // Check if the chainId in the transaction object if specified matches the chainId of the network\n    const chainId = await getCachedChainId(thorClient);\n    if (transaction.chainId != null && transaction.chainId !== chainId) {\n        throw new JSONRPCInvalidParams(\n            'eth_sendTransaction',\n            `ChainId in the transaction object does not match the chainId of the network. Expected: ${chainId}, Received: ${transaction.chainId}`,\n            { chainId: transaction.chainId }\n        );\n    }\n\n    try {\n        // Get the signer of the provider\n        const signer = (await provider.getSigner(\n            transaction.from\n        )) as VeChainSigner;\n\n        // Return the result\n        return await signer.sendTransaction(transaction);\n    } catch (error) {\n        throw new JSONRPCInternalError(\n            'eth_sendTransaction()',\n            'Method \"eth_sendTransaction\" failed.',\n            {\n                params: stringifyData(params),\n                url: thorClient.httpClient.baseURL\n            },\n            error\n        );\n    }\n};\n\nexport { ethSendTransaction };\n","import type { ThorClient } from '../../../../../thor-client';\nimport type { VeChainProvider } from '../../../../providers/vechain-provider';\nimport {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport { RPC_DOCUMENTATION_URL } from '../../../../../utils';\nimport type { TransactionObjectInput } from '../eth_sendTransaction';\nimport type { VeChainSigner } from '../../../../../signer';\n\n/**\n * RPC Method eth_signTransaction implementation\n *\n * @link [eth_signTransaction](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n *               * params[0]: transaction - object - This describes the transaction info with following properties:\n *                   * to: 20 bytes - Address the transaction is directed to.\n *                   * from: 20 bytes [Required] - Address the transaction is sent from.\n *                   * gas: Hexadecimal value of the gas provided for the transaction execution as hex string.\n *                   * gasPrice: Hexadecimal value of the gasPrice used for each paid gas.\n *                   * value: Hexadecimal of the value sent with this transaction.\n *                   * data: Hash of the method signature and encoded parameters.\n *                   * nonce: The nonce of the transaction.\n * @param provider - The provider instance to use.\n * @throws {JSONRPCInvalidParams, JSONRPCInternalError}\n */\nconst ethSignTransaction = async (\n    thorClient: ThorClient,\n    params: unknown[],\n    provider?: VeChainProvider\n): Promise<string> => {\n    // Input validation\n    if (params.length !== 1 || typeof params[0] !== 'object')\n        throw new JSONRPCInvalidParams(\n            'eth_signTransaction',\n            `Invalid input params for \"eth_signTransaction\" method. See ${RPC_DOCUMENTATION_URL} for details.`,\n            { params }\n        );\n\n    // Provider must be defined\n    if (provider?.wallet === undefined) {\n        throw new JSONRPCInvalidParams(\n            'eth_signTransaction',\n            'Provider must be defined with a wallet. Ensure that the provider is defined and connected to the network.',\n            { provider }\n        );\n    }\n\n    // From field is required\n    if ((params[0] as TransactionObjectInput).from === undefined) {\n        throw new JSONRPCInvalidParams(\n            'eth_signTransaction',\n            'From field is required in the transaction object.',\n            { provider }\n        );\n    }\n\n    // Input params\n    const [transaction] = params as [TransactionObjectInput];\n\n    try {\n        // Get the signer of the provider\n        const signer = (await provider.getSigner(\n            transaction.from\n        )) as VeChainSigner;\n\n        // Return the result\n        return await signer.signTransaction(transaction);\n    } catch (error) {\n        throw new JSONRPCInternalError(\n            'eth_signTransaction()',\n            'Method \"eth_signTransaction\" failed.',\n            {\n                params: stringifyData(params),\n                url: thorClient.httpClient.baseURL\n            },\n            error\n        );\n    }\n};\n\nexport { ethSignTransaction };\n","import { Address } from '@vechain/sdk-core';\nimport {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport type {\n    TypedDataDomain,\n    TypedDataParameter,\n    VeChainSigner\n} from '../../../../../signer/signers';\nimport type { ThorClient } from '../../../../../thor-client';\nimport type { VeChainProvider } from '../../../../providers/vechain-provider';\n\n/**\n * RPC Method eth_signTypedDataV4 implementation\n *\n * @link [eth_signTypedDataV4](https://docs.metamask.io/wallet/reference/eth_signtypeddata_v4/)\n *\n * @param thorClient - The thor client instance to use.\n * @param params - The standard array of rpc call parameters.\n *               * params[0]: The hex encoded address of the account to sign the typed message.\n *               * params[1] An object or a JSON string containing:\n *                   * types - An array of EIP712Domain object. It is an array specifying one or more (name, version, chainId, verifyingContract) tuples.\n *                   * domain - Contains the domain separator values specified in the EIP712Domain type.\n *                   * primaryType: A string specifying the name of the primary type for the message.\n *                   * message: An object containing the data to sign.\n * @param provider - The provider instance to use.\n * @throws {JSONRPCInvalidParams, JSONRPCInternalError}\n */\nconst ethSignTypedDataV4 = async (\n    thorClient: ThorClient,\n    params: unknown[],\n    provider?: VeChainProvider\n): Promise<string> => {\n    // Input validation\n    if (\n        params.length !== 2 ||\n        typeof params[0] !== 'string' ||\n        !Address.isValid(params[0]) ||\n        (typeof params[1] !== 'object' && typeof params[1] !== 'string')\n    )\n        throw new JSONRPCInvalidParams(\n            'eth_signTypedDataV4',\n            `Invalid input params for \"eth_signTypedDataV4\" method. See https://docs.metamask.io/wallet/reference/eth_signtypeddata_v4/ for details.`,\n            { params }\n        );\n\n    // Provider must be defined\n    if (\n        provider?.wallet === undefined ||\n        (await provider.getSigner(params[0])) === null\n    ) {\n        throw new JSONRPCInvalidParams(\n            'eth_signTypedDataV4',\n            `Provider must be defined with a wallet. Ensure that the provider is defined, connected to the network and has the wallet with the address ${params[0]} into it.`,\n            { provider }\n        );\n    }\n\n    // Input params\n    const [address] = params as [string, unknown];\n    let typedData: {\n        primaryType: string;\n        domain: TypedDataDomain;\n        types: Record<string, TypedDataParameter[]>;\n        message: Record<string, unknown>;\n    };\n\n    // Parse typedData if it's a string\n    if (typeof params[1] === 'string') {\n        try {\n            typedData = JSON.parse(params[1]) as {\n                primaryType: string;\n                domain: TypedDataDomain;\n                types: Record<string, TypedDataParameter[]>;\n                message: Record<string, unknown>;\n            };\n        } catch (error) {\n            throw new JSONRPCInvalidParams(\n                'eth_signTypedData_v4',\n                'Invalid JSON string for typed data parameter',\n                { params },\n                error\n            );\n        }\n    } else {\n        typedData = params[1] as typeof typedData;\n    }\n\n    try {\n        // Get the signer of the provider\n        const signer = (await provider.getSigner(address)) as VeChainSigner;\n\n        // Return the result\n        return await signer.signTypedData(\n            typedData.domain,\n            typedData.types,\n            typedData.message,\n            typedData.primaryType\n        );\n    } catch (error) {\n        throw new JSONRPCInternalError(\n            'eth_signTypedDataV4',\n            'Method \"eth_signTypedDataV4\" failed.',\n            {\n                params: stringifyData(params),\n                url: thorClient.httpClient.baseURL\n            },\n            error\n        );\n    }\n};\n\nexport { ethSignTypedDataV4 };\n","import { Hex } from '@vechain/sdk-core';\nimport {\n    JSONRPCInternalError,\n    JSONRPCInvalidParams,\n    JSONRPCServerError,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport { type ThorClient } from '../../../../../thor-client';\nimport {\n    type FilterOptions,\n    type VeChainProvider\n} from '../../../../providers/vechain-provider';\n\n/**\n * Enumerates the types of subscriptions supported by the`eth_subscribe` RPC method.\n */\nenum SUBSCRIPTION_TYPE {\n    /**\n     * Subscription type for receiving notifications about new blocks added to the blockchain.\n     */\n    NEW_HEADS = 'newHeads',\n\n    /**\n     * Subscription type for receiving log entries that match specific filter criteria,\n     * allowing clients to listen for specific events emitted by smart contracts.\n     */\n    LOGS = 'logs'\n}\n\n/**\n * Defines the parameter types accepted by the `eth_subscribe` RPC method.\n */\ntype ethSubscribeParams = [SUBSCRIPTION_TYPE, string | string[]] | unknown[];\n\n/**\n * Initiates a subscription to the blockchain events based on the specified parameters.\n * This function supports subscriptions to new block headers ('newHeads') and log entries ('logs')\n * that match given filter criteria. It ensures that the provided parameters are valid and that\n * the provider is available before setting up the subscription and generating a unique subscription ID.\n *\n * @link [eth_subscribe](https://docs.infura.io/api/networks/ethereum/json-rpc-methods/subscription-methods/eth_subscribe)\n *\n * @param thorClient - An instance of `ThorClient` used to interact with the blockchain, such as\n *                     retrieving the current best block when setting up a new subscription.\n * @param params - Parameters for the subscription, conforming to `ethSubscribeParams`. The first\n *                 element of the array specifies the type of subscription, and the second element\n *                 (if present) provides additional options, such as filter criteria for log subscriptions.\n * @param provider - An optional `VeChainProvider` instance that contains the subscription manager.\n *                   The subscription manager is used to store and manage active subscriptions.\n *                   If the provider is not provided or is undefined, the function throws an error.\n *\n * @returns A `Promise` that resolves to a string representing the unique ID of the created subscription.\n * @throws {JSONRPCInternalError, JSONRPCInvalidParams, JSONRPCServerError}\n */\nconst ethSubscribe = async (\n    thorClient: ThorClient,\n    params: ethSubscribeParams,\n    provider?: VeChainProvider\n): Promise<string> => {\n    if (provider === undefined) {\n        throw new JSONRPCInternalError(\n            'eth_subscribe()',\n            'Method \"eth_subscribe\" failed. Provider is not defined.',\n            {\n                url: thorClient.httpClient.baseURL,\n                params: stringifyData(params)\n            }\n        );\n    }\n    if (\n        params[0] !== SUBSCRIPTION_TYPE.NEW_HEADS &&\n        params[0] !== SUBSCRIPTION_TYPE.LOGS\n    ) {\n        throw new JSONRPCInvalidParams(\n            'eth_subscribe()',\n            'Method \"eth_subscribe\" failed. Invalid subscription type param.',\n            {\n                url: thorClient.httpClient.baseURL,\n                params: stringifyData(params)\n            }\n        );\n    }\n\n    // I check if a poll instance is already active, if not I set a new starting block number for the subscription\n    if (provider.getPollInstance() === undefined) {\n        const block = await thorClient.blocks.getBestBlockCompressed();\n\n        if (block !== undefined && block !== null) {\n            provider.subscriptionManager.currentBlockNumber = block.number;\n        } else\n            throw new JSONRPCServerError(\n                'eth_subscribe()',\n                'Method \"eth_subscribe\" failed. Best block not available.',\n                {\n                    url: thorClient.httpClient.baseURL,\n                    params: stringifyData(params)\n                }\n            );\n\n        provider.startSubscriptionsPolling();\n    }\n    const subscriptionId: string = Hex.random(16).digits;\n\n    if (params.includes(SUBSCRIPTION_TYPE.NEW_HEADS)) {\n        provider.subscriptionManager.newHeadsSubscription = {\n            subscriptionId,\n            subscription: {\n                type: SUBSCRIPTION_TYPE.NEW_HEADS\n            }\n        };\n    }\n\n    if (params.includes(SUBSCRIPTION_TYPE.LOGS)) {\n        provider.subscriptionManager.logSubscriptions.set(subscriptionId, {\n            type: SUBSCRIPTION_TYPE.LOGS,\n            options: params[1] as FilterOptions\n        });\n    }\n    return subscriptionId;\n};\n\nexport { ethSubscribe };\n","import { HexInt } from '@vechain/sdk-core';\nimport { JSONRPCInternalError, stringifyData } from '@vechain/sdk-errors';\nimport {\n    type CompressedBlockDetail,\n    type ThorClient\n} from '../../../../../thor-client';\nimport { blocksFormatter, type SyncBlockRPC } from '../../../formatter';\nimport { ethChainId } from '../eth_chainId';\n\n/**\n * Check if the block is out of sync in time.\n * A block is considered out of sync if the difference between the current time and the block timestamp is GREATER than 11 seconds.\n *\n * @param block - Block to check\n */\nconst _isBlockNotOutOfSyncInTime = (block: CompressedBlockDetail): boolean => {\n    return Math.floor(Date.now() / 1000) - block.timestamp < 11000;\n};\n\n/**\n * RPC Method eth_syncing implementation\n *\n * @link [eth_syncing](https://ethereum.github.io/execution-apis/api-documentation/)\n *\n * @param thorClient - The thor client instance to use.\n *\n * @note The startingBlock parameter is not supported.\n *\n * @returns Returns an object with the sync status of the node if the node is out-of-sync and is syncing. Returns false when the node is already in sync.\n */\nconst ethSyncing = async (\n    thorClient: ThorClient\n): Promise<boolean | SyncBlockRPC> => {\n    try {\n        // Get the best block and the genesis block\n        const bestBlock = await thorClient.blocks.getBestBlockCompressed();\n        const genesisBlock = await thorClient.blocks.getGenesisBlock();\n\n        // Get the highest block number\n        const highestBlockNumber: string | null =\n            genesisBlock !== null\n                ? HexInt.of(\n                      Math.floor((Date.now() - genesisBlock.timestamp) / 10000)\n                  ).toString()\n                : null;\n\n        // Check the latest block\n        if (bestBlock !== null) {\n            // Check if the node is out of sync\n            if (_isBlockNotOutOfSyncInTime(bestBlock)) return false;\n\n            // Calculate the chainId\n            const chainId = await ethChainId(thorClient);\n\n            return {\n                currentBlock: blocksFormatter.formatToRPCStandard(\n                    bestBlock,\n                    chainId\n                ),\n                highestBlock: highestBlockNumber,\n\n                // Not supported field\n                startingBlock: null\n            };\n        }\n\n        // Strange cases when the fetched best block is null\n        return {\n            currentBlock: null,\n            highestBlock: highestBlockNumber,\n\n            // Not supported field\n            startingBlock: null\n        };\n    } catch (e) {\n        throw new JSONRPCInternalError(\n            'eth_syncing()',\n            'Method \"eth_syncing\" failed.',\n            {\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { ethSyncing };\n","import { JSONRPCInternalError, stringifyData } from '@vechain/sdk-errors';\nimport type { VeChainProvider } from '../../../../providers/vechain-provider';\n\n/**\n * Asynchronously unsubscribes from a VeChain event subscription.\n * This function attempts to unsubscribe from either 'newHeads' or log subscriptions\n * based on the provided `subscriptionId`. If the provider is not available or the\n * `subscriptionId` does not match any active subscriptions, it may throw an error\n * or return `false`, respectively.\n *\n * @link [eth_unsubscribe](https://docs.infura.io/api/networks/ethereum/json-rpc-methods/subscription-methods/eth_unsubscribe)\n *\n * @param params - An array containing the subscription ID as its first element.\n * The subscription ID is used to identify and unsubscribe from the corresponding\n * Ethereum event subscription.\n * @param provider - An optional `VeChainProvider` instance that contains the\n * subscription manager. This manager holds the active subscriptions and is used\n * to unsubscribe from them. If the provider is not provided or is undefined,\n * the function throws an error indicating that the provider is not available.\n * @returns A `Promise` that resolves to `true` if the unsubscription was successful,\n * or `false` if the specified subscription ID does not match any active subscriptions.\n * @throws {JSONRPCInternalError}\n */\nconst ethUnsubscribe = async (\n    params: unknown[],\n    provider?: VeChainProvider\n): Promise<boolean> => {\n    let result: boolean = false;\n\n    if (provider === undefined) {\n        throw new JSONRPCInternalError(\n            'eth_unsubscribe()',\n            'Method \"eth_unsubscribe\" failed. Provider is not defined.',\n            {\n                params: stringifyData(params)\n            }\n        );\n    }\n\n    const subscriptionId = params[0] as string;\n\n    // Unsubscribe from 'newHeads' events if the subscription ID matches the newHeads subscription\n    if (\n        provider.subscriptionManager.newHeadsSubscription !== undefined &&\n        subscriptionId ===\n            provider.subscriptionManager.newHeadsSubscription.subscriptionId\n    ) {\n        provider.subscriptionManager.newHeadsSubscription = undefined;\n        result = true;\n    }\n    // Unsubscribe from log events if the subscription ID matches a log subscription\n    else {\n        result =\n            provider.subscriptionManager.logSubscriptions.delete(\n                subscriptionId\n            );\n    }\n\n    if (!provider.isThereActiveSubscriptions()) {\n        provider.stopSubscriptionsPolling();\n    }\n\n    return await Promise.resolve(result);\n};\n\nexport { ethUnsubscribe };\n","import { JSONRPCInternalError, stringifyData } from '@vechain/sdk-errors';\nimport { type ThorClient } from '../../../../../thor-client';\nimport { Poll } from '../../../../../utils';\n\n/**\n * RPC Method evm_mine implementation\n *\n * @link [evm_mine](https://hardhat.org/hardhat-network/docs/explanation/mining-modes)\n *\n * @param thorClient - The thor client instance to use.\n * @returns The new block or null if the block is not available.\n * @throws {JSONRPCInternalError}\n */\nconst evmMine = async (thorClient: ThorClient): Promise<null> => {\n    try {\n        const head = await thorClient.blocks.getBestBlockCompressed();\n        if (head === null) {\n            throw new JSONRPCInternalError(\n                'evm_mine()',\n                'Method \"evm_mine\" failed. No best block found.',\n                {\n                    url: thorClient.httpClient.baseURL\n                }\n            );\n        }\n\n        await Poll.SyncPoll(() => thorClient.blocks.getHeadBlock()).waitUntil(\n            (result) => {\n                return result !== head;\n            }\n        );\n\n        return null;\n    } catch (e) {\n        if (e instanceof JSONRPCInternalError) {\n            throw e;\n        }\n\n        throw new JSONRPCInternalError(\n            'evm_mine()',\n            'Method \"evm_mine\" failed.',\n            {\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { evmMine };\n","import { JSONRPCInternalError, stringifyData } from '@vechain/sdk-errors';\nimport type { ThorClient } from '../../../../../thor-client';\n\n/**\n * RPC Method net_listening implementation\n *\n * @link [net_listening](https://docs.infura.io/api/networks/ethereum/json-rpc-methods/net_listening)\n *\n * @param thorClient - The thor client instance to use.\n */\nconst netListening = async (thorClient: ThorClient): Promise<boolean> => {\n    try {\n        return await thorClient.nodes.isHealthy();\n    } catch (e) {\n        throw new JSONRPCInternalError(\n            'net_listening()',\n            'Method \"net_listening\" failed.',\n            {\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { netListening };\n","import { type ThorClient } from '../../../../../thor-client';\nimport { JSONRPCInternalError, stringifyData } from '@vechain/sdk-errors';\n\n/**\n * RPC Method net_peerCount implementation\n *\n * @link [net_peerCount](https://docs.infura.io/api/networks/ethereum/json-rpc-methods/net_peercount)\n *\n * @param thorClient - The thor client instance to use.\n */\nconst netPeerCount = async (thorClient: ThorClient): Promise<number> => {\n    try {\n        const peers = await thorClient.nodes.getNodes();\n        return peers.length;\n    } catch (e) {\n        throw new JSONRPCInternalError(\n            'net_peerCount()',\n            'Method \"net_peerCount\" failed.',\n            {\n                url: thorClient.httpClient.baseURL,\n                innerError: stringifyData(e)\n            }\n        );\n    }\n};\n\nexport { netPeerCount };\n","import { type ThorClient } from '../../../../../thor-client';\nimport { ethChainId } from '../eth_chainId';\n\n/**\n * RPC Method net_version implementation\n *\n * @link [net_version](https://docs.infura.io/networks/ethereum/json-rpc-methods/net_version)\n *\n * @param thorClient - ThorClient instance.\n *\n * @returns The net version (equivalent to chain id in our case).\n */\nconst netVersion = async (thorClient: ThorClient): Promise<string> => {\n    return await ethChainId(thorClient);\n};\n\nexport { netVersion };\n","/**\n * RPC Method txpool_content implementation\n *\n * @link [txpool_content](https://www.quicknode.com/docs/ethereum/txpool_content)\n *\n * @note\n *  * We return a constant empty object for now.\n *\n * @returns The transaction pool status\n */\nconst txPoolContent = async (): Promise<object> => {\n    return await Promise.resolve({});\n};\n\nexport { txPoolContent };\n","import { JSONRPCInvalidParams } from '@vechain/sdk-errors';\nimport { Address } from '@vechain/sdk-core';\n\n/**\n * RPC Method txpool_contentFrom implementation\n *\n * @link [txpool_contentFrom](https://www.quicknode.com/docs/ethereum/txpool_contentFrom)\n *\n * @note\n *  * We return a constant empty object for now.\n *\n * @param params - The standard array of rpc call parameters.\n * params[0]: The address to get the transaction pool status from\n * @returns The transaction pool status\n */\nconst txPoolContentFrom = async (params: unknown[]): Promise<object> => {\n    // Validate input\n    if (\n        params.length !== 1 ||\n        typeof params[0] !== 'string' ||\n        !Address.isValid(params[0])\n    )\n        throw new JSONRPCInvalidParams(\n            'txpool_contentFrom()',\n            `Invalid input params for \"txpool_contentFrom\" method. See https://www.quicknode.com/docs/ethereum/txpool_contentFrom for details.`,\n            { params }\n        );\n    return await Promise.resolve({});\n};\n\nexport { txPoolContentFrom };\n","/**\n * RPC Method txpool_inspect implementation\n *\n * @link [txpool_inspect](https://www.quicknode.com/docs/ethereum/txpool_inspect)\n *\n * @note\n *  * We return a constant empty object for now.\n *\n * @returns The transaction pool status\n */\nconst txPoolInspect = async (): Promise<object> => {\n    return await Promise.resolve({});\n};\n\nexport { txPoolInspect };\n","/**\n * RPC Method txpool_status implementation\n *\n * @link [txpool_status](https://www.quicknode.com/docs/ethereum/txpool_status)\n *\n * @note\n *  * We return a constant empty object for now.\n *\n * @returns The transaction pool status\n */\nconst txPoolStatus = async (): Promise<object> => {\n    return await Promise.resolve({});\n};\n\nexport { txPoolStatus };\n","/**\n * RPC Method web3_clientVersion implementation\n *\n * @link [web3_clientVersion](https://docs.infura.io/networks/ethereum/json-rpc-methods/web3_clientversion)\n *\n * @returns A string representing the current client version.\n */\nconst web3ClientVersion = async (): Promise<string> => {\n    return await Promise.resolve('thor');\n};\n\nexport { web3ClientVersion };\n","import { JSONRPCInvalidParams } from '@vechain/sdk-errors';\nimport { Hex, Keccak256 } from '@vechain/sdk-core';\n\n/**\n * RPC Method web3_sha3 implementation\n *\n * @link [web3_sha3](https://docs.alchemy.com/reference/web3-sha3)\n * @param params - The standard array of rpc call parameters.\n *                * params[0]: The data to hash.\n * @returns A string representing the current client version.\n */\nconst web3Sha3 = async (params: unknown[]): Promise<string> => {\n    // Input validation\n    if (\n        params.length !== 1 ||\n        typeof params[0] !== 'string' ||\n        !Hex.isValid(params[0])\n    )\n        throw new JSONRPCInvalidParams(\n            'web3_sha3',\n            `Invalid input params for \"web3_sha3\" method. See 'https://docs.alchemy.com/reference/web3-sha3' for details.`,\n            { params }\n        );\n\n    return await Promise.resolve(Keccak256.of(params[0]).toString());\n};\n\nexport { web3Sha3 };\n","import { type ThorClient } from '../../../thor-client';\nimport { type FeeHistoryResponse } from '../../../thor-client/gas/types';\nimport { type VeChainProvider } from '../../providers/vechain-provider';\nimport { RPC_METHODS } from '../const/rpc-mapper/rpc-methods';\nimport {\n    type BlocksRPC,\n    type LogsRPC,\n    type SyncBlockRPC,\n    type TracerReturnTypeRPC,\n    type TransactionReceiptRPC,\n    type TransactionRPC\n} from '../formatter';\nimport {\n    debugTraceBlockByHash,\n    debugTraceBlockByNumber,\n    debugTraceCall,\n    debugTraceTransaction,\n    ethAccounts,\n    ethBlockNumber,\n    ethCall,\n    ethChainId,\n    ethEstimateGas,\n    ethGasPrice,\n    ethGetBalance,\n    ethGetBlockByHash,\n    ethGetBlockByNumber,\n    ethGetBlockReceipts,\n    ethGetBlockTransactionCountByHash,\n    ethGetBlockTransactionCountByNumber,\n    ethGetCode,\n    ethGetLogs,\n    ethGetStorageAt,\n    ethGetTransactionByBlockHashAndIndex,\n    ethGetTransactionByBlockNumberAndIndex,\n    ethGetTransactionByHash,\n    ethGetTransactionCount,\n    ethGetTransactionReceipt,\n    ethGetUncleByBlockHashAndIndex,\n    ethGetUncleByBlockNumberAndIndex,\n    ethGetUncleCountByBlockHash,\n    ethGetUncleCountByBlockNumber,\n    ethRequestAccounts,\n    ethSendRawTransaction,\n    ethSendTransaction,\n    ethSignTransaction,\n    ethSignTypedDataV4,\n    ethSubscribe,\n    ethSyncing,\n    ethUnsubscribe,\n    evmMine,\n    netListening,\n    netPeerCount,\n    netVersion,\n    txPoolContent,\n    txPoolContentFrom,\n    txPoolInspect,\n    txPoolStatus,\n    web3ClientVersion,\n    web3Sha3\n} from './methods';\nimport { ethFeeHistory } from './methods/eth_feeHistory/eth_feeHistory';\nimport { ethMaxPriorityFeePerGas } from './methods/eth_maxPriorityFeePerGas/eth_maxPriorityFeePerGas';\n\ntype MethodHandlerType<TParams, TReturnType> = (\n    params: TParams[]\n) => Promise<TReturnType>;\n\n/**\n * Map of RPC methods to their implementations with the SDK.\n * We can consider this as an \"RPC Mapper\" for the SDK.\n *\n * List of all RPC methods:\n * * https://eth.wiki/json-rpc/API\n * * https://ethereum.github.io/execution-apis/api-documentation/\n *\n * @param thorClient - ThorClient instance.\n * @param provider - Provider instance. It is optional because the majority of the methods do not require a provider.\n */\nconst RPCMethodsMap = (\n    thorClient: ThorClient,\n    provider?: VeChainProvider\n): Record<string, MethodHandlerType<unknown, unknown>> => {\n    /**\n     * Returns a map of RPC methods to their implementations with our SDK.\n     */\n    return {\n        [RPC_METHODS.eth_blockNumber]: async (): Promise<string> => {\n            return await ethBlockNumber(thorClient);\n        },\n\n        [RPC_METHODS.eth_chainId]: async (): Promise<string> => {\n            return await ethChainId(thorClient);\n        },\n\n        [RPC_METHODS.eth_getBalance]: async (params): Promise<string> => {\n            return await ethGetBalance(thorClient, params);\n        },\n\n        [RPC_METHODS.eth_getCode]: async (params): Promise<string> => {\n            return await ethGetCode(thorClient, params);\n        },\n\n        [RPC_METHODS.eth_getStorageAt]: async (params): Promise<string> => {\n            return await ethGetStorageAt(thorClient, params);\n        },\n\n        [RPC_METHODS.eth_estimateGas]: async (params): Promise<string> => {\n            return await ethEstimateGas(thorClient, params);\n        },\n\n        [RPC_METHODS.eth_call]: async (params): Promise<string> => {\n            return await ethCall(thorClient, params);\n        },\n\n        [RPC_METHODS.eth_sendRawTransaction]: async (\n            params\n        ): Promise<string> => {\n            return await ethSendRawTransaction(thorClient, params);\n        },\n\n        [RPC_METHODS.eth_getLogs]: async (params): Promise<LogsRPC[]> => {\n            return await ethGetLogs(thorClient, params);\n        },\n\n        [RPC_METHODS.eth_getBlockByHash]: async (\n            params\n        ): Promise<BlocksRPC | null> => {\n            return await ethGetBlockByHash(thorClient, params);\n        },\n\n        [RPC_METHODS.eth_getBlockByNumber]: async (\n            params\n        ): Promise<BlocksRPC | null> => {\n            return await ethGetBlockByNumber(thorClient, params);\n        },\n\n        [RPC_METHODS.eth_accounts]: async (): Promise<string[]> => {\n            return await ethAccounts(provider);\n        },\n\n        [RPC_METHODS.eth_gasPrice]: async (): Promise<string> => {\n            return await ethGasPrice(thorClient);\n        },\n\n        [RPC_METHODS.eth_getTransactionByHash]: async (\n            params\n        ): Promise<TransactionRPC | null> => {\n            return await ethGetTransactionByHash(thorClient, params);\n        },\n\n        [RPC_METHODS.eth_getTransactionCount]: async (\n            params\n        ): Promise<string> => {\n            return await ethGetTransactionCount(params);\n        },\n\n        [RPC_METHODS.eth_getTransactionReceipt]: async (\n            params\n        ): Promise<TransactionReceiptRPC | null> => {\n            return await ethGetTransactionReceipt(thorClient, params);\n        },\n\n        [RPC_METHODS.eth_sendTransaction]: async (params): Promise<string> => {\n            return await ethSendTransaction(thorClient, params, provider);\n        },\n\n        [RPC_METHODS.eth_syncing]: async (): Promise<\n            boolean | SyncBlockRPC\n        > => {\n            return await ethSyncing(thorClient);\n        },\n\n        [RPC_METHODS.net_version]: async (): Promise<string> => {\n            return await netVersion(thorClient);\n        },\n\n        [RPC_METHODS.web3_clientVersion]: async (): Promise<string> => {\n            return await web3ClientVersion();\n        },\n\n        [RPC_METHODS.eth_subscribe]: async (params): Promise<string> => {\n            return await ethSubscribe(thorClient, params, provider);\n        },\n\n        [RPC_METHODS.eth_unsubscribe]: async (params) => {\n            return await ethUnsubscribe(params, provider);\n        },\n\n        [RPC_METHODS.debug_traceTransaction]: async (\n            params\n        ): Promise<\n            TracerReturnTypeRPC<'call'> | TracerReturnTypeRPC<'prestate'>\n        > => {\n            return await debugTraceTransaction(thorClient, params);\n        },\n\n        [RPC_METHODS.debug_traceCall]: async (\n            params\n        ): Promise<\n            TracerReturnTypeRPC<'call'> | TracerReturnTypeRPC<'prestate'>\n        > => {\n            return await debugTraceCall(thorClient, params);\n        },\n\n        [RPC_METHODS.evm_increaseTime]: async (): Promise<null> => {\n            // @see https://docs.vechain.org/core-concepts/evm-compatibility/test-coverage/hardhat-specific/evm_increasetime\n            // VeChain does not support evm_increaseTime, so we use evm_mine instead\n            // This is a workaround to be able to use hardhat's evm_increaseTime\n            return await evmMine(thorClient);\n        },\n\n        [RPC_METHODS.evm_mine]: async (): Promise<null> => {\n            return await evmMine(thorClient);\n        },\n\n        [RPC_METHODS.eth_getBlockTransactionCountByHash]: async (\n            params\n        ): Promise<number> => {\n            return await ethGetBlockTransactionCountByHash(thorClient, params);\n        },\n\n        [RPC_METHODS.eth_getBlockTransactionCountByNumber]: async (\n            params\n        ): Promise<number> => {\n            return await ethGetBlockTransactionCountByNumber(\n                thorClient,\n                params\n            );\n        },\n\n        [RPC_METHODS.eth_getTransactionByBlockHashAndIndex]: async (\n            params\n        ): Promise<TransactionRPC | null> => {\n            return await ethGetTransactionByBlockHashAndIndex(\n                thorClient,\n                params\n            );\n        },\n\n        [RPC_METHODS.eth_getTransactionByBlockNumberAndIndex]: async (\n            params\n        ): Promise<TransactionRPC | null> => {\n            return await ethGetTransactionByBlockNumberAndIndex(\n                thorClient,\n                params\n            );\n        },\n\n        [RPC_METHODS.eth_getUncleByBlockHashAndIndex]: async (\n            params\n        ): Promise<object | null> => {\n            return await ethGetUncleByBlockHashAndIndex(params);\n        },\n\n        [RPC_METHODS.eth_getUncleByBlockNumberAndIndex]: async (\n            params\n        ): Promise<object | null> => {\n            return await ethGetUncleByBlockNumberAndIndex(params);\n        },\n\n        [RPC_METHODS.eth_getUncleCountByBlockHash]: async (\n            params\n        ): Promise<number> => {\n            return await ethGetUncleCountByBlockHash(params);\n        },\n\n        [RPC_METHODS.eth_getUncleCountByBlockNumber]: async (\n            params\n        ): Promise<number> => {\n            return await ethGetUncleCountByBlockNumber(params);\n        },\n\n        [RPC_METHODS.eth_requestAccounts]: async (): Promise<string[]> => {\n            return await ethRequestAccounts(provider);\n        },\n\n        [RPC_METHODS.net_listening]: async (): Promise<boolean> => {\n            return await netListening(thorClient);\n        },\n\n        [RPC_METHODS.net_peerCount]: async (): Promise<number> => {\n            return await netPeerCount(thorClient);\n        },\n\n        [RPC_METHODS.eth_getBlockReceipts]: async (\n            params\n        ): Promise<TransactionReceiptRPC[] | null> => {\n            return await ethGetBlockReceipts(thorClient, params);\n        },\n\n        [RPC_METHODS.eth_signTransaction]: async (params): Promise<string> => {\n            return await ethSignTransaction(thorClient, params, provider);\n        },\n\n        [RPC_METHODS.web3_sha3]: async (params): Promise<string> => {\n            return await web3Sha3(params);\n        },\n\n        [RPC_METHODS.txpool_inspect]: async (): Promise<object> => {\n            return await txPoolInspect();\n        },\n\n        [RPC_METHODS.txpool_content]: async (): Promise<object> => {\n            return await txPoolContent();\n        },\n\n        [RPC_METHODS.txpool_contentFrom]: async (params): Promise<object> => {\n            return await txPoolContentFrom(params);\n        },\n\n        [RPC_METHODS.txpool_status]: async (): Promise<object> => {\n            return await txPoolStatus();\n        },\n\n        [RPC_METHODS.debug_traceBlockByHash]: async (\n            params\n        ): Promise<\n            Array<{\n                txHash: string;\n                result:\n                    | TracerReturnTypeRPC<'call'>\n                    | TracerReturnTypeRPC<'prestate'>;\n            }>\n        > => {\n            return await debugTraceBlockByHash(thorClient, params);\n        },\n\n        [RPC_METHODS.debug_traceBlockByNumber]: async (\n            params\n        ): Promise<\n            Array<{\n                txHash: string;\n                result:\n                    | TracerReturnTypeRPC<'call'>\n                    | TracerReturnTypeRPC<'prestate'>;\n            }>\n        > => {\n            return await debugTraceBlockByNumber(thorClient, params);\n        },\n\n        [RPC_METHODS.eth_signTypedData_v4]: async (params): Promise<string> => {\n            return await ethSignTypedDataV4(thorClient, params, provider);\n        },\n\n        [RPC_METHODS.eth_maxPriorityFeePerGas]: async (\n            params\n        ): Promise<string> => {\n            return await ethMaxPriorityFeePerGas(thorClient, params, provider);\n        },\n\n        [RPC_METHODS.eth_feeHistory]: async (\n            params\n        ): Promise<FeeHistoryResponse> => {\n            return await ethFeeHistory(thorClient, params, provider);\n        }\n    };\n};\nexport { RPCMethodsMap };\n","import { HexInt } from '@vechain/sdk-core';\nimport {\n    JSONRPCMethodNotFound,\n    JSONRPCMethodNotImplemented\n} from '@vechain/sdk-errors';\nimport { EventEmitter } from 'events';\nimport { type VeChainSigner } from '../../../signer';\nimport {\n    type CompressedBlockDetail,\n    type ThorClient\n} from '../../../thor-client';\nimport { type EventPoll, Poll, vnsUtils } from '../../../utils';\nimport {\n    type EIP1193ProviderMessage,\n    type EIP1193RequestArguments\n} from '../../eip1193';\nimport { type ProviderInternalWallet } from '../../helpers';\nimport {\n    ethGetLogs,\n    POLLING_INTERVAL,\n    RPC_METHODS,\n    RPCMethodsMap\n} from '../../utils';\nimport {\n    type FilterOptions,\n    type SubscriptionEvent,\n    type SubscriptionManager\n} from './types';\n\n/**\n * Our core provider class for VeChain\n */\nclass VeChainProvider extends EventEmitter implements EIP1193ProviderMessage {\n    public readonly subscriptionManager: SubscriptionManager = {\n        logSubscriptions: new Map(),\n        currentBlockNumber: 0\n    };\n\n    /**\n     * Poll instance for subscriptions\n     *\n     * @private\n     */\n    private pollInstance?: EventPoll<SubscriptionEvent[]>;\n\n    /**\n     * Constructor for VeChainProvider\n     *\n     * @param thorClient - ThorClient instance.\n     * @param wallet - ProviderInternalWallet instance. It is optional because the majority of the methods do not require a wallet.\n     * @param enableDelegation - Enable fee delegation or not.\n     * @throws {JSONRPCInvalidParams}\n     *\n     */\n    constructor(\n        readonly thorClient: ThorClient,\n        readonly wallet?: ProviderInternalWallet,\n        readonly enableDelegation: boolean = false\n    ) {\n        super();\n    }\n\n    /**\n     * Destroys the provider by closing the thorClient and stopping the provider poll instance if present.\n     * This is because thorClient and the provider might be initialized with a polling interval.\n     */\n    public destroy(): void {\n        this.thorClient.destroy();\n        if (this.pollInstance !== undefined) {\n            this.pollInstance.stopListen();\n            this.pollInstance = undefined;\n        }\n    }\n\n    /**\n     * This method is used to send a request to the provider.\n     * Basically, it is a wrapper around the RPCMethodsMap.\n     *\n     * @param args - Method and parameters to be used for the request.\n     * @returns The result of the request.\n     * @throws {JSONRPCMethodNotFound}\n     */\n    public async request(args: EIP1193RequestArguments): Promise<unknown> {\n        // Check if the method is supported\n        if (\n            !Object.values(RPC_METHODS)\n                .map((key) => key.toString())\n                .includes(args.method)\n        ) {\n            const error = new JSONRPCMethodNotFound(\n                'VeChainProvider.request()',\n                'Method not found',\n                { code: -32601, message: 'Method not found' }\n            );\n\n            // Override the error message with our custom formatted message\n            throw error;\n        }\n\n        const methodsMap = RPCMethodsMap(this.thorClient, this);\n\n        // If method is in enum but not in map, throw \"not implemented\"\n        if (!(args.method in methodsMap)) {\n            throw new JSONRPCMethodNotImplemented(\n                args.method,\n                'Method not implemented',\n                {\n                    code: -32004,\n                    message: 'Method not supported'\n                }\n            );\n        }\n\n        // Get the method from the RPCMethodsMap and call it\n        return await methodsMap[args.method](args.params as unknown[]);\n    }\n\n    /**\n     * Initializes and starts the polling mechanism for subscription events.\n     * This method sets up an event poll that periodically checks for new events related to active\n     * subscriptions, such as 'newHeads' or log subscriptions. When new data is available, it emits\n     * these events to listeners.\n     *\n     * This method leverages the `Poll.createEventPoll` utility to create the polling mechanism,\n     * which is then started by invoking `startListen` on the poll instance.\n     */\n    public startSubscriptionsPolling(): boolean {\n        let result = false;\n        if (this.pollInstance === undefined) {\n            this.pollInstance = Poll.createEventPoll(async () => {\n                const data: SubscriptionEvent[] = [];\n\n                const currentBlock = await this.getCurrentBlock();\n\n                if (currentBlock !== null) {\n                    if (\n                        this.subscriptionManager.newHeadsSubscription !==\n                        undefined\n                    ) {\n                        data.push({\n                            method: 'eth_subscription',\n                            params: {\n                                subscription:\n                                    this.subscriptionManager\n                                        .newHeadsSubscription.subscriptionId,\n                                result: currentBlock\n                            }\n                        });\n                    }\n                    if (this.subscriptionManager.logSubscriptions.size > 0) {\n                        const logs = await this.getLogsRPC();\n                        data.push(...logs);\n                    }\n\n                    this.subscriptionManager.currentBlockNumber++;\n                }\n                return data;\n            }, POLLING_INTERVAL).onData(\n                (subscriptionEvents: SubscriptionEvent[]) => {\n                    subscriptionEvents.forEach((event) => {\n                        this.emit('message', event);\n                    });\n                }\n            );\n\n            this.pollInstance.startListen();\n            result = true;\n        }\n        return result;\n    }\n\n    /**\n     * Stops the polling mechanism for subscription events.\n     * This method stops the polling mechanism for subscription events, if it is active.\n     *\n     * @returns {boolean} A boolean indicating whether the polling mechanism was stopped.\n     */\n    public stopSubscriptionsPolling(): boolean {\n        let result = false;\n        if (this.pollInstance !== undefined) {\n            this.pollInstance.stopListen();\n            this.pollInstance = undefined;\n            result = true;\n        }\n        return result;\n    }\n\n    /**\n     * Checks if there are active subscriptions.\n     * This method checks if there are any active log subscriptions or a new heads subscription.\n     *\n     * @returns {boolean} A boolean indicating whether there are active subscriptions.\n     */\n    public isThereActiveSubscriptions(): boolean {\n        return (\n            this.subscriptionManager.logSubscriptions.size > 0 ||\n            this.subscriptionManager.newHeadsSubscription !== undefined\n        );\n    }\n\n    /**\n     * Returns the poll instance for subscriptions.\n     */\n    public getPollInstance(): EventPoll<SubscriptionEvent[]> | undefined {\n        return this.pollInstance;\n    }\n\n    /**\n     * Fetches logs for all active log subscriptions managed by `subscriptionManager`.\n     * This method iterates over each log subscription, constructs filter options based on the\n     * subscription details, and then queries for logs using these filter options.\n     *\n     * Each log query is performed asynchronously, and the method waits for all queries to complete\n     * before returning. The result for each subscription is encapsulated in a `SubscriptionEvent`\n     * object, which includes the subscription ID and the fetched logs.\n     *\n     * This function is intended to be called when there's a need to update or fetch the latest\n     * logs for all active subscriptions, typically in response to a new block being mined or\n     * at regular intervals to keep subscription data up to date.\n     *\n     * @returns {Promise<SubscriptionEvent[]>} A promise that resolves to an array of `SubscriptionEvent`\n     * objects, each containing the subscription ID and the corresponding logs fetched for that\n     * subscription. The promise resolves to an empty array if there are no active log subscriptions.\n     */\n    private async getLogsRPC(): Promise<SubscriptionEvent[]> {\n        // Convert the logSubscriptions Map to an array of promises, each promise corresponds to a log fetch operation\n        const promises = Array.from(\n            this.subscriptionManager.logSubscriptions.entries()\n        ).map(async ([subscriptionId, subscriptionDetails]) => {\n            const currentBlock = HexInt.of(\n                this.subscriptionManager.currentBlockNumber\n            ).toString();\n            // Construct filter options for the Ethereum logs query based on the subscription details\n            const filterOptions: FilterOptions = {\n                address: subscriptionDetails.options?.address, // Contract address to filter the logs by\n                fromBlock: currentBlock,\n                toBlock: currentBlock,\n                topics: subscriptionDetails.options?.topics // Topics to filter the logs by\n            };\n\n            // Fetch logs based on the filter options and construct a SubscriptionEvent object\n            return {\n                method: 'eth_subscription',\n                params: {\n                    subscription: subscriptionId, // Subscription ID\n                    result: await ethGetLogs(this.thorClient, [filterOptions]) // The actual log data fetched from Ethereum node\n                }\n            };\n        });\n\n        // Wait for all log fetch operations to complete and return an array of SubscriptionEvent objects\n        const subscriptionEvents = await Promise.all(promises);\n        // Filter out empty results\n        return subscriptionEvents.filter(\n            (event) => event.params.result.length > 0\n        );\n    }\n\n    /**\n     * Fetches the current block details from the VeChain node.\n     *\n     * @private\n     */\n    private async getCurrentBlock(): Promise<CompressedBlockDetail | null> {\n        // Initialize the result to null, indicating no block found initially\n        let result: CompressedBlockDetail | null = null;\n\n        // Proceed only if there are active log subscriptions or a new heads subscription is present\n        if (this.isThereActiveSubscriptions()) {\n            // Fetch the block details for the current block number\n            const block = await this.thorClient.blocks.getBlockCompressed(\n                this.subscriptionManager.currentBlockNumber\n            );\n\n            // If the block is successfully fetched (not undefined or null), update the result.\n            if (block !== undefined && block !== null) {\n                result = block; // Set the fetched block as the result\n            }\n        }\n\n        // Return the fetched block details or null if no block was fetched\n        return result;\n    }\n\n    /**\n     * Get a signer into the internal wallet provider\n     * for the given address.\n     *\n     * @param addressOrIndex - Address of index of the account.\n     * @returns The signer for the given address.\n     */\n    async getSigner(\n        addressOrIndex?: string | number\n    ): Promise<VeChainSigner | null> {\n        if (this.wallet === undefined) {\n            return null;\n        }\n        return await this.wallet?.getSigner(this, addressOrIndex);\n    }\n\n    /**\n     * Use vet.domains to resolve name to address\n     * @param vnsName - The name to resolve\n     * @returns the address for a name or null\n     */\n    async resolveName(vnsName: string): Promise<null | string> {\n        return await vnsUtils.resolveName(this.thorClient, vnsName);\n    }\n\n    /**\n     * Use vet.domains to look up a verified primary name for an address\n     * @param address - The address to lookup\n     * @returns the primary name for an address or null\n     */\n    async lookupAddress(address: string): Promise<null | string> {\n        return await vnsUtils.lookupAddress(this.thorClient, address);\n    }\n}\n\nexport { VeChainProvider };\n","import {\n    JSONRPCInternalError,\n    stringifyData,\n    VechainSDKError\n} from '@vechain/sdk-errors';\nimport { VeChainSDKLogger } from '@vechain/sdk-logging';\nimport { SimpleHttpClient } from '../../../http';\nimport { ThorClient } from '../../../thor-client';\nimport type { EIP1193RequestArguments } from '../../eip1193';\nimport { type ProviderInternalWallet } from '../../helpers';\nimport { VeChainProvider } from '../vechain-provider/vechain-provider';\nimport {\n    type BuildHardhatErrorFunction,\n    type JsonRpcRequest,\n    type JsonRpcResponse\n} from './types';\n\n/**\n * This class is a wrapper for the VeChainProvider that Hardhat uses.\n *\n * It exposes the interface that Hardhat expects, and uses the VeChainProvider as wrapped provider.\n */\nclass HardhatVeChainProvider extends VeChainProvider {\n    /**\n     * Debug mode.\n     */\n    debug: boolean;\n\n    /**\n     * The function to use to build Hardhat errors.\n     */\n    buildHardhatErrorFunctionCallback: BuildHardhatErrorFunction;\n\n    /**\n     * RPC configuration.\n     */\n    rpcConfiguration: {\n        ethGetTransactionCountMustReturn0: boolean;\n    };\n\n    /**\n     * Constructor with the network configuration.\n     *\n     * @param walletToUse - The wallet to use.\n     * @param nodeUrl - The node url to use\n     * @param buildHardhatErrorFunctionCallback - The function to use to build Hardhat errors.\n     * @param debug - Debug mode.\n     * @param enableDelegation - Enable fee delegation or not.\n     */\n    constructor(\n        walletToUse: ProviderInternalWallet,\n        nodeUrl: string,\n        buildHardhatErrorFunctionCallback: BuildHardhatErrorFunction,\n        debug: boolean = false,\n        enableDelegation: boolean = false,\n        rpcConfiguration = {\n            // By default, the eth_getTransactionCount method returns a random number.\n            ethGetTransactionCountMustReturn0: false\n        }\n    ) {\n        // Initialize the provider with the network configuration.\n        super(\n            new ThorClient(new SimpleHttpClient(nodeUrl)),\n            walletToUse,\n            enableDelegation\n        );\n\n        // Save the debug mode.\n        this.debug = debug;\n\n        // Save the RPC configuration.\n        this.rpcConfiguration = rpcConfiguration;\n\n        // Save the buildHardhatErrorFunction.\n        this.buildHardhatErrorFunctionCallback =\n            buildHardhatErrorFunctionCallback;\n    }\n\n    /**\n     * Overload of the send method\n     *\n     * @param method - The method to call.\n     * @param params - The parameters to pass to the method.\n     */\n    async send(method: string, params?: unknown[]): Promise<unknown> {\n        return await this.request({\n            method,\n            params\n        });\n    }\n\n    /**\n     * Overload of the sendAsync method.\n     * It is the same of the send method, but with a callback.\n     * Instead of returning the result, it calls the callback with the result.\n     *\n     * @param payload - The request payload (it contains method and params as 'send' method).\n     * @param callback - The callback to call with the result.\n     */\n    async sendAsync(\n        payload: JsonRpcRequest,\n        callback: (error: unknown, response: JsonRpcResponse) => void\n    ): Promise<void> {\n        try {\n            const result = await this.request({\n                method: payload.method,\n                params: payload.params\n            });\n\n            // Execute the callback with the result\n            callback(null, {\n                id: payload.id,\n                jsonrpc: '2.0',\n                result\n            });\n        } catch (e) {\n            // Execute the callback with the error\n            callback(e, {\n                id: payload.id,\n                jsonrpc: '2.0'\n            });\n        }\n    }\n\n    /**\n     * It sends the request through the VeChainProvider.\n     *\n     * @param args - The request arguments.\n     */\n    async request(args: EIP1193RequestArguments): Promise<unknown> {\n        // Must return 0 with the eth_getTransactionCount method\n        const mustReturn0 =\n            this.rpcConfiguration.ethGetTransactionCountMustReturn0 &&\n            args.method === 'eth_getTransactionCount';\n\n        try {\n            // Debug mode - get the request and the accounts\n            if (this.debug) {\n                const accounts = await (\n                    this.wallet as ProviderInternalWallet\n                ).getAddresses();\n                const gasPayer = await (\n                    this.wallet as ProviderInternalWallet\n                ).getGasPayer();\n\n                VeChainSDKLogger('log').log({\n                    title: `Sending request - ${args.method}`,\n                    messages: [\n                        `params: ${stringifyData(args.params)}`,\n                        `accounts: ${stringifyData(accounts)}`,\n                        `gasPayer: ${stringifyData(gasPayer)}`,\n                        `url: ${this.thorClient.httpClient.baseURL}`\n                    ]\n                });\n            }\n            // Send the request\n            const result = mustReturn0\n                ? '0x0'\n                : await super.request({\n                      method: args.method,\n                      params: args.params as never\n                  });\n\n            // Debug mode - get the result\n            if (this.debug) {\n                VeChainSDKLogger('log').log({\n                    title: `Get request - ${args.method} result`,\n                    messages: [`result: ${stringifyData(result)}`]\n                });\n            }\n\n            return result;\n        } catch (error) {\n            // Debug the error\n            if (this.debug) {\n                VeChainSDKLogger('error').log(\n                    new JSONRPCInternalError(\n                        args.method,\n                        `Error on request - ${args.method}`,\n                        {\n                            args\n                        }\n                    )\n                );\n            }\n\n            if (error instanceof VechainSDKError) {\n                // Throw the error\n                // eth_call is a special case, @nomiclabs/truffle-contract uses this error to revert the transaction\n                // @NOTE: Review whether makes sense to handle this case in a different way (error message per RPC method?)\n                if (args.method === 'eth_call') {\n                    throw this.buildHardhatErrorFunctionCallback(\n                        'revert',\n                        error\n                    );\n                }\n                throw this.buildHardhatErrorFunctionCallback(\n                    `Error on request ${args.method}: ${error.innerError}`,\n                    error\n                );\n            }\n        }\n    }\n}\n\nexport { HardhatVeChainProvider };\n"]}